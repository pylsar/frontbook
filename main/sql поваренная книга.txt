запросы всегда заглавными SELECT
базы и названия маленькими my_base
пробела нет, если надо разделить ставим _
в конце всегда ставим ;
текст пишется в апострофах'' для колонок VARCHAR
CHARACTER и VARCHAR значения включаются в одиночные кавычки как "текст". Различие между CHAR и VARCHAR в том, что CHAR должен 
резервировать достаточное количество памяти для максимальной длины строки, а VARCHAR распределяет память так как это необходимо.
запись - это синоним строки.
поле - это синоним столбца


DESC название таблицы; -выводит информацию о таблице
SHOW DATABASES; - показать базы данных
CREATE DATABASE mma; - создать базу данных мма
CREATE DATABASE IF NOT EXISTS articule; - для того, чтобы не возникала ошибка, если указанная база данных или таблица уже существует
DROP DATABASE mma; - удалить базу данных мма
USE mma; - переходим в базу данных мма, чтобы можжно было в ней работать
AUTO_INCREMENT - для колонки id чтобы каждый раз не вбивать цифры, она будет делать +1
для AUTO_INCREMENT пишем NULL или не пишем id после INSERT INTO (название столбца, название столбца....)

CREATE TABLE ufc - создаём таблицу ufc
пример:
CREATE TABLE ufc 
( id INT,
name VARCHAR(30),
win INT,
lost INT,
country 'VARCHAR'(30)); - создаём таблицу ufc где INt - целочисленое число, VARCHAR(30)- текс до 30 симфолов

DROP TABLE ufc; - удалить таблицу ufc

INSERT INTO ufc VALUE - внести информацию в таблицу ufc
пример1: 
	INSERT INTO ufc VALUE 
	( 1,
	'macgregor',
	25,
	2); вносим информацию в таблицу ufc
пример2:
	INSERT INTO ufc (win, name) VALUES 
	(30,
	'Fedor'); внести в таблицу ufc только значения win и name в таком порядке

Когда вводим 2 или более строки то(каждая строка в скобках и после скобки запятая)


SELECT * FROM ufc; - выбрать всё из таблицы ufc

SELECT id,name FROM ufc; - выведет только 2 колонки с айди и именем из таблицы ufc

SELECT FROM WHERE - выбираем из таблицы с условием где
пример:
	SELECT name,win FROM ufc WHERE win > 25; - выведет на экран таблицу с win и name где колво побед больше 25
так же можно использовать значения =,>,<,>=,<=,<>(<> - неравно)

AND- И добавляет условия для выбора
пример:
	SELECT name,win FROM ufc WHERE win > 25 AND country = 'Russia'; выберет поля имя и победы из таблицы юфс где колво 
побед больше 25 и страна Россия. на экран выведет только 2 столбца - name и win

OR - ИЛИ добавляет условие для выбора
SELECT name,win FROM ufc WHERE win > 25 OR lost < 2;выберет поля имя и победы из таблицы юфс где колво 
побед больше 25 и колво поражений меньше 2. на экран выведет только 2 столбца - name и win
пример:
	SELECT *
	FROM Salespeople
	WHERE city='Barcelona'
	OR city='London';
	Имеется и более простой способ получить ту же информацию:
	SELECT *
	FROM Salespeople
	WHERE city IN ('Barcelona', 'London' );
	это один и тот же запрос

LIKE 
LIKE применим только к полям типа CHAR или VARCHAR, с которыми он используется чтобы находить подстроки.
пример:
SELECT name,win FROM ufc WHERE country LIKE '%ia' ; -выведется на экран имя, победы из юфс где страна заканчивается на "ia"
% означает любое колво букв до и после 
пример:
SELECT name,win FROM ufc WHERE country LIKE '%ia%' ;-выведется на экран имя, победы из юфс где в стране есть словосочетание букв "ia"
_ -знак нижнее подчёркивание, заменяет любую букву в конце. если написать Russi_, то он найдет Russia или Russib и тд

усложненый пример
SELECT name,win FROM ufc WHERE country LIKE '_%ia' AND win > 25; выбрать имя победы из таблицы юфс где страна начинается
на первая буква неизвестна и заканчивается на ia и побед больше 25

* Имеются два типа групповых символов используемых с LIKE:
символ подчеркивания (_ ) замещает любой одиночный символ. Например, 'b_t' будет соответствовать словам 'bat' или 'bit', но не будет
* соответствовать 'brat'.
знак процента (%) замещает последовательность любого числа символов
(включая символы нуля). Например '%p%t' будет соответствовать словам
'put', 'posit', или 'opt', но не 'spite'.
пример:
Давайте найдем всех заказчиков чьи имена начинаются с G:
	SELECT
	FROM Customers
	WHERE cname LIKE 'G%';

LIKE может быть удобен если вы ищете имя или другое значение, и если вы не помните как они точно пишутся. Предположим что вы неуверены как 
записано по буквам имя одного из ваших продавцов Peal или Peel. Вы можете просто использовать ту часть которую вы знаете и групповые символы 
чтобы находить все возможные пары:
пример:
	SELECT *
	FROM Salespeople
	WHERE sname LIKE 'P _ _ l %';
Групповые символы подчеркивания, каждый из которых представляет один символ, добавят только два символа к уже существующим 'P' и 'l', поэтому
имя наподобии Prettel не может быть показано. Групповой символ ' % ' - в конце строки необходим в большинстве реализаций если длина поля sname больше 
чем число символов в имени Peel (потому что некоторые другие значения sname - длиннее чем четыре символа). В таком случае, значение поля sname, фактически 
сохраняемое как имя Peel, сопровождается рядом пробелов. Следовательно, символ 'l' не будет рассматриваться концом строки. Групповой символ ' % ' - просто
соответствует этим пробелам. Это необязательно, если поля sname имеет тип - VARCHAR.


IN - чтобы не использовать много раз AND

пример:
	SELECT name,win FROM ufc WHERE win IN (20,24,26); - выбрать имя и победы из таблицы юфс где победы = 20,24,26

BETWEEN - между, в диапазоне
Оператор BETWEEN похож на оператор IN. В отличии от определения по номерам из набора, как это делает IN, 
BETWEEN определяет диапазон, значения которого должны уменьшаться что делает предикат верным. Вы должны ввести 
ключевое слово BETWEEN с начальным значением, ключевое AND и конечное значение. В отличие от IN, BETWEEN чувствителен 
к порядку, и первое значение в предложении должно быть первым по алфавитному или числовому порядку.
пример:
Этот запрос выбирает всех заказчиков чьи имена попали в определенный алфавитный диапазон:
	SELECT *
	FROM Customers
	WHERE cname BETWEEN 'A' AND 'G';
пример:
	SELECT name,win FROM ufc WHERE win BETWEEN 20 AND 26;выберет все варианты которые в диапазоне 20-26
меньшее значение(20) всегда пишется перед большим значением(26)

NOT - меняет местами запрос, всегда пишется после WHERE
пример:
SELECT name,win FROM ufc WHERE NOT win BETWEEN 20 AND 26;- выбирутся все кроме диапазона 20-26
пример:
	SELECT *
	FROM Customers
	WHERE NOT city=" San Jose'
	OR rating > 200;
NOT применяется здесь только к выражению city='SanJose',
пример:
	SELECT *
	FROM Customers
	WHERE NOT( city=" San Jose'
	OR rating > 200 );
Здесь SQL понимает круглые скобки как означающие, что все внутри них будет оцениваться первым 
и обрабатываться как единое выражение с помощью всего что снаружи них

можно давать псевдонимы полям, тоесть времено переименовывать их
пример: 
	SELECT name AS имена FROM ufc; выведет колонку с названием имена , а не name
изменится только в выводе, в таблице останется также(name)
можно без AS
пример:
	SELECT name имена FROM ufc;

DELETE-удалять(только начинку таблицы)
пример: DELETE FROM ufc WHERE lost >5; удалит где больше 5 поражений
Чтобы проверить что мы удаляем можно : SELECT * FROM ufc WHERE lost >5; тоесть он сначала покажет
что мы собираемся удалять.


UPDATE-добавлять

UPDATE таблица SET поле=значение;
UPDATE таблица SET поле=значение WHERE условие;
пример:
	UPDATE ufc SET lost=6; поменяется у всей таблицы
	UPDATE ufc SET lost=6 WHERE id=3; поменяется только у айди 3
	UPDATE ufc SET win=win*3;все победы в таблице будут умножены на 3
	UPDATE ufc SET win=win+3 WHERE id=3; у id3 будут приплюсованы 3 победы

ALTER TABLE - изменение таблицы
пример:
	ALETR TABLE ufc ADD COLUMN win KO INT; - добавит в таблицу колонку выигрыш нокаутом целочисленная
пример2:
	ALTER TABLE ufc ADD COLUMN id AUTO_INCREMENT FIRST,
ADD PRIMARY KEY (id); 				- сначала добавит колонку id и поставит её на первое место в таблице, 
затем добавит первичный ключ.
Вместо FIRST можно написать AFTER название колонки
пример:
	ALTER TABLE ufc ADD COLUMN test VARCHAR(10) AFTER id; -добавит после айди колонку с названием тест, где текстовые настройки

DROP COLUMN - удалить колонку
пример: 
	ALTER TABLE ufc DROP COLUMN lost; - удалить колонку проигрышы в таблице юфс

RENAME TO - переименовать(только для названия таблицы)
пример: 
	ALTER TABLE ufc RENAME TO ufc220; переименуется в юфс22

CHANGE COLUMN - изменить колонку(включая харки колонки)
пример:
	ALTER TABLE ufc CHANGE COLUMN name firstname VARCHAR(18); - изменит название колонки и 18 символов будет

MODIFY COLUMN- изменяет харки таблицы
пример:
	ALTER TABLE ufc MODIFY COLUMN firstname VARCHAR(19); будет 19 символов включать

функции - часто повторяющиеся коды автоматизируем. после слов функции всегда скобки()
строчные функции:
UPPER и LOWER - меняет буквы на заглавные и строчные
пример:
	SELECT UPPER(name) FROM ufc; - все имена будут с большой буквы.
пример:2
	UPDATE ufc
	SET lastname = UPPER(lastname)
	WHERE id=1; -в первом айди будут заглавные буквы

SUBSTRING_INDEX - Позволяет выбрать весь текст до или после разделителя(если положительный то слева, если отрицательный то справа)

предположим ситуацию, когда у нас в одном столбце имя и фамилия, и я хочу разделить их на 2 столбца, то:
ALTER TABLE ufc 
ADD TABLE first_name VARCHAR(20) NOT NULL
ADD TABLE last_name VARCHAR(20) NOT NULL; - на этом этапе создадутся 2 пустых колонки
UPDATE ufc SET first_name = SUBSTRING_INDEX(first_name, ' ',1) - ' тут пробел в качестве разделителя'  1 - значит весь текст до первого пробела
UPDATE ufc SET last_name = SUBSTRING_INDEX(last_name, ' ',-1); - ' тут пробел в качестве разделителя' - 1 - значит весь текст после первого пробела


RIGHT и LEFT - указатели справа и слева
пример:
	SELECT RIGHT(lastname, 2) FROM ufc; выведет из колонки фамилия по 2 последние буквы


RTRIM\LTRIM -убрать пробелы справа и слева

CASE - случай
пример:
мы хотим добавить колонку с прозвищем тогда
	ALTER TABLE ufc ADD COLUMN nik VARCHAR(20) NOT NULL;
	UPDATE ufc SET nik = CASE
	WHEN age > 35 THEN 'старпёр'
	WHEN age > 30 TNEN 'опытный'
	WNEN age > 0 TNEN 'расцвет'
	ELSE = 'не родился'
	END;
В этом примере ELSE исключает варианты когда мы не попали в диапазон(в данном случаем 0 и минус возраст)

ORDER BY поле - выводит в алфавитном порядке(поле это то по какому столбцу выведет алфавитный порядок)
пример:
	SELECT name, win , lastname FROM ufc ORDER BY name; 
	SELECT name, win , lastname FROM ufc ORDER BY name,last name; - сначала по имени отсортирует а потом по фамилии  

ORDER BY DESC - сортировка в обратном порядке
пример:

	SELECT name, win , lastname FROM ufc ORDER BY name DESC;

агрегатные функции:
SUMM - выводит сумму значений
MIN\MAX - выводит минимальное или максимальное значение
COUNT  - выводит количество записей
AVG - выводит средне арифметическое

пример:
	SELECT SUM(age) FROM ufc; - посчитает суммарный возраст
	SELECT MAX(age) FROm ufc; - выведет макс возраст

пример:
SELECT name, lastname,age FROM ufc WHERE age = (SELECT MAX(age)) FROM ufc;
пример:
SELECT COUNT(lost) FROM ufc; - выведет колво записей (заполненых полей, не NULL)
пример:
SELECT AVG(age) FROM ufc; - средний возраст выведет

* COUNT производит номера строк или не-NULL значения полей которые выбрал запрос.
	* SUM производит арифметическую сумму всех выбранных значений данного поля.
	* AVG производит усреднение всех выбранных значений данного поля.
	* MAX производит наибольшее из всех выбранных значений данного поля.
	* MIN производит наименьшее из всех выбранных значений данного поля.
пример:
	SELECT SUM (win) FROM ufc;

Чтобы подсчитать общее число строк в таблице, используйте функцию COUNT со звездочкой вместо имени поля, как например
в следующем примере:
	SELECT COUNT (*)
	FROM Customers;

Различия между ALL и * когда они используются с COUNT -
	* ALL использует имя_поля как аргумент.
	* ALL не может подсчитать значения NULL.
Пока * является единственым аргументом который включает NULL значения, и он используется только с COUNT; функции отличные 
от COUNT игнорируют значения NULL в любом случае. Следующая команда подсчитает(COUNT) число не-NULL значений в поле rating в таблице 
Заказчиков (включая повторения ):
	SELECT COUNT (ALL rating )
	FROM Customers;

Предположим, что таблица Порядков имеет еще один столбец который хранит предыдущий неуплаченый баланс (поле blnc) для каждого заказчика. Вы должны
найти этот текущий баланс, добавлением суммы приобретений к предыдущему балансу. Вы можете найти наибольший неуплаченый баланс следующим образом:
	SELECT MAX (blnc + (amt) )
	FROM Orders;

SELECT snum, odate, MAX (amt)
	FROM Orders GROUP BY snum, odate;
	*Table
Таблица 6.6: Нахождение наибольшей суммы приобретений на каждый день
Конечно же, пустые группы, в дни когда текущий продавец не имел порядков, не будут показаны в выводе.

GROUP BY - обьединяет поля

SELECT поля+ агрегатная функция FROM таблица GROUP BY поле;
пример:
	SELECT name, SUM(win) FROM ufc GROUP BY name;- выведет сумму всех побед

Предложение HAVING определяет критерии используемые чтобы удалять определенные группы из вывода, точно также как предложение WHERE делает это
для индивидуальных строк.
Правильной командой будет следующяя:
	SELECT snum, odate, MAX ((amt))
	FROM Orders
	GROUP BY snum, odate
	HAVING MAX ((amt)) > 3000.00;

вы можете пожелать, представить комиссионные вашего продавца в процентном отношении а не как десятичные числа. Просто достаточно:
	SELECT snum, sname, city, comm * 100
	FROM Salespeople;


DISTINCT - не создаёт дубликаты
пример:
SELECT DISTINCT country FROM ufc; - выведет только страны без дубликатов
DISTINCT опускает строки где все выбранные поля идентичны. Строки в которых некоторые значения одинаковы
а некоторые различны - будут сохранены.

LIMIT число - ограничивает по числу(добавляется в самом конце)
пример:
SELECT name, win, country FROM ufc ORDER BY win DESC LIMIT 1;-выведет 1 запись где наибольшее колво побед
Если LIMIT 2 то выведет 2 результата

SQL предоставляет специальный оператор IS, который используется с ключевым словом NULL, для размещения значения NULL.
	Найдем все записи в нашей таблице Заказчиков с NULL значениями в city столбце:
	SELECT *
	FROM Customers
	WHERE city IS NULL;
	Здесь не будет никакого вывода, потому что мы не имеем никаких значений NULL

Полное имя столбца таблицы фактически состоит из имени таблицы, сопровождаемого точкой и затем именем столбца. Имеются несколько примеров имен:
	Salespeople.snum
	Salespeople.city
	Orders.odate

Предположим что вы хотите поставить в соответствии вашему продавцу ваших заказчиков в городе в котором они живут, поэтому вы увидите
все комбинации продавцов и заказчиков для этого города. Вы будете должны брать каждого продавца и искать в таблице Заказчиков всех заказчиков
того же самого города. Вы могли бы сделать это, введя следующую команду:
	SELECT Customers.cname, Salespeople.sname,
	Salespeople.city
	FROM Salespeople, Customers
	WHERE Salespeople.city=Customers.city;
	
чтобы показать имена всех заказчиков соответствующих продавцам которые их обслуживают, мы будем использовать такой запрос:
	SELECT Customers.cname, Salespeople.sname
	FROM Customers, Salespeople
	WHERE Salespeople.snum=Customers.snum;

SELECT sname, cname FROM Salespeople, Customers
	WHERE sname < cname AND rating < 200;
	*Table
Таблица 8.3: Обьединение основанное на неравенстве
Эта команда не часто бывает полезна. Она воспроизводит все комбинации имени продавца и имени заказчика так, что первый 
предшествует последнему в алфавитном порядке, а последний имеет оценку меньше чем 200.

Предположим что мы хотим найти все порядки заказчиков не находящихся в тех городах где находятся их продавцы.Для этого необходимо связать все 
три наши типовые таблицы:
	SELECT onum, cname, Orders.cnum, Orders.snum
	FROM Salespeople, Customers,Orders
	WHERE Customers.city < > Salespeople.city
	AND Orders.cnum=Customers.cnum
	AND Orders.snum=Salespeople.snum;

вы набираете имя таблицы, оставляете пробел, и затем набираете псевдоним для нее. Имеется пример который находит все пары заказчиков имеющих один и
тот же самый рейтинг:
	SQL Execution Log
	SELECT first.cname, second.cname, first.rating
	FROM Customers first, Customers second
	WHERE first.rating=second.rating;





