переменные присваиваются:
		справа значение. тоесть var a =b; var c=b; тогда обоим присвоим значение b. если сделаем var b = c; , то будет только 1 значение c
.push() - добавляет элемент в конец массива
.pop()  - удаляет последний элемент массива	
.shift() - удаляет первый элемент массива			
.unshift() - добавляет элемент в начало массива
.hasOwnProperty() - проверяет есть ли свойство у объекта. пример: myObj.hasOwnProperty("top"); // true
тернарный оператор : условие ? код, если условие выполняется : код, если условие не выполняется;
Object.freeze - запрещает мутацию. пример: Object.freeze(obj);
стрелочные функции анонимны и нигде не переиспользуются
map() - создаёт новый массив основываясь на старом массиве. Пример:
	let c = a.map(function(currentValue){
	return x*2;
})	// с новый массив, а - старый массив. функция вернет старый массив "а"" умноженый на 2 в виде нового массива "c"
import - импортирует функцию из другого файла пример:
			import { function } from "file_path_goes_here"  Хорошей практикой считается  ставить пробелы между кудрявыми скобками
РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ:
	можно протестировать используя .test(); пример:
		let myString = "hello world";
		let myReg = /hello/;
		let result = myReg.test(myString);
		выдаст true
	так же можно перебрать несколько значений используя | пример:
		let myReg = /hello|bye/ важно: не должно быть пробелов между |
	--> символ i игнорирует написание заглавных и прописных букв. пример:
		let myReg = /hello/i - в этом случае он найдет hello будь он написан с заглаными буквами или без 
	.match(); - возвращает массив с регулярным вырожением. пример:
		"Hello, World!".match(/Hello/); - вернет ["Hello"]
		еще пример:
			let myString = "hello world";
			let myReg = /hello/;
			let result = myString.match(myReg);
	--> символ g извлекает более 1 раза пример:
		let myString = "hello world, hello world, hello world";	
		let myReg = /hello/g;
		let result = myString.match(myReg); 
		вернет - ["hello", "hello", "hello"]
	--> чтобы использовать вместе i и g нужно:
		let myReg = /hello/gi;	
	--> символ . используется для поиска когда неизвестна часть слова
	--> [] позволяют указывать символы которые надо искать между другими символами. пример:
		let bigStr = "big";
		let bagStr = "bag";
		let bugStr = "bug";
		let bogStr = "bog";
		let bgRegex = /b[aiu]g/;
		вернет все, кроме "bog"
	для удобства можем ставить дефис. пример: let bgRegex = /[a-z]/ или /[h-z2-6]/; подстаит все буквы алфавита
	[^] - указывает какие символы искать не надо
	+ - ищет совпадения, которые выстроены подряд(например "aabc") тогда /a+/g вернет ["aa"] , если "abab" то вернет ["a","a"]
	* - ищет все возможные вариации после нужного параметра. пример:
		let soccerWord = "gooooooooal!";
		let gPhrase = "gut feeling";
		let oPhrase = "over the moon";
		let goRegex = /go*/;
		soccerWord.match(goRegex); // Returns ["goooooooo"]
		gPhrase.match(goRegex); // Returns ["g"]
		oPhrase.match(goRegex); // Returns null
		используя * флаги ставить не надо
	ищем слово titanik: /t[a-z]*k/ - начинается на t и заканчивается на k и между бувами любые буквы в любом количестве	
	^ - ищет совпадение в начале строки (ставится в начале слова) 
	$ - ищет совпадение в конце сторки (ставится в конце слова)пример:
		let theEnding = "This is a never ending story";
		let storyRegex = /story$/;
		storyRegex.test(theEnding);// Returns true
		
		let noEnding = "Sometimes a story will have to end";
		storyRegex.test(noEnding);// Returns false	
	\w это короткая запись 	[A-Za-z0-9_] - ищет все заглавные и прописные буквы и цифры
	\W это короткая запись  [^A-Za-z0-9_] - ищет все все символы кроме заглавные и прописные буквы и цифры
	\d это короткая запись  [0-9] - ищет цыфры
	\D это короткая запись  [^0-9] - ищет не цыфры
	минимальная длинна - {2,} в примере минимальная длина 2 символа
пример /^[a-z]{2,}\d*$/i - в начале только буквы(минимум 2 символа) в конце цыфры и не важен регистр
	\s - ищет пробелы, табы и новые строки
	\S - ищет все кроме пробелов, табов и ноывх строк
	? - когда ты не уверен есть ли буква пример:
		let american = "color";
		let british = "colour";
		let rainbowRegex= /colou?r/;
		rainbowRegex.test(american); // Returns true
		rainbowRegex.test(british); // Returns true
пример поиска повторяющихся слов:
	let repeatStr = "regex regex";
	let repeatRegex = /(\w+)\s\1/;
	repeatRegex.test(repeatStr); // Returns true
	repeatStr.match(repeatRegex); // Returns ["regex regex", "regex"]			
метод replace(); - заменяет знаяения в поиске. пример:
	let wrongText = "The sky is silver.";
	let silverRegex = /silver/;
	wrongText.replace(silverRegex, "blue"); // Returns "The sky is blue."
Дебагинг :
	метод typeoff(); - определяет тип значения. пример:
		console.log(typeof ""); // outputs "string"
		console.log(typeof 0); // outputs "number"
		console.log(typeof []); // outputs "object"
		console.log(typeof {}); // outputs "object"