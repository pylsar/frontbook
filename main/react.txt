npm:
	чтобы изменить диск в консоли нужно написать название диска и : пример d:
	npm i create-react-app  установит пакет
	в нужной папке shift + правая кнопка мыши --> открыть окно команд
	cd смена папки пример: cd foldername
	cd .. поднятся на уровень выше
	cntr +c - в терминале останавливает компиляцию
	создание приложения react:
		npx create-react-app my-app
		cd my-app
		npm start
json server установка:
		npm install -g json-server
запуск json server: 
		json-server src/posts.json  и нажимаем enter, останавливаем сервер и заново запускаем его на другом порту 
установка react router:
	npm i react-router-dom -save
	в App.js : import {BrowserRouter as Router, Route} from 'react-router-dom';
	оборачиваем App.js в тег <Router></Router> 	
	в App.js вместо компонента(например <Feed/>) пишем <Route path='/' component={Feed} exact/>
	существуют варианты когда надо передать пропсы  в <Route>, тогда запись будет выглядеть след образом:
		<Route path='/' render={ () => <Feed/>} />
		так же можно задать через переменную. пример:
			let SomeComponent = () => <Feed/>;
			<Route path='/' component={SomeComponent} />
			render вроде как работает шустрее
			
			
	там где хотим поставить ссылки: import {Link} from 'react-router-dom'; и вместо тега <a> используем тег <Link to=""></Link>
	чтобы добавить класс active: <li className={classes.item}><NavLink to="/profile" activeClassName={classes.active}>Profile</NavLink></li> 
	чтобы добавить id в url : <NavLink to={"/dialogs/" + props.id}>{props.name}</NavLink>
развернуть проект на боевом: 
	npm run build
	создастся папка build  ее и надо грузить на сервер
клонировать репозиторий: в командной строке git clone ссылка
версия ноды: в командной строке node -v
чтобы обновить модули в папке node modules(сделать такие же как в packet.json): npm install
при установке пакетов через npm флаг -save заносит данные в packet.json. это нужно для того чтобы с другого компа не вспоминать что было установлено(так как папка node modules находится в .gitignor). командная строка ругнется и надо будет прописать npm install. и все команды которые есть в packet.json и которых нет в node modules уствновятся		



папка public используется для хранения статических страниц
названия классов всегда пишутся с большой буквы
статус 200 - означает что сервер все правильно нам отдал и мы все получили
props - не изменяются. мы создали компонент например с картинкой и все
state - динамическая структура
setState - устанавливает новое состояние
в JSX используем className вместо class
идентификатор key {} - пример. лента инстаграмм обновляет е сразу все посты а лишь те что изменились
реакт фрагмент <>тут подряд разные дивы</>(тоесть не обязательно всю верстку оборачивать в див)
названия классов для стилей не писать через дефис


пример: разбиваем css на модули Navbar.module.css
	в Navbar.jsx  пишем import classes from './Navbar.module.css';
	classes будем добавлять к className пример: было className="nav" стало className={classes.nav}
	пример 2х классов: className = {`${classes.className1} ${classes.className2}`}
	чтобы посмотреть что лежит в объекте classes: console.log(classes);
	classes меняем только в jsx



компонент - это функция которая выдает html код синтаксисом JSX
если используем компонент вне файла его надо экспотировать и импортировать
экспорт : export default componentname;
импорт : import componentName from './../componentFile';
import React from 'react'; - импортируем библиотеку реакт из папки нод модулз
название компоненты пишется с большой буквы
	пример компонента:
				class MyComponent extends React.Component{
				    constructor(props) {
				    super(props);
				  }
				  render() {
				    return (
				      <div>
				        <h1>My First React Component!</h1>
				        </div>
				    );
				  }
				}
				ReactDOM.render(<MyComponent/>, document.getElementById('challenge-node'))

плагин для vs code  auto import 
внутри JSX код JavaScript надо писать в {}


получаемые данные и логику надо писать раздельно
	пример:
	// постепенно выносим в index.js поднимая вверх на уровень и прописывая пропсы
	let posts = [
        {id: 1, message: 'whats up', likesCount: 67},
        {id: 2, message: 'whats viber', likesCount: 26}
    ]
	//пишется внутри компоненты
    let postsElement = props.posts.map( (posts) =>{
        return (
            <Post message={posts.message} likesCount={posts.likesCount} />
        )
    } )
	и каждому родителю надо дать пропсы в тег компонента если он там нужен <MyPosts posts={posts}/>
	не забываем в названии компоненты прописывать пропс const Name = (props)=>
	когда данные внутри файла jsx то мы пишем например <MyPosts posts={posts} />
	когда мы выносим данны из файла на уровень выше то пишем <MyPosts posts={props.posts} /> и соответственно копируем в этот файл данные. 
	По итогу все данные хранятся в state.js и через пропсы мы прокидываем их в нужные компоненты. 
		
	
map() - метод нужен для того чтобы не писать много раз одно и тоже действие(т.е приходит 100 сообщений с сервера и map все их перебирает и выводит)
чемто похож на цикл
		пример:
				const MyPosts = () => {

				let postsData = [
					{id: 1, message: 'whats up', likesCount: 67},
					{id: 2, message: 'whats viber', likesCount: 26}
				]

				let postsElement = postsData.map( (posts) =>{
					return (
						<Post message={posts.message} likesCount={posts.likesCount} />
					)
				} )

				return (
					<div className={classes.posts_block}>	
						<div className={classes.posts}>
							{postsElement}
						</div>
					</div>
				)
			}
суть реакта сводится к тому что мы не работаем с дом элементами в привычном смысле (никаких document.getElementById, addEventListener)


чтобы вызвать state надо :
		class MyComponent extends React.Component {
		  constructor(props) {
		    super(props);
		    this.state = {
		      name: 'freeCodeCamp'
		    }
		  }
		  render() {
		  const name = this.state.name;
		    return (
		      <div>
	  			<h1>{name}</h1>
		      </div>
		    );
		  }
		};

	или:
		class MyComponent extends React.Component {
		  constructor(props) {
		    super(props);
		    this.state = {
		      name: 'freeCodeCamp'
		    }
		  }
		  render() {
		    return (
		      <div>
	  			<h1>{this.state.name}</h1>
		      </div>
		    );
		  }
		};

нерекомендуется напрямую изменять this.state для этого используем this.setState() 
	пример:
		class MyComponent extends React.Component {
		  constructor(props) {
		    super(props);
		    this.state = {
		      name: 'Initial State'
		    };
		    this.handleClick = this.handleClick.bind(this);
		  }
		  handleClick() {
		this.setState({name: 'React Rocks!'});
		  }
		  render() {
		    return (
		      <div>
		        <button onClick={this.handleClick}>Click Me</button>
		        <h1>{this.state.name}</h1>
		      </div>
		    );
		  }
		};	
есть договоренность что: если свойство начинается с нижнего подчеркивания( пример this._hero=hero), то нельзя его менять напрямую

setState() - изменяет состояние.
	пример использования:
		this.setState((state, props) => ({
		  counter: state.counter + props.increment
		}));
	пример использования когда не нужны пропсы:
		this.setState(state => ({
		  counter: state.counter + 1
		}));

пример создания кнопки переключателя:
		class MyComponent extends React.Component {
		  constructor(props) {
		    super(props);
		    this.state = {
		      visibility: false
		    };
		    this.toggleVisibility = this.toggleVisibility.bind(this);
		  }
		 toggleVisibility(){
		  this.setState(state =>{
		      if(state.visibility === true){
		        return {visibility: false}
		      }else {
		        return {visibility: true}
		      }
		    })};
		  render() {
		    if (this.state.visibility) {
		      return (
		        <div>
		          <button onClick={this.toggleVisibility}>Click Me</button>
		          <h1>Now you see me!</h1>
		        </div>
		      );
		    } else {
		      return (
		        <div>
		          <button onClick={this.toggleVisibility}>Click Me</button>
		        </div>
		      );
		    }
		  }
		};


пример кода где при клике на кнопки мы увеличиваем уменьшаем и сбрасываем в 0:
		class Counter extends React.Component {
		  constructor(props) {
		    super(props);
		    this.state = {
		      count: 0
		    };
		this.increment = this.increment.bind(this);
		this.decrement = this.decrement.bind(this);
		this.reset = this.reset.bind(this);
		  }
		reset(){
		  this.setState((state) => ({
		    count: 0
		  }))
		}

		increment(){
		this.setState((state) =>({
		  count: state.count +1
		}))
		}

		decrement(){
		  this.setState((state)=> ({
		    count: state.count -1
		  }))
		}

		  render() {
		    return (
		      <div>
		        <button className='inc' onClick={this.increment}>Increment!</button>
		        <button className='dec' onClick={this.decrement}>Decrement!</button>
		        <button className='reset' onClick={this.reset}>Reset</button>
		        <h1>Current Count: {this.state.count}</h1>
		      </div>
		    );
		  }
		};


Необходимо делать проверки типов(они не идут в продакшн):
		подключаем библиотеку: 
			import PropTypes from 'prop-types';
		PropTypes экспортирует множество валидаторов, которые могут использоваться, чтобы убедиться, что данные, которые вы получаете, являются валидными. В данном примере мы используем PropTypes.number. Когда свойству предоставляется не валидное значение, будет показано предупреждение в JavaScript консоли. По соображениям производительности, propTypes работает только в режиме разработки.	
		пример:
			itemName.propTypes = {
			  propsName: PropTypes.dataType.isRequired
			};
		пример:	
			HelloWorld.propTypes = {
			   name: PropTypes.string
			};
stateless(функциональные, тупые) компоненты - это компоненты без логики	

событие в реакте:
		событие onClick:
			пишем функцию которая будет отвечать за нужные нам действия. обычно пишутся внутри компонента перед return
			let addPost = () => {
				let text = newPostElement.current.value; 
				alert('text');
			}
		добавляем кнопке эту функцию в событии:
			<button onClick={addPost}>add post</button> // важный момент: мы не ставим у функции ()
		добавляем референсную ссылку(есть есть возможность обойтись без этого, то выбираем другой вариант)
			let newPostElement = React.createRef();
		прописываем откуда будем брать инфу:
			<textarea ref={newPostElement}></textarea>
			
экспорт функции не по дефолту пример:
 при создании функции начинаем со слова export пример:
	export let addPost = (postMessage) => {
    let newPost = {
        id: 3,
        message: postMessage,
        likesCount: 0 
    };
    state.profilePage.posts.push(newPost);
}
так же не забываем прописывать импорт через {} пример:
	import {addPost} from './redux/state';
когда мы создаем функцию в state.js мы начинаем ее прокидывать через пропсы до нужного компанента пример: 
		<Route path='/profile' render={ () => <Profile stateData={props.state.profilePage} addPost={props.addPost} /> }/>
		
при импорте экспорте логики важно не делать циклические зависимости
bind() - используем чтобы обезопасить себя( мы привязываем свойства к методу). тоесть если мы вызываем функцию bind не нужен, а если 
		мы передаём функцию в след компоненту то надо использовать bind
		пример:
				let rerenderEntireTree = (state) =>{
					ReactDOM.render(<App 
						state={state} 
						addPost={store.addPost.bind(store)} 
						updateNewPostText={store.updateNewPostText.bind(store)} />,
						document.getElementById('root'));
				}

в react-create-app serviceworker нужен для того чтобы наше приложение работало без интернета	

условия в стилях:
		function Joke(props) {
		return (
			<div>
				<h3 style={{display: props.question ? "block" : "none"}}>Question: // если выполняется условие тогда ставим display: block, если нет - displat: none
				{props.question}</h3>
				<h3>Answer: {props.punchLine}</h3>
			</div>
			)
		}

npm install classnames - библиотека помогает работать с классами
	пример	
		<li key={index} className={classNames(item.className, {'active': item.active})}> // первый класс передаетсякак строка, второй по условию
		если active true - то передастся класс
		