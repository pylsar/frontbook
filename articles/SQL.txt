Краткий справочник SQL
Типы данных языка SQL
Типы данных, используемые в языке SQL для хранения информации в столбцах таблиц БД, весьма разнообразны. К сожалению, производители конкретных реляционных СУБД  считают своим долгом ?улучшить? множество типов данных, регламентируемых стандартом,  реализуя свои собственные версии и расширения. 
Автором учебного пособия в качестве базовых  предлагается считать следующие типы данных:
INT[(len)] - целое число длиной 4 байта, представляемое при выводе максимально len цифрами;
SMALLINT[(len)] - целое число длиной 2 байта, представляемое при выводе максимально len цифрами;
FLOAT[(len,dec)] - действительное число, представляемое при выводе максимально len символами с dec цифрами после десятичной точки;
CHAR(size) - строка символов фиксированной длины размером size символов;
VARCHAR(size) - строка символов переменной длины максимальным размером до size символов;
BLOB (Binary Large OBject) - массив произвольных (двоичных) байтов (максимальный размер зависит от реализации, обычно это 65535 байт); этот тип данных может использоваться, например, для хранения изображений;
DATE - астрономическая дата;
TIME - астрономическое время.
Символьные константы (типа CHAR и VARCHAR) записываются как последовательности символов, заключенные в одиночные апострофы, например ?brass? (латунь). 
Десятичные константы (типа FLOAT) могут записываться в ?научной? нотации как последовательности следующих компонент:
знак числа;
десятичное число с точкой;
символ ?е?;
знак (?+? или ?-?) показателя степени;
целое число, играющее роль показателя степени числа 10.
Например, десятичное число -0,123 может быть записано как -12.3е-2.
Отличие типов данных CHAR и VARCHAR заключается в том, что для хранения в таблице строк символов типа CHAR используется точно size байт (хотя содержание хранимых строк может быть значительно короче), в то время как для строк типа VARCHAR незанятые символами строк (?пустые?) байты в таблице не хранятся. 
Подчеркнем, что величины len и dec (в отличие от size) не влияют на размер хранения данных в таблице, а только форматируют вывод данных из таблицы.

Примечание. Тип данных BLOB поддерживается непосредственно не всеми СУБД, однако каждая из них предлагает его аналог (например, BINARY или IMAGE).

Рекомендация. Разрабатывая мобильное приложение (рассчитанное на работу в среде различных СУБД), старайтесь без необходимости избегать использования необязательных возможностей в описании типов данных. 
 

Манипулирование таблицами
Для создания, изменения и удаления таблиц в SQL БД используются операторы CREATE TABLE, ALTER TABLE и DROP TABLE.
Создание таблицы
Создание таблицы в БД реализуется оператором CREATE TABLE, имеющим следующий синтаксис
CREATE TABLE имя_табл (с_спецификация, ...);
где с_спецификация имеет разнообразный синтаксис. Здесь же рассматриваются наиболее часто используемые ее формы.
Описание столбца таблицы
имя_столбца тип_данных [NULL]
где имя_столбца -  имя столбца таблицы, а тип_данных - спецификация одного из типов данных, рассмотренных в разделе ?Типы данных языка SQL?. Необязательное ключевое слово NULL означает, что ячейкам данного столбца разрешено быть пустыми (т.е. не содержать какого-либо значения). 
 
Описание столбца таблицы
имя_столбца тип_данных NOT NULL [DEFAULT по_умолч] [PRIMARY KEY]
где конструкция NOT NULL запрещает иметь в таблице пустые ячейки в данном столбце. Конструкция PRIMARY KEY указывает, что содержимое столбца будет играть роль первичного ключа для создаваемой таблицы. Конструкция DEFAULT по_умолч переопределяет имеющееся для столбцов каждого типа данных значение ?по умолчанию? (например, 0 для числовых типов), используемое при добавлении в таблицу оператором INSERT INTO строк, не содержащих значений в этом столбце. 
 
Описание первичного ключа
PRIMARY KEY имя_ключа (имя_столбца, ...)
Эта спецификация позволяет задать первичный ключ для таблицы в виде композиции содержимого нескольких столбцов. 
 
Описание вторичного ключа
KEY имя_ключа (имя_столбца, ...)
Примеры
Ниже приводятся примеры использования оператора CREATE TABLE для создания четырех таблиц учебной БД.
CREATE TABLE nodes (
    id SMALLINT NOT NULL PRIMARY KEY,    # номер узла
    x FLOAT NOT NULL,              
         # x-координата
    y FLOAT NOT NULL);              
        # y-координата
 
CREATE TABLE elements (
    id SMALLINT NOT NULL PRIMARY KEY,    # номер КЭ
    n1 SMALLINT NOT NULL,               
    # номер первой вершины
    n2 SMALLINT NOT NULL,               
    # номер второй вершины
    n3 SMALLINT NOT NULL,               
    # номер третьей вершины
    props CHAR(12) NOT NULL DEFAULT 'steel');
Столбец props таблицы elements предназначен для хранения названия материала КЭ и не может содержать ?пустых? полей, его значением ?по умолчанию? является строка символов ?steel? (сталь).
CREATE TABLE materials (
    name CHAR(12) NOT NULL PRIMARY KEY,   # название материала
    density FLOAT NOT NULL,              
    # плотность
    elastics FLOAT NOT NULL,             
    # модуль Юнга
    poisson FLOAT NOT NULL,              
    # к-т Пуассона
    strength FLOAT NOT NULL);            
    # прочность
 
CREATE TABLE loadings (
    type CHAR(1) NOT NULL,               
    # тип граничного условия
    direction CHAR(1),              
         # направление действия
    node SMALLINT NOT NULL,              
    # номер узла приложения
    value FLOAT,                
             # числовое значение
    KEY key_node (node) );               
    # вторичный ключ
В таблице граничных условий loadings поля столбцов direction и value могут быть пустыми (иметь значение NULL), поскольку не все виды нагрузок имеют направление действия и/или величину. 
Номер узла node приложения граничного условия определяется как ключ поиска в таблице, т.к. типичный запрос на поиск в таблице loadings - это запрос на определение граничных условий для конкретного узла. Однако этот ключ не может быть первичным, поскольку к одному узлу допустимо приложение нескольких граничных условий (например, момент внешних сил в шарнире). 
Следует отметить, что в этой таблице первичный ключ может быть сконструирован только составным из столбцов type, direction и node. 
 
Модификация таблицы
Модификация существующей таблицы в БД реализуется оператором ALTER TABLE, имеющим следующий синтаксис
ALTER TABLE имя_табл м_специкация [,м_спецификация ...]
где м_спецификация имеет различные формы. Ниже рассматриваюся наиболее часто используемые.
Добавление нового столбца
ADD COLUMN с_спецификация
где с_спецификация - описание добавляемого столбца в том виде, как оно используется  для создания таблицы оператором CREATE TABLE. 
 
Удаление первичного ключа для таблицы
DROP PRIMARY KEY
Изменение/удаление значения ?по умолчанию?
ALTER COLUMN имя_столбца SET по_умолч
или
ALTER COLUMN имя_столбца DROP DEFAULT
Пример 
Предположим в нашей задаче моделирования состояния плоского механического объекта возникла необходимость учесть дополнительно тепловые эффекты. Для этого, в частности, необходимо иметь сведения о теплофизических параметрах материала объекта (теплоемкости и теплопроводности). Включение дополнительных сведений в таблицу materials требует ее расширения двумя новыми столбцами, что можно реализовать таким оператором языка SQL:
ALTER TABLE materials     ADD COLUMN capacity FLOAT NOT NULL,    
       # теплоемкость     ADD COLUMN conductivity FLOAT NOT NULL;
       # теплопроводность
Удаление таблицы
Удаление одной или сразу нескольких таблиц из БД реализуется оператором DROP TABLE, имеющим следующий простой синтаксис
DROP TABLE имя_табл, ...
Подчеркнем, что оператор DROP TABLE удаляет не только все содержимое таблицы, но и само описание таблицы из БД. Если требуется удалить только содержимое таблицы, то необходимо использовать оператор DELETE FROM.
Добавление строк в таблицу
Для добавления строк в таблицу SQL базы данных используется оператор INSERT INTO. Основные его синтаксические формы описываются ниже.
Добавление строки перечислением значений всех ее ячеек
INSERT INTO имя_табл VALUES (знач, ...);
где знач - константное значение ячейки строки. Значения ячеек в списке должны соответствовать порядку перечисления спецификаций столбцов таблицы в операторе CREATE TABLE. Допустимо в качестве знач указывать ключевое слово NULL, что означает отсутствие значения для соответствующей ячейки строки. 
Перед добавлением новой строки в таблицу СУБД проверяет допустимость перечисленных значений, используя описание столбцов таблицы из оператора CREATE TABLE. 
 
Добавление строки с использованием списка имен столбцов
INSERT INTO имя_табл (имя_столбца, ...) VALUES (знач, ...);
Здесь списки имен столбцов и значений ячеек добавляемой строки должны быть согласованы, хотя нет никаких требований к их порядку. Допустимо опускать в списках информацию о некоторых ячейках строки, при этом
ячейки, соответствующие столбцам со спецификацией NULL в операторе CREATE TABLE, будут пустыми;
ячейки, соответствующие столбцам со спецификацией NOT NULL в операторе CREATE TABLE, заполняются значениями ?по умолчанию?.
 
Добавление строк по результатам запроса к БД
INSERT INTO имя_табл [(имя_столбца, ...)] SELECT ...
Такой оператор дает возможность добавить в таблицу 0, 1 или сразу несколько новых строк, полученных в результате запроса к базе данных, реализуемого оператором SELECT.
Пример 
Добавление информации о новом узле КЭ-сетки в таблицу nodes:
INSERT INTO nodes VALUES (25, 6.3, 1.8);
Отметим, что добавление новой строки будет удачным только в том случае, если узла с таким же идентификатором в таблице nodes еще нет - дело в том, что столбец id этой таблицы объявлен первичным ключом и, следоваательно, значения всех его ячеек должны быть уникальны.
Пример 
Добавление информации о новом КЭ в таблицу elements:

INSERT INTO elements     (n1, n2, n3, id) VALUES     (14, 25,
    18, 46);
В результате в таблице elements появится новая строка, содержащая в поле props значение ?steel?, как умолчательное значение, определенное при создании таблицы.
Пример 
Включение в таблицу materials сведений о новом материале:

INSERT INTO materials VALUES (     'wood', 0.6, 2.0, 0.12, 50);
Пример 
Добавление в таблицу граничных условий loadings информации об ориентированном горизонтально ?катке? в узле 2:
INSERT INTO loadings VALUES (     'r', 'x', 2, NULL);
Выборка данных из таблиц
Для извлечения данных, содержащихся в таблицах SQL БД, используется оператор SELECT, имеющий в общем случае сложный и многовариантный синтаксис. В данном учебном пособии рассматриваются только несложные и наиболее часто используемые примеры конструкций оператора SELECT. 
Упрощенно оператор SELECT выглядит следующим образом:
SELECT [ALL | DISTINCT] в_выражение, ...
    FROM имя_табл [син_табл], ...
    [WHERE сложн_условие]
    [GROUP BY полн_имя_столбца|ном_столбца, ...]
    [ORDER BY полн_имя_столбца|ном_столбца [ASC|DESC],
    ...]
    [HAVING сложн_условие];
Результатом работы оператора является выводимая на стандартный вывод (экран дисплея) вновь построенная таблица, для которой
количество и смысл (семантика) столбцов определяется списком элементов в_выражение;
содержимое строк определяется содержимым исходных таблиц из списка FROM и критерием выборки, задаваемым сложн_условие.
При описании синтаксиса оператора SELECT использованы следующие обозначения:
син_табл - необязательный синоним имени таблицы, используемый для сокращения длины записи выражений и условий в операторе SELECT.
полн_имя_столбца - полное имя столбца в виде
[имя_табл|син_табл.]имя_столбца
Конкретизирующий таблицу префикс в имени столбца необходим только для различения столбцов, имеющих одинаковое имя в разных таблицах из списка FROM.
ном_столбца - номер столбца результирующей таблицы.
Описание столбцов результирующей таблицы
1. Специальным (и часто используемым) видом в_выражение является символ ?*?, имеющий смысл ?все столбцы таблиц из списка FROM?. 
Пример 
Вывод всего содержимого таблицы materials.
SELECT * FROM materials;
2. Простым (и также часто используемым) случаем в_выражение является полное имя столбца одной из таблиц списка FROM. 
Пример 
Пусть необходимо определить идентификаторы всех узлов КЭ-сетки, к которым приложено какое-либо граничное условие, при этом необходимо знать тип приложенного условия. Эта задача может быть решена с помощью следующего оператора:
SELECT node, type FROM loading
Полученная результирующая таблица содержит дублирующие строки для узла 27. Избежать этого можно, добавив в оператор ключевое слово DISTINCT, запрещающее включение в итоговую таблицу одинаковых строк.
SELECT DISTINCT node, type FROM loadings;

3. В общем случае в_выражение может представлять собой сложное скобочное выражение над содержимым столбцов таблицы, использующее арифметические, строковые, логические операции и функции. Наиболее часто используемые функции описаны ниже в таблицах 1, 2, 3. 
Пример 
Используемая нами таблица свойств материалов materials содержит в своих столбцах density и elastics значащие разряды чисел, выражающих, соответственно, плотность и модуль Юнга каждого материала. Для получения реальных значений этих свойств в системе единиц измерения СИ (кг/м3 и Па) необходимо домножить их на масштабные коэффициенты, что реализуется следующим оператором

SELECT name, density*1000, elastics*1e+9 FROM materials;

Синтаксис 	Возвращаемое значение
ABS(x)	абсолютное значение x
SQRT(x)	квадратный корень от x
MAX(x, y, ...)	значение наибольшего элемента из списка x, y, ...
MIN(x,y, ...)	значение наименьшего элемента из списка x, y, ...
 Примечание. x, y - числа или выражения, имеющие числовой результат. 
 Таблица 2. Строковые функции 
 
Синтаксис	Возвращаемое значение
LEFT(s,n)	первые n символов строки s
RIGHT(s.n)	последние n символов строки s
SUBSTRING(s, m, n)	строка, получаемая копированием n символов из строки s, начиная с m-ого символа строки s 
LCASE(s)	строка, полученная из s преобразованием всех букв в строчные
UCASE(s)	строка, полученная из s преобразованием всех букв в прописные
CONCAT(s1, s2, ...)	строка, полученная конкатенацией (слиянием) строк s1, s2, ...
LENGTH(s)	длина строки s
Примечание. s, s1,s2 - строки или выражения, имеющие результат в виде строки. n, m - числа или выражения, имеющие числовой результат. 
 Таблица 3. Операторы и функции, возвращающие логическое значение (1 - ?истина?, 0 - ?ложь?) 
 
Синтаксис	Возвращаемое значение
x = y  
x ?? y  
x ? y  
x ? y  
x ?= y  
x ?= y	1 (?истина?) или 0 (?ложь?) в зависимости от результата операции сравнения (соответственно, ?равно?, ?не равно?, ?больше?, ?меньше?, ?не больше?, ?не меньше?)
NOT l	1, если l=0  
0, если l=1
l1 AND l2	результат логической операции ?И? над l1 и l2
l1 OR l2	результат логической операции ?ИЛИ? над l1 и l2
BETWEEN (x, y z)	результат выполнения логического выражения (x?=y AND x?=z)
ISNULL (v)	1, если v имеет значение ?пусто? (NULL)  
0, в противном случае
IFNULL (v1, v2)	v1, если v1 не ?пусто?  
v2, в противном случае
s LIKE образец	1, при удачном сопоставлении строки s с образец   
0, в противном случае
s NOT LIKE образец	0, при удачном сопоставлении строки s с образец   
1, в противном случае
Примечание. x, y, z - числа или выражения, имеющие числовой результат. l, l1, l2 - логические константы (1 или 0) или логические выражения. s - строка или выражение, имеющее результат в виде строки. v, v1, v2 - переменные или выражения. 
образец - константа в виде строки символов, возможно, содержащая метасимволы ?%? и ?_?. В образец метасимвол ?_? сопоставим с любым одиночным символом строки s, метасимвол ?%? - с любой цепочкой символов любой ( в том числе нулевой) длины.
Пример 
Пусть необходимо при выводе информации о плотности материалов из таблицы materials идентифицировать материалы, имеющие в своем составе алюминий (правильнее, имеющие в своем названии упоминание об алюминии). Эта задача может быть решена с помощью следующего оператора.

SELECT name, name LIKE '%alu%', density FROM materials;
Пример 
Пусть необходимо для каждого конечного  элемента определить наибольшее значение разности идентификаторов узлов, являющихся вершинами этого конечного элемента. Данная задача может быть решена следующим оператором
SELECT id, n1, n2, n3, MAX(ABS(n1-n2),ABS(n1-n3),ABS(n2-n3)) FROM element

4. В общем случае в_выражение допускает использование агрегативных (называемых также групповыми) функций, принимающих в качестве своего единственного аргумента значения всех ячеек указанного столбца результирующей таблицы. Основные такие функции представлены в таблице 4. Таблица 4. Агрегативные функции 
 
Синтаксис	Возвращаемое значение
SUM(x)	сумма значений столбца x результирующей таблицы
MAX(x)	наибольшее значение из всех значений ячеек столбца x 
MIN(x)	наименьшее значение из всех значений ячеек столбца x
AVG(x)	среднее значение для всех значений ячеек столбца x
COUNT(x)	общее количество ячеек в столбце x
 Примечание. Функции MAX(...) и MIN(...) с одним аргументом являются агрегативными функциями, они же с двумя и более аргументами - обычные функции (см. таблицу 1).
Пример 
Для отыскания наибольшего значения модуля Юнга для материалов, имеющихся в таблице materials, можно использовать следующий оператор

SELECT MAX(elastics) FROM materials

Пример 
Следующий оператор SELECT позволяет определить общее количество конечных элементов в КЭ-сетке из нашего примера.
SELECT COUNT(*) FROM elements

Описание критерия выборки содержимого строк результирующей
                матрицы
В качестве критерия выбора информации из таблиц списка FROM оператора SELECT выступает сложн_условие, записываемое после ключевого слова WHERE и имеющее следующий вид:
прост_условие
или
прост_условие AND сложн_условие
или
прост_условие OR сложн_условие
Типичными вариантами прост_условие являются следующие.
Сравнение
полн_имя_столбца @ полн_имя_столбца_или_константа
где @ - один из операторов сравнения: ? (?больше?), ? (?меньше?), ?= (? не меньше?), ?= (?не больше?), = (?равно?), ?? (?не равно?), а полное_имя_столбца - имя столбца, конкретизированное при необходимости именем или синонимом имени таблицы, как это было описано выше. 
 
Сопоставление с образцом
полн_имя_столбца [NOT] LIKE образец
где образец имеет вид, описанный в таблице 3. 
 
Проверка на ?пустое? значение в ячейке стодбца
полн_имя_столбца IS [NOT] NULL
При конструировании сложн_условие допустимо использование  круглых скобок для управления порядком вычисления условий.
Примечание. Обратите внимание, что синтаксис сложн_условие существенно ?беднее? синтаксиса в_выражение. Дело в том, что сложн_условие используется (в том числе и на физическом уровне организации БД) на этапе выборки из исходной (возможно, очень большой) таблицы (таблиц) необходимых строк в результирующую. Для сокращения времени прямого доступа к строкам таблиц они (таблицы) снабжаются ключами и индексами. Реальный эффект от использования ключей и индексов может быть достигнут только при условии, что запросы на поиск в таблицах используют в качестве критерия поиска только значения ячеек столбцов в ?чистом? виде, а не в виде их комбинации в сложном выражении. 
Конструкция же в_выражение применяется, по сути дела, к значениям столбцов уже результирующей таблицы, поэтому сложность в_выражение на эффективность выполнения запроса практически никакого влияния не оказывает.

Пример 
Для определения координат местоположения узла 11 может использоваться следующий оператор:

SELECT * FROM nodes WHERE id = 11;

Пример 
Пусть необходимо определить идентификаторы всех конечных элементов, имеющих в качестве одной из своих вершин узел 20. Эта задача может быть решена следующим оператором SELECT
 SELECT id FROM elements     WHERE n1 = 20 OR n2 = 20 OR n3 = 20;

Пример 
Для определения идентификаторов узлов КЭ-сетки, расположенных в первом квадранте системы координат можно использовать следующий оператор
SELECT * FROM nodes     WHERE x ?= 0 AND y ?= 0;
Пример 
Следующий оператор SELECT может быть использован для  определения граничных условий, имеющих в качестве одной из своих характеристик численное значение величины
SELECT * FROM loadings WHERE value IS NOT NULL;
Упорядочивание и группирование строк результирующей таблицы
Для обеспечения структурированности в расположении строк результирующей таблицы в операторе SELECT используются конструкции GROUP BY и ORDER BY.
Упорядочение строк достигается перечислением полных имен столбцов, по которым в возрастающем (ASC) или убывающем (DESC) порядке сортируются строки результирующей таблицы. При этом строки упорядочиваются в первую очередь по столбцу, указанному первым в списке ORDER BY. Затем, если среди значений ячеек первого столбца есть повторяющиеся, производится упорядочение по второму столбцу и так далее. 
 
Пример 
Для вывода информации об узлах КЭ-сетки в убывающем порядке их (узлов) идентификаторов может быть использован следующий оператор:

SELECT * FROM nodes ORDER BY id DESC;
Пример 
Пусть необходимо вывести информацию о конечных элементах, упорядочив ее;
в первую очередь по идентификаторам узлов, являющихся первой вершиной конечного элемента;
во вторую очередь по идентификаторам узлов, являющихся второй вершиной конечного элемента;
Для решения этой задачи можно использовать следующий оператор
SELECT * FROM elements ORDER BY n1, n2;
 
Оператор SELECT может обеспечить вычисление агрегативных функций для групп строк результирующей таблицы. Для этого используется список полных имен столбцов в конструкции GROUP BY. Первое полное имя столбца в списке GROUP BY используется для разбиения строк результирующей таблицы на первичные группы, первичные группы разделяются на ?подгруппы? вторым в списке полным именем столбца и так далее. 
 
Оператор SELECT выводит значения агрегативных функций для самых ?малых? подгрупп.

Пример 
Пусть необходимо определить количество узлов КЭ-сетки, охватываемых каждым видом граничных условий. Для этого может быть использован следующий оператор

SELECT type, COUNT(*) FROM loadings GROUP BY type;
Примечание. Конструкция HAVING сложн_условие, как необязательная составная часть предложения GROUP BY, позволяет определять дополнительный (к WHERE сложн_условие) критерий выборки строк в группы.  Этот дополнительный критерий применяется в режиме постпроцессорной обработки к таблице, полученной в результате использования критерия из конструкции WHERE. 
 
Выборка из нескольких таблиц
В общем случае оператор SELECT языка SQL дает возможность выборки информации сразу из нескольких таблиц, перечисленных в списке FROM. На концептуальном уровне рассмотрения (уровне реляционной модели данных) такая выборка включает в себя два основных этапа:
построение промежуточной таблицы, представляющей собой декартово произведение таблиц из списка FROM (т.е. таблицы, строки которой представляют собой все возможные сочетания строк исходных таблиц);
копирование в результирующую таблицу всех строк промежуточной, отвечающих критерию из WHERE сложн_условие (если таковой определен).
Пример 
Пусть необходимо определить значение модуля Юнга для конечного элемента с идентификатором 25. Эта задача может быть решена следующим оператором
SELECT id, elastics FROM elements, materials     WHERE id = 25 AND props
    = name;
Примечание. Обратите внимание, что в данном примере нигде в операторе SELECT не потребовалось использовать полные имена столбцов различных таблиц. Объясняется это тем, что имена столбцов таблиц elements и materials различны, и поэтому неоднозначностей в именовании быть не может. 
Примечание. Хотя концептуальная модель обработки оператора SELECT со списком FROM из двух и более таблиц подразумевает построение декартового произведения этих табллиц, в реальности этого не происходит в силу ?ограниченности? синтаксиса сложн_условие из конструкции WHERE. Так, в нашем последнем примере запрос на выборку осуществлялся в 2 ?коротких? этапа: 1) из таблицы elements (с использованием первичного ключа) прямым доступом извлекается строка с id=25; 2) из таблицы materials (опять с использованием первичного ключа) прямым доступом извлекается информация о материале ?steel? (сталь). Очевидно, что такой ?оптимизированный? подход несравненно более эффективен по сравнению с каноническим (через декартово произведение). 
Пример 
Для вывода координат трех вершин каждого конечного элемента в КЭ-сетке в одной таблице можно использовать следующий оператор
SELECT e.id, node1.x, node1.y, node2.x, node2.y, node3.x, node3.y     FROM
    elements e, nodes node1, nodes node2, nodes node3     WHERE e.n1 = node1.id
            AND e.n2 = node2.id         AND
    e.n3 = node3.id;
Примечание. Обратите внимание, что необходимая для выполнения данного запроса промежуточная таблица в виде декартового произведения (если бы она реально строилась) имеет размер в 31*29*29*29=756059 строк (31 строка в таблице elements и 29 строк в таблице nodes). 
 
Манипулирование строками таблиц
Для удаления и изменения строк таблиц SQL БД применяются операторы DELETE и UPDATE.
Удаление строк
Удаление строк таблицы реализуется оператором DELETE FROM, имеющим следующий синтаксис
DELETE FROM имя_табл [WHERE сложн_условие]
где сложн_условие имеет описанный выше синтаксис. В результате выполнения оператора из таблицы удаляются все строки, удовлетворяющие критерию сложн_условие. Если в операторе DELETE FROM конструкция WHERE опущена, то удаляются все строки таблицы.
Модификация строк
Изменение содержимого строк таблицы реализуется оператором UPDATE, имеющим следующий синтаксис
UPDATE имя_табл SET имя_столбца=выражение, ...
[WHERE сложн_условие]
где выражение - выражение (в простейшем случае - константа), согласующееся по результату с типом данных столбца. В выражение допустимо использование значений ячеек любых столбцов таблицы, рассмотренных ранее операций и функций (но не агрегативных), а также прежнего содержимого модифицуруемой ячейки. Обновлению подлежат столбцы строк, отвечающих критерию сложн_условие. Если конструкция WHERE в операторе отсутствует, то обновляются все строки таблицы. 
Пример 
Для изменения наименования материала, из которого выполнена механическая конструкция, для всех элементов КЭ-сетки можно использовать следующий оператор
UPDATE elements SET props='brass'; SELECT * FROM elements;

Пример 
В нашей КЭ-сетке элемент 22 имеет ?неправильную? форму.
Ставится задача заменить его двумя новыми конечными элементами, имеющими форму,
более близкую к равносторонней. 
Эта задача может быть решена следующей последовательностью операторов 
DELETE FROM elements WHERE id=22; INSERT INTO nodes VALUES (30, 45.0, -33.5); INSERT
    INTO elements VALUES (22, 21, 30, 19); INSERT INTO elements VALUES (32, 21, 23,
    30);
Пример 
Для решения предыдущей задачи можно также использовать и другой набор операторов
INSERT INTO nodes VALUES (30, 45.0, -33.5); UPDATE elements SET n2 = 30 WHERE id
    = 22; INSERT INTO elements VALUES (32, 21, 23, 30);