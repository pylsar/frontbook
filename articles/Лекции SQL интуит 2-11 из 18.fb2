<?xml version="1.0" encoding="UTF-8"?>
<FictionBook xmlns="http://www.gribuser.ru/xml/fictionbook/2.0" xmlns:xlink="http://www.w3.org/1999/xlink">
    <description>
        <title-info>
            <genre>antique</genre>
                <author><first-name></first-name><last-name>User</last-name></author>
            <book-title>Unknown</book-title>
            
            <lang>ru</lang>
            
            
        </title-info>
        <document-info>
            <author><first-name></first-name><last-name>User</last-name></author>
            <program-used>calibre 3.26.1</program-used>
            <date>15.10.2018</date>
            <id>26d7c7a4-6fa7-4ec0-983e-054ae2e81151</id>
            <version>1.0</version>
        </document-info>
        <publish-info>
            <publisher>SPecialiST RePack</publisher>
            
            
        </publish-info>
    </description>
<body>
<section>
<p>Лекция2</p>

<p><strong>Типы данных языка SQL, определенные стандартом</strong></p>

<p><strong><emphasis>Данные</emphasis></strong> – это совокупная информация, хранимая в базе <emphasis>данных</emphasis> в виде одного из нескольких различных <emphasis>типов</emphasis> . С помощью <strong><emphasis>типов данных</emphasis></strong>устанавливаются основные правила для <emphasis>данных</emphasis>, содержащихся в конкретном столбце таблицы, в том числе размер выделяемой для них памяти.</p>

<p>В языке <emphasis>SQL</emphasis> имеется шесть скалярных <emphasis>типов данных</emphasis>, определенных стандартом. Их краткое описание представлено в таблице.</p><empty-line /><p>Таблица 2.1.</p><empty-line /><p><strong><emphasis>Тип данных</emphasis></strong></p>

<p><strong>Объявления</strong></p><empty-line /><p><emphasis>Символьный</emphasis></p>

<p>CHAR | VARCHAR</p><empty-line /><p><emphasis>Битовый</emphasis></p>

<p>BIT | BIT VARYING</p><empty-line /><p><emphasis>Точные числа</emphasis></p>

<p>NUMERIC | DECIMAL | INTEGER | SMALLINT</p><empty-line /><p><emphasis>Округленные числа</emphasis></p>

<p>FLOAT | REAL | DOUBLE PRECISION</p><empty-line /><p><emphasis>Дата/время</emphasis></p>

<p>DATE | TIME | TIMESTAMP</p><empty-line /><p>Интервал</p>

<p>INTERVAL</p><empty-line /><p><strong>Символьные данные</strong></p>

<p><strong><emphasis>Символьные данные</emphasis></strong> состоят из последовательности символов, входящих в определенный создателями СУБД набор символов. Поскольку наборы символов являются специфическими для различных диалектов языка SQL, перечень символов, которые могут входить в состав значений <emphasis>данных </emphasis><emphasis>символьного типа</emphasis>, также зависит от конкретной реализации. Чаще всего используются наборы символов ASCII и <emphasis>EBCDIC</emphasis>. Для определения <emphasis>данных </emphasis><emphasis>символьного типа</emphasis> используется следующий формат:</p>

<p>&lt;символьный_тип&gt;::=</p>

<p>{ CHARACTER [ VARYING][длина] | [CHAR |</p>

<p>VARCHAR][длина]}</p>

<p>При определении столбца с <emphasis>символьным типом</emphasis> <emphasis>данных</emphasis> параметр длина применяется для указания максимального количества символов, которые могут быть помещены в данный столбец (по умолчанию принимается значение 1 ). Символьная строка может быть определена как имеющая фиксированную или переменную ( VARYING ) длину. Если строка определена с фиксированной длиной значений, то при вводе в нее меньшего количества символов значение дополняется до указанной длины пробелами, добавляемыми справа. Если строка определена с переменной длиной значений, то при вводе в нее меньшего количества символов в базе <emphasis>данных</emphasis> будут сохранены только введенные символы, что позволит достичь определенной экономии внешней памяти.</p>

<p><strong>Битовые данные</strong></p>

<p><strong><emphasis>Битовый тип</emphasis></strong> <emphasis>данных</emphasis> используется для определения битовых строк, т.е. последовательности двоичных цифр (битов), каждая из которых может иметь значение либо 0, либо 1 . <emphasis>Данные </emphasis><emphasis>битового типа</emphasis> определяются при помощи следующего формата:</p>

<p>&lt;битовый_тип&gt;::=</p>

<p>BIT [VARYING][длина]</p>

<p><strong>Точные числа</strong></p>

<p><strong><emphasis>Тип точных числовых данных</emphasis></strong> применяется для определения чисел, которые имеют точное представление, т.е. числа состоят из цифр, необязательной десятичной точки и необязательного символа знака. <emphasis>Данные </emphasis><emphasis>точного числового типа</emphasis> определяются точностью и длиной дробной части. Точность задает общее количество значащих десятичных цифр числа, в которое входит длина как целой части, так и дробной, но без учета самой десятичной точки. Масштаб указывает количество дробных десятичных разрядов числа.</p>

<p>&lt;фиксированный_тип&gt;::=</p>

<p>{NUMERIC[точность[,масштаб]]|{DECIMAL|DEC}</p>

<p>[точность[, масштаб]]</p>

<p>| {INTEGER |INT}| SMALLINT}</p>

<p><emphasis>Типы</emphasis> NUMERIC и DECIMAL предназначены для хранения чисел в десятичном формате. По умолчанию длина дробной части равна нулю, а принимаемая по умолчанию точность зависит от реализации. <emphasis>Тип</emphasis> INTEGER ( INT ) используется для хранения больших положительных или отрицательных целых чисел. <emphasis>Тип</emphasis> SMALLINT – для хранения небольших положительных или отрицательных целых чисел; в этом случае расход внешней памяти существенно сокращается.</p>

<p><strong>Округленные числа</strong></p>

<p><strong><emphasis>Тип округленных чисел</emphasis></strong> применяется для описания <emphasis>данных</emphasis>, которые нельзя точно представить в компьютере, в частности действительных чисел. <emphasis>Округленные числа</emphasis> или числа с плавающей точкой представляются в научной нотации, при которой число записывается с помощью мантиссы, умноженной на определенную степень десяти (порядок), например: 10Е3, +5.2Е6, -0.2Е-4 . Для определения <emphasis>данных</emphasis>вещественного <emphasis>типа</emphasis> используется формат:</p>

<p>&lt;вещественный_тип&gt;::=</p>

<p>{ FLOAT [точность]| REAL |</p>

<p>DOUBLE PRECISION}</p>

<p>Параметр точность задает количество значащих цифр мантиссы. Точность <emphasis>типов</emphasis> REAL и DOUBLE PRECISION зависит от конкретной реализации.</p>

<p><strong>Дата и время</strong></p>

<p><strong><emphasis>Тип данных "дата/время"</emphasis></strong> используется для определения моментов времени с некоторой установленной точностью. Стандарт SQL поддерживает следующий формат:</p>

<p>&lt;тип_даты/времени&gt;::=</p>

<p>{DATE | TIME[точность][WITH TIME ZONE]|</p>

<p>   TIMESTAMP[точность][WITH TIME ZONE]}</p>

<p><emphasis>Тип данных </emphasis>DATE используется для хранения календарных дат, включающих поля YEAR (год), MONTH (месяц) и DAY (день). <emphasis>Тип данных</emphasis>TIME – для хранения отметок времени, включающих поля HOUR (часы), MINUTE (минуты) и SECOND (секунды). <emphasis>Тип данных</emphasis> TIMESTAMP – для совместного хранения даты и времени. Параметр точность задает количество дробных десятичных знаков, определяющих точность сохранения значения в поле SECOND. Если этот параметр опускается, по умолчанию его значение для столбцов <emphasis>типа</emphasis> TIME принимается равным нулю (т.е. сохраняются целые секунды), тогда как для полей <emphasis>типа</emphasis> TIMESTAMP он принимается равным 6. Наличие ключевого слова WITH <emphasis>TIME ZONE</emphasis> определяет использование полей TIMEZONE HOUR и TIMEZONE MINUTE, тем самым задаются час и минуты сдвига зонального времени по отношению к универсальному координатному времени (Гринвичскому времени).</p>

<p><emphasis>Данные </emphasis><emphasis>типа</emphasis> INTERVAL используются для представления периодов времени.</p>

<p><strong>Понятие домена</strong></p>

<p><strong><emphasis>Домен</emphasis></strong> – это набор допустимых значений для одного или нескольких атрибутов. Если в таблице базы <emphasis>данных</emphasis> или в нескольких таблицах присутствуют столбцы, обладающие одними и теми же характеристиками, можно описать <emphasis>тип</emphasis> такого столбца и его поведение через <emphasis>домен</emphasis>, а затем поставить в соответствие каждому из одинаковых столбцов имя <emphasis>домена</emphasis>. <emphasis>Домен</emphasis> определяет все потенциальные значения, которые могут быть присвоены атрибуту.</p>

<p>Стандарт SQL позволяет определить <emphasis>домен</emphasis> с помощью следующего <emphasis>оператора</emphasis>:</p>

<p>&lt;определение_домена&gt;::=</p>

<p>CREATE DOMAIN имя_домена [AS]</p>

<p>      тип_данных</p>

<p>[ DEFAULT значение]</p>

<p>[ CHECK (допустимые_значения)]</p>

<p>Каждому создаваемому <emphasis>домену</emphasis> присваивается имя, <emphasis>тип данных</emphasis>, значение по умолчанию и набор допустимых значений. Следует отметить, что приведенный формат <emphasis>оператора</emphasis> является неполным. Теперь при создании таблицы можно указать вместо <emphasis>типа данных</emphasis> имя <emphasis>домена</emphasis>.</p>

<p>Удаление <emphasis>доменов</emphasis> из базы <emphasis>данных</emphasis> выполняется с помощью <emphasis>оператора</emphasis>:</p>

<p>DROP DOMAIN имя_домена [ RESTRICT |</p>

<p>CASCADE]</p>

<p>В случае указания ключевого слова CASCADE любые столбцы таблиц, созданные с использованием удаляемого <emphasis>домена</emphasis>, будут автоматически изменены и описаны как содержащие <emphasis>данные</emphasis> того <emphasis>типа</emphasis>, который был указан в определении удаляемого <emphasis>домена</emphasis>.</p>

<p>Альтернативой <emphasis>доменам</emphasis> в среде SQL Server являются <emphasis>пользовательские типы данных</emphasis>.</p>

<p><strong>Типы данных, используемые в SQL-сервере</strong></p>

<p><strong>Системные типы данных</strong></p>

<p>Один из основных моментов процесса создания таблицы – определение <emphasis>типов данных</emphasis> для ее полей. <emphasis>Тип данных</emphasis> поля таблицы определяет тип информации, которая будет размещаться в этом поле. Понятие <emphasis>типа данных</emphasis> в SQL Server полностью адекватно понятию <emphasis>типа данных</emphasis> в современных языках программирования. SQL-сервер поддерживает большое число различных <emphasis>типов данных</emphasis>: текстовые, числовые, двоичные (см. таблицу 2.2).</p><empty-line /><p>Таблица 2.2.</p><empty-line /><p>image</p>

<p>smalldatetime</p>

<p>bit</p>

<p>binary</p><empty-line /><p>text</p>

<p>real</p>

<p>decimal</p>

<p>char</p><empty-line /><p>uniqueidentifier</p>

<p>money</p>

<p>numeric</p>

<p>timestamp</p><empty-line /><p>tinyint</p>

<p>datetime</p>

<p>smallmoney</p>

<p>nvarchar</p><empty-line /><p>smallint</p>

<p>float</p>

<p>varbinary</p>

<p>nchar</p><empty-line /><p>int</p>

<p>ntext</p>

<p>varchar</p>

<p>sysname</p><empty-line /><p>Приведем краткий обзор <emphasis>типов данных</emphasis> SQL Server.</p>

<p>Для хранения символьной информации используются <emphasis>символьные типы</emphasis> <emphasis>данных</emphasis>, к которым относятся CHAR (длина), VARCHAR (длина), NCHAR (длина), NVARCHAR (длина). Последние два предназначены для хранения символов Unicode. Максимальное значение длины ограничено 8000 знаками ( 4000 – для символов Unicode).</p>

<p>Хранение символьных <emphasis>данных</emphasis> большого объема (до 2 Гб) осуществляется при помощи текстовых <emphasis>типов данных</emphasis> TEXT и NTEXT.</p>

<p>К <emphasis>целочисленным типам</emphasis> <emphasis>данных</emphasis> относятся INT ( INTEGER ), SMALLINT, TINYINT, BIGINT. Для хранения <emphasis>данных </emphasis><emphasis>целочисленного типа</emphasis>используется, соответственно, 4 байта (диапазон от -2<sup>31</sup> до 2<sup>31</sup>-1 ), 2 байта (диапазон от -2<sup>15</sup> до 2<sup>15</sup>-1 ), 1 байт (диапазон от 0 до 255 ) или 8 байт (диапазон от -2<sup>63</sup> до 2<sup>63</sup>-1 ). Объекты и <emphasis>выражения </emphasis><emphasis>целочисленного типа</emphasis> могут применяться в любых математических операциях.</p>

<p>Числа, в составе которых есть десятичная точка, называются нецелочисленными. <emphasis>Нецелочисленные данные</emphasis> разделяются на два <emphasis>типа</emphasis> – десятичные и приблизительные.</p>

<p>К десятичным <emphasis>типам данных</emphasis> относятся <emphasis>типы</emphasis> DECIMAL [(точность[,масштаб])] или DEC и NUMERIC [(точность[,масштаб])]. <emphasis>Типы данных</emphasis> DECIMAL и NUMERIC позволяют самостоятельно определить формат точности числа с плавающей запятой. Параметр точностьуказывает максимальное количество цифр вводимых <emphasis>данных</emphasis> этого <emphasis>типа</emphasis> (до и после десятичной точки в сумме), а параметр масштаб – максимальное количество цифр, расположенных после десятичной точки. В обычном режиме сервер позволяет вводить не более 28 цифр, используемых в <emphasis>типах</emphasis> DECIMAL и NUMERIC (от 2 до 17 байт).</p>

<p>К приблизительным <emphasis>типам данных</emphasis> относятся FLOAT (точность до 15 цифр, 8 байт) и REAL (точность до 7 цифр, 4 байта). Эти <emphasis>типы</emphasis>представляют <emphasis>данные</emphasis> в формате с плавающей запятой, т.е. для представления чисел используется мантисса и порядок, что обеспечивает одинаковую точность вычислений независимо от того, насколько мало или велико значение.</p>

<p>Для хранения информации о дате и времени предназначены такие <emphasis>типы данных</emphasis>, как DATETIME и SMALLDATETIME, использующие для представления даты и времени 8 и 4 байта соответственно.</p>

<p><emphasis>Типы данных</emphasis> MONEY и SMALLMONEY делают возможным хранение информации <emphasis>денежного типа</emphasis> ; они обеспечивают точность значений до 4 знаков после запятой и используют 8 и 4 байта соответственно.</p>

<p><emphasis>Тип данных</emphasis> BIT позволяет хранить один бит, который принимает значения 0 или 1.</p>

<p>В среде SQL Server реализован ряд <emphasis>специальных типов данных</emphasis>.</p>

<p><emphasis>Тип данных</emphasis> TIMESTAMP применяется в качестве индикатора изменения версии строки в пределах базы <emphasis>данных</emphasis>.</p>

<p><emphasis>Тип данных</emphasis> UNIQUEIDENTIFIER используется для хранения глобальных уникальных идентификационных номеров.</p>

<p><emphasis>Тип данных</emphasis> SYSNAME предназначен для идентификаторов <emphasis>объектов</emphasis>.</p>

<p><emphasis>Тип данных</emphasis> SQL_VARIANT позволяет хранить значения любого из поддерживаемых SQL Server <emphasis>типов данных</emphasis> за исключением TEXT, NTEXT, IMAGE и TIMESTAMP.</p>

<p><emphasis>Тип данных</emphasis> TABLE, подобно временным таблицам, обеспечивает хранение набора строк, предназначенных для последующей обработки. <emphasis>Тип данных</emphasis> TABLE может применяться только для определения локальных <emphasis>переменных</emphasis> и возвращаемых пользовательскими функциями значений. Пример использования <emphasis>типа данных</emphasis> TABLE приведен в лекции, посвященной функциям пользователя.</p>

<p><emphasis>Тип данных</emphasis> CURSOR нужен для работы с такими <emphasis>объектами</emphasis>, как курсоры, и может быть востребован только для <emphasis>переменных</emphasis> и <emphasis>параметров хранимых процедур</emphasis>. Курсоры SQL Server представляют собой механизм обмена <emphasis>данными</emphasis> между сервером и клиентом. Курсор позволяет клиентским приложениям работать не с полным набором <emphasis>данных</emphasis>, а лишь с одной или несколькими строками. Примеры использования <emphasis>данных </emphasis><emphasis>типа</emphasis> CURSOR мы рассмотрим в лекциях, посвященных курсорам и хранимым процедурам.</p>

<p><strong>Создание пользовательского типа данных</strong></p>

<p>В системе SQL-сервера имеется поддержка <strong><emphasis>пользовательских типов данных</emphasis></strong>. Они могут использоваться при определении какого-либо специфического или часто употребляемого формата.</p>

<p>Создание <emphasis>пользовательского типа данных</emphasis> осуществляется выполнением системной процедуры:</p>

<p>sp_addtype [@typename=]type,[@phystype=]</p>

<p>system_data_type</p>

<p>   [,[@nulltype=]’null_type’]</p>

<p><emphasis>Тип данных</emphasis> system_data_type выбирается из следующей таблицы.</p><empty-line /><p>Таблица 2.3.</p><empty-line /><p>image</p>

<p>smalldatetime</p>

<p>decimal</p>

<p>bit</p><empty-line /><p>text</p>

<p>real</p>

<p>‘decimal[(p[,s])]’</p>

<p>‘binary(n)’</p><empty-line /><p>uniqueidentifier</p>

<p>datetime</p>

<p>numeric</p>

<p>‘char(n)’</p><empty-line /><p>smallint</p>

<p>float</p>

<p>‘numeric[(p[,s])]’</p>

<p>‘nvarchar(n)’</p><empty-line /><p>int</p>

<p>‘float(n)’</p>

<p>‘varbinary(n)’</p><empty-line /><p>ntext</p>

<p>‘varchar(n)’</p>

<p>‘nchar(n)’</p><empty-line /><p>EXEC sp_addtype bir, DATETIME, 'NULL'</p>

<p>или</p>

<p>EXEC sp_addtype bir, DATETIME, ‘NOT NULL’</p>

<p>2.1. Создание пользовательского типа данных bir.</p>

<p>CREATE TABLE tab</p>

<p>(id_n      INT IDENTITY(1,1) PRIMARY KEY,</p>

<p>names      VARCHAR(40),</p>

<p>birthday      BIR)</p>

<p>2.2. Использование пользовательского типа данных bir при создании таблицы.</p>

<p>Удаление <emphasis>пользовательского типа данных</emphasis> происходит в результате выполнения процедуры sp_droptype type: EXEC sp_droptype 'bir'</p>

<p><strong>Получение информации о типах данных</strong></p>

<p>Получить список всех <emphasis>типов данных</emphasis>, включая <emphasis>пользовательские</emphasis>, можно из системной таблицы systypes:</p>

<p>SELECT * FROM  systypes</p>

<p><strong>Преобразование типов</strong></p>

<p>Нередко требуется <strong><emphasis>конвертировать</emphasis></strong> значения одного <emphasis>типа</emphasis> в значения другого. Наиболее часто выполняется <emphasis>конвертирование</emphasis> чисел в символьные <emphasis>данные</emphasis> и наоборот, для этого используется специализированная функция STR. Для выполнения других <emphasis>преобразований</emphasis> SQL Server предлагает универсальные функции CONVERT и CAST, с помощью которых значения одного <emphasis>типа</emphasis> преобразовываются в значения другого <emphasis>типа</emphasis>, если такие изменения вообще возможны. CONVERT и CAST примерно одинаковы и могут быть взаимозаменяемыми.</p>

<p>CAST(выражение AS тип_данных)</p>

<p>CONVERT(тип_данных[(длина)],</p>

<p>выражение [,стиль])</p>

<p>С помощью аргумента стиль можно управлять стилем представления значений следующих <emphasis>типов данных</emphasis>: <emphasis>дата/время</emphasis>, <emphasis>денежный</emphasis> или <emphasis>нецелочисленный</emphasis>.</p>

<p>DECLARE @d DATETIME</p>

<p>DECLARE  @s CHAR(8)</p>

<p>SET @s=’29.10.01’</p>

<p>SET @d=CAST(@s AS DATETIME)</p>

<p>2.3. Преобразование данных символьного типа к данным типа дата/время.</p>

<p><strong>Наряду с </strong></p>

<p><strong><emphasis>типами данных</emphasis></strong></p>

<p><strong> основополагающими понятиями при работе с языком SQL в среде MS SQL Server являются </strong></p>

<p><strong><emphasis>выражения</emphasis></strong></p>

<p><strong>, </strong></p>

<p><strong><emphasis>операторы</emphasis></strong></p>

<p><strong>, </strong></p>

<p><strong><emphasis>переменные</emphasis></strong></p>

<p><strong>, </strong></p>

<p><strong><emphasis>управляющие конструкции</emphasis></strong></p>

<p><strong>.</strong></p>

<p><strong> Выражения</strong></p>

<p><strong><emphasis>Выражения</emphasis></strong> представляют собой комбинацию идентификаторов, функций, знаков логических и арифметических операций, констант и других <emphasis>объектов</emphasis>. <emphasis>Выражение</emphasis> может быть использовано в качестве аргумента в командах, хранимых процедурах или запросах.</p>

<p><emphasis>Выражение</emphasis> состоит из <emphasis>операндов</emphasis> (собственно <emphasis>данных</emphasis> ) и <emphasis>операторов</emphasis> (знаков операций, производимых над <emphasis>операндами</emphasis> ). В качестве <emphasis>операндов</emphasis>могут выступать <emphasis>константы</emphasis>, <emphasis>переменные</emphasis>, имена столбцов, функции, подзапросы.</p>

<p><strong><emphasis>Операторы</emphasis></strong> – это знаки операций над одним или несколькими <emphasis>выражениями</emphasis> для создания нового <emphasis>выражения</emphasis>. Среди <emphasis>операторов</emphasis> можно выделить унарные <emphasis>операторы</emphasis>, <emphasis>операторы</emphasis> присваивания, арифметические <emphasis>операторы</emphasis>, строковые <emphasis>операторы</emphasis>, <emphasis>операторы</emphasis> сравнения, логические <emphasis>операторы</emphasis>, битовые <emphasis>операторы</emphasis> .</p>

<p><strong>Переменные</strong></p>

<p>В среде <emphasis>SQL</emphasis> <emphasis>Server</emphasis> существует несколько способов передачи <emphasis>данных</emphasis> между командами. Один из них – передача <emphasis>данных</emphasis> через локальные <emphasis>переменные</emphasis>. Прежде чем использовать какую-либо <emphasis>переменную</emphasis>, ее следует объявить. Объявление <emphasis>переменной</emphasis> выполняется командой DECLARE, имеющей следующий формат:</p>

<p>DECLARE {@имя_переменной тип_данных }</p>

<p>[,...n]</p>

<p>Значения <emphasis>переменной</emphasis> можно присвоить посредством команд SET и SELECT. С помощью команды SELECT <emphasis>переменной</emphasis> можно присвоить не только конкретное <emphasis>значение</emphasis>, но и результат вычисления <emphasis>выражения</emphasis>.</p>

<p>DECLARE @a INT</p>

<p>SET @a=10</p>

<p>2.4. Использование SET для присваивания значения локальной переменной.</p>

<p>DECLARE @k INT</p>

<p>SELECT @k=SUM(количество) FROM Товар</p>

<p>2.5. Использование SELECT для присваивания локальной переменной результата вычислений.</p>

<p><strong>Управляющие конструкции SQL</strong></p>

<p>Язык <emphasis>SQL</emphasis> является непроцедурным, но тем не менее в среде <emphasis>SQL</emphasis> <emphasis>Server</emphasis> предусмотрен ряд различных <emphasis>управляющих конструкций</emphasis>, без которых невозможно написание эффективных алгоритмов.</p>

<p>Группировка двух и более команд в единый <emphasis>блок</emphasis> осуществляется с использованием ключевых слов BEGIN и END:</p>

<p>&lt;блок_операторов&gt;::=</p>

<p>BEGIN</p>

<p>{ sql_оператор | блок_операторов }</p>

<p>END</p>

<p>Сгруппированные команды воспринимаются интерпретатором <emphasis>SQL</emphasis> как одна <emphasis>команда</emphasis>. Подобная группировка требуется для <emphasis>конструкций поливариантных ветвлений</emphasis>, <emphasis>условных</emphasis> и <emphasis>циклических</emphasis> конструкций. <emphasis>Блоки</emphasis> BEGIN...END могут быть вложенными.</p>

<p>Некоторые команды <emphasis>SQL</emphasis> не должны выполняться вместе с другими командами (речь идет о командах резервного копирования, изменения структуры таблиц, хранимых процедур и им подобных), поэтому их совместное включение в конструкцию BEGIN...END не допускается.</p>

<p>Нередко определенная часть программы должна выполняться только при реализации некоторого логического условия. <emphasis>Синтаксис</emphasis> <emphasis>условного оператора</emphasis> показан ниже:</p>

<p>&lt;условный_оператор&gt;::=</p>

<p>IF лог_выражение</p>

<p>  { sql_оператор | блок_операторов }</p>

<p>[ ELSE</p>

<p>  {sql_оператор | блок_операторов } ]</p>

<p>Циклы организуются с помощью следующей конструкции:</p>

<p>&lt;оператор_цикла&gt;::=</p>

<p>WHILE лог_выражение</p>

<p>   { sql_оператор | блок_операторов }</p>

<p>   [ BREAK ]</p>

<p>   { sql_оператор | блок_операторов }</p>

<p>   [ CONTINUE ]</p>

<p>Цикл можно принудительно остановить, если в его теле выполнить команду BREAK. Если же нужно начать цикл заново, не дожидаясь выполнения всех команд в теле, необходимо выполнить команду CONTINUE.</p>

<p>Для замены <emphasis>множества</emphasis> одиночных или вложенных <emphasis>условных операторов</emphasis> используется следующая конструкция:</p>

<p>&lt;оператор_поливариантных_ветвлений&gt;::=</p>

<p>CASE входное_значение</p>

<p>WHEN {значение_для_сравнения |</p>

<p>   лог_выражение } THEN</p>

<p>вых_выражение [,...n]</p>

<p>[ ELSE иначе_вых_выражение ]</p>

<p>END</p>

<p>Если входное <emphasis>значение</emphasis> и <emphasis>значение</emphasis> для сравнения совпадают, то конструкция возвращает выходное <emphasis>значение</emphasis>. Если же <emphasis>значение</emphasis> входного параметра не найдено ни в одной из строк WHEN...THEN, то тогда будет возвращено <emphasis>значение</emphasis>, указанное после ключевого слова ELSE.</p>

<p><strong>Основные объекты структуры базы данных SQL-сервера</strong></p>

<p>Рассмотрим логическую структуру базы <emphasis>данных</emphasis>.</p>

<p><emphasis>Логическая структура</emphasis> определяет структуру таблиц, взаимоотношения между ними, <emphasis>список</emphasis> пользователей, хранимые процедуры, правила, умолчания и другие <emphasis>объекты базы данных</emphasis>.</p>

<p>Логически <emphasis>данные</emphasis> в <emphasis>SQL</emphasis> <emphasis>Server</emphasis> организованы в виде <emphasis>объектов</emphasis>. К основным <emphasis>объектам базы данных</emphasis> <emphasis>SQL</emphasis> <emphasis>Server</emphasis> относятся <emphasis>объекты</emphasis>, представленные в таблице 2.4.</p><empty-line /><p>Таблица 2.4.</p><empty-line /><p>Tables</p>

<p>Таблицы базы <emphasis>данных</emphasis>, в которых хранятся собственно данные</p><empty-line /><p>Views</p>

<p>Просмотры (виртуальные таблицы) для отображения <emphasis>данных</emphasis> из таблиц</p><empty-line /><p>Stored Procedures</p>

<p>Хранимые процедуры</p><empty-line /><p>Triggers</p>

<p>Триггеры – специальные хранимые процедуры, вызываемые при изменении <emphasis>данных</emphasis> в таблице</p><empty-line /><p>User Defined function</p>

<p>Создаваемые пользователем функции</p><empty-line /><p>Indexes</p>

<p>Индексы – дополнительные структуры, призванные повысить производительность работы с <emphasis>данными</emphasis></p><empty-line /><p>User Defined Data Types</p>

<p>Определяемые пользователем <emphasis>типы данных</emphasis></p><empty-line /><p>Keys</p>

<p>Ключи – один из видов <emphasis>ограничений целостности данных</emphasis></p><empty-line /><p>Constraints</p>

<p>Ограничение целостности – <emphasis>объекты</emphasis> для обеспечения логической целостности данных</p><empty-line /><p>Users</p>

<p>Пользователи, обладающие доступом к базе данных</p><empty-line /><p>Roles</p>

<p>Роли, позволяющие объединять пользователей в группы</p><empty-line /><p>Rules</p>

<p>Правила базы <emphasis>данных</emphasis>, позволяющие контролировать логическую целостность данных</p><empty-line /><p>Defaults</p>

<p>Умолчания или стандартные установки базы данных</p><empty-line /><p>Приведем краткий обзор основных <emphasis>объектов</emphasis> баз <emphasis>данных</emphasis>.</p>

<p><strong>Таблицы</strong></p>

<p>Все <emphasis>данные</emphasis> в SQL содержатся в <emphasis>объектах</emphasis>, называемых таблицами. Таблицы представляют собой совокупность каких-либо сведений об <emphasis>объектах</emphasis>, явлениях, процессах реального мира. Никакие другие <emphasis>объекты</emphasis> не хранят <emphasis>данные</emphasis>, но они могут обращаться к <emphasis>данным</emphasis> в таблице. Таблицы в SQL имеют такую же структуру, что и таблицы всех других СУБД и содержат:</p>

<p>cтроки; каждая строка (или запись) представляет собой совокупность атрибутов (свойств) конкретного экземпляра <emphasis>объекта</emphasis> ;</p>

<p>cтолбцы; каждый столбец (поле) представляет собой атрибут или совокупность атрибутов. Поле строки является минимальным элементом таблицы. Каждый столбец в таблице имеет определенное имя, <emphasis>тип данных</emphasis> и размер.</p>

<p><strong>Представления</strong></p>

<p>Представлениями (просмотрами) называют виртуальные таблицы, содержимое которых определяется запросом. Подобно <emphasis>реальным таблицам</emphasis>, представления содержат именованные столбцы и строки с <emphasis>данными</emphasis>. Для конечных пользователей представление выглядит как таблица, но в действительности оно не содержит <emphasis>данных</emphasis>, а лишь представляет <emphasis>данные</emphasis>, расположенные в одной или нескольких таблицах. Информация, которую видит пользователь через представление, не сохраняется в базе <emphasis>данных</emphasis> как самостоятельный <emphasis>объект</emphasis>.</p>

<p><strong>Хранимые процедуры</strong></p>

<p>Хранимые процедуры представляют собой группу команд SQL, объединенных в один модуль. Такая группа команд компилируется и выполняется как единое целое.</p>

<p><strong>Триггеры</strong></p>

<p>Триггерами называется специальный класс хранимых процедур, автоматически запускаемых при добавлении, изменении или удалении <emphasis>данных</emphasis>из таблицы.</p>

<p><strong>Функции</strong></p>

<p>Функции в языках программирования – это конструкции, содержащие часто исполняемый код. Функция выполняет какие-либо действия над <emphasis>данными</emphasis> и возвращает некоторое значение.</p>

<p><strong>Индексы</strong></p>

<p>Индекс – структура, связанная с таблицей или представлением и предназначенная для ускорения поиска информации в них. Индекс определяется для одного или нескольких столбцов, называемых индексированными столбцами. Он содержит отсортированные значения индексированного столбца или столбцов со ссылками на соответствующую строку исходной таблицы или представления. Повышение производительности достигается за счет сортировки <emphasis>данных</emphasis>. Использование индексов может существенно повысить производительность поиска, однако для хранения индексов необходимо дополнительное пространство в базе <emphasis>данных</emphasis>.</p>

<p><strong>Пользовательские типы данных</strong></p>

<p><strong><emphasis>Пользовательские типы данных</emphasis></strong> – это <emphasis>типы данных</emphasis>, которые создает пользователь на основе системных <emphasis>типов данных</emphasis>, когда в нескольких таблицах необходимо хранить однотипные значения; причем нужно гарантировать, что столбцы в таблице будут иметь одинаковый размер, <emphasis>тип данных</emphasis> и чувствительность к значениям NULL .</p>

<p><strong>Ограничения целостности</strong></p>

<p>Ограничения целостности – механизм, обеспечивающий автоматический контроль соответствия <emphasis>данных</emphasis> установленным условиям (или ограничениям). Ограничения целостности имеют приоритет над триггерами, правилами и значениями по умолчанию. К ограничениям целостности относятся: ограничение на значение NULL, проверочные ограничения, ограничение уникальности (уникальный ключ), ограничение первичного ключа и ограничение внешнего ключа. Последние три ограничения тесно связаны с понятием ключей.</p>

<p><strong>Правила</strong></p>

<p>Правила используются для ограничения значений, хранимых в столбце таблицы или в <emphasis>пользовательском типе данных</emphasis>. Они существуют как самостоятельные <emphasis>объекты</emphasis> базы <emphasis>данных</emphasis>, которые связываются со столбцами таблиц и <emphasis>пользовательскими типами данных</emphasis>. Контроль значений <emphasis>данных</emphasis> может быть реализован и с помощью ограничений целостности.</p>

<p><strong>Умолчания</strong></p>

<p>Умолчания – самостоятельный <emphasis>объект базы данных</emphasis>, представляющий значение, которое будет присвоено элементу таблицы при вставке строки, если в команде вставки явно не указано значение для этого столбца.</p><empty-line /><p>Лекция 3</p>

<p><strong>База данных</strong></p>

<p><strong>Создание базы данных</strong></p>

<p>В различных СУБД процедура создания <emphasis>баз данных</emphasis> обычно закрепляется только за администратором <emphasis>баз данных</emphasis>. В однопользовательских системах принимаемая по умолчанию <emphasis>база данных</emphasis> может быть сформирована непосредственно в процессе установки и настройки самой СУБД. Стандарт SQL не определяет, как должны создаваться <emphasis>базы данных</emphasis>, поэтому в каждом из диалектов языка SQL обычно используется свой подход. В соответствии со стандартом SQL, <emphasis>таблицы</emphasis> и другие объекты <emphasis>базы данных</emphasis> существуют в некоторой среде. Помимо всего прочего, каждая среда состоит из одного или более <emphasis>каталогов</emphasis>, а каждый <emphasis>каталог</emphasis> – из набора <emphasis>схем</emphasis>. <emphasis>Схема</emphasis> представляет собой поименованную коллекцию объектов <emphasis>базы данных</emphasis>, некоторым образом связанных друг с другом (все объекты в <emphasis>базе данных</emphasis> должны быть описаны в той или иной <emphasis>схеме</emphasis> ). Объектами <emphasis>схемы</emphasis> могут быть <emphasis>таблицы</emphasis>, представления, домены, утверждения, сопоставления, толкования и наборы символов. Все они имеют одного и того же владельца и множество общих значений, принимаемых по умолчанию.</p>

<p>Стандарт SQL оставляет за разработчиками СУБД право выбора конкретного механизма создания и уничтожения <emphasis>каталогов</emphasis>, однако механизм создания и удаления <emphasis>схем</emphasis> регламентируется посредством операторов CREATE SCHEMA и DROP SCHEMA. В стандарте также указано, что в рамках оператора создания <emphasis>схемы</emphasis> должна существовать возможность определения диапазона привилегий, доступных пользователям создаваемой <emphasis>схемы</emphasis>. Однако конкретные способы определения подобных привилегий в разных СУБД различаются.</p>

<p>В настоящее время операторы CREATE SCHEMA и DROP SCHEMA реализованы в очень немногих СУБД. В других реализациях, например, в СУБД MS SQL Server, используется оператор CREATE DATABASE.</p>

<p><strong>Создание базы данных в среде MS SQL Server</strong></p>

<p>Процесс создания <emphasis>базы данных</emphasis> в системе SQL-сервера состоит из двух этапов: сначала организуется сама <emphasis>база данных</emphasis>, а затем принадлежащий ей <emphasis>журнал транзакций</emphasis>. Информация размещается в соответствующих файлах, имеющих расширения *.mdf (для <emphasis>базы данных</emphasis> ) и *.ldf. (для <emphasis>журнала транзакций</emphasis> ). В файле <emphasis>базы данных</emphasis> записываются сведения об основных объектах ( <emphasis>таблицах</emphasis>, <emphasis>индексах</emphasis>, представлениях и т.д.), а в файле <emphasis>журнала транзакций</emphasis> – о процессе работы с транзакциями (контроль целостности данных, состояния <emphasis>базы данных</emphasis> до и после выполнения транзакций).</p>

<p>Создание <emphasis>базы данных</emphasis> в системе SQL-сервер осуществляется командой CREATE DATABASE. Следует отметить, что процедура создания <emphasis>базы данных</emphasis> в SQL-сервере требует наличия прав администратора сервера.</p>

<p>&lt;определение_базы_данных&gt; ::=</p>

<p>   CREATE DATABASE имя_базы_данных</p>

<p>   [ON [PRIMARY]</p>

<p>   [ &lt;определение_файла&gt;  [,...n] ]</p>

<p>   [,&lt;определение_группы&gt; [,...n] ] ]</p>

<p>   [ LOG ON {&lt;определение_файла&gt;[,...n] } ]</p>

<p>   [ FOR LOAD | FOR ATTACH ]</p>

<p>Рассмотрим основные параметры представленного оператора.</p>

<p>При выборе имени <emphasis>базы данных</emphasis> следует руководствоваться общими правилами именования объектов. Если имя <emphasis>базы данных</emphasis> содержит пробелы или любые другие недопустимые символы, оно заключается в ограничители (двойные кавычки или квадратные скобки). Имя <emphasis>базы данных</emphasis>должно быть уникальным в пределах сервера и не может превышать 128 символов.</p>

<p>При создании и изменении <emphasis>базы данных</emphasis> можно указать имя файла, который будет для нее создан, изменить имя, путь и исходный размер этого файла. Если в процессе использования <emphasis>базы данных</emphasis> планируется ее размещение на нескольких дисках, то можно создать так называемые <emphasis>вторичные файлы</emphasis> <emphasis>базы данных</emphasis> с расширением *.ndf. В этом случае основная информация о <emphasis>базе данных</emphasis> располагается в <emphasis>первичном</emphasis> ( PRIMARY ) файле, а при нехватке для него свободного места добавляемая информация будет размещаться во <emphasis>вторичном файле</emphasis>. Подход, используемый в SQL-сервере, позволяет распределять содержимое <emphasis>базы данных</emphasis> по нескольким дисковым томам.</p>

<p>Параметр ON определяет список файлов на диске для размещения информации, хранящейся в <emphasis>базе данных</emphasis>.</p>

<p>Параметр PRIMARY определяет <emphasis>первичный файл</emphasis>. Если он опущен, то <emphasis>первичным</emphasis> является первый файл в списке.</p>

<p>Параметр LOG ON определяет список файлов на диске для размещения <emphasis>журнала транзакций</emphasis>. Имя файла для <emphasis>журнала транзакций</emphasis>генерируется на основе имени <emphasis>базы данных</emphasis>, и в конце к нему добавляются символы _log.</p>

<p>При создании <emphasis>базы данных</emphasis> можно определить набор файлов, из которых она будет состоять. Файл определяется с помощью следующей конструкции:</p>

<p>&lt;определение_файла&gt;::=</p>

<p>   ([ NAME=логическое_имя_файла,]</p>

<p>   FILENAME='физическое_имя_файла'</p>

<p>   [,SIZE=размер_файла ]</p>

<p>   [,MAXSIZE={max_размер_файла |UNLIMITED } ]</p>

<p>   [, FILEGROWTH=величина_прироста ] )[,...n]</p>

<p>Здесь <strong><emphasis>логическое имя файла</emphasis></strong> – это имя файла, под которым он будет опознаваться при выполнении различных SQL-команд.</p>

<p><strong><emphasis>Физическое имя файла</emphasis></strong> предназначено для указания полного пути и названия соответствующего физического файла, который будет создан на жестком диске. Это имя останется за файлом на уровне операционной системы.</p>

<p>Параметр SIZE определяет первоначальный размер файла; минимальный размер параметра – 512 Кб, если он не указан, по умолчанию принимается 1 Мб.</p>

<p>Параметр MAXSIZE определяет максимальный размер файла <emphasis>базы данных</emphasis>. При значении параметра UNLIMITED максимальный размер <emphasis>базы данных</emphasis> ограничивается свободным местом на диске.</p>

<p>При создании <emphasis>базы данных</emphasis> можно разрешить или запретить автоматический рост ее размера (это определяется параметром FILEGROWTH ) и указать приращение с помощью абсолютной величины в Мб или процентным соотношением. Значение может быть указано в килобайтах, мегабайтах, гигабайтах, терабайтах или процентах (%). Если указано число без суффикса МБ, КБ или %, то по умолчанию используется значение MБ. Если <emphasis>размер шага</emphasis> роста указан в процентах (%), размер увеличивается на заданную часть в процентах от размера файла. Указанный размер округляется до ближайших 64 КБ.</p>

<p>Дополнительные файлы могут быть включены в группу:</p>

<p>&lt;определение_группы&gt;::=FILEGROUP имя_группы_файлов</p>

<p>    &lt;определение_файла&gt;[,...n]</p>

<p><strong>Пример 3.1</strong>. Создать <emphasis>базу данных</emphasis>, причем для данных определить три файла на диске C, для <emphasis>журнала транзакций</emphasis> – два файла на диске C.</p>

<p>CREATE DATABASE Archive</p>

<p>ON PRIMARY ( NAME=Arch1,</p>

<p>  FILENAME=’c:\user\data\archdat1.mdf’,</p>

<p>SIZE=100MB, MAXSIZE=200, FILEGROWTH=20),</p>

<p>(NAME=Arch2,</p>

<p>  FILENAME=’c:\user\data\archdat2.mdf’,</p>

<p>  SIZE=100MB, MAXSIZE=200, FILEGROWTH=20),</p>

<p>(NAME=Arch3,</p>

<p>  FILENAME=’c:\user\data\archdat3.mdf’,</p>

<p>  SIZE=100MB, MAXSIZE=200, FILEGROWTH=20)</p>

<p>LOG ON</p>

<p>(NAME=Archlog1,</p>

<p>  FILENAME=’c:\user\data\archlog1.ldf’,</p>

<p>    SIZE=100MB, MAXSIZE=200, FILEGROWTH=20),</p>

<p>(NAME=Archlog2,</p>

<p>  FILENAME=’c:\user\data\archlog2.ldf’,</p>

<p>    SIZE=100MB, MAXSIZE=200, FILEGROWTH=20)</p>

<p>Пример 3.1. Создание базы данных.</p>

<p><strong>Изменение базы данных</strong></p>

<p>Большинство действий по изменению конфигурации <emphasis>базы данных</emphasis> выполняется с помощью следующей конструкции:</p>

<p>&lt;изменение_базы_данных&gt; ::=</p>

<p>  ALTER DATABASE имя_базы_данных</p>

<p>  { ADD FILE &lt;определение_файла&gt;[,...n]</p>

<p>    [TO FILEGROUP имя_группы_файлов ]</p>

<p>  | ADD LOG FILE &lt;определение_файла&gt;[,...n]</p>

<p>  | REMOVE FILE логическое_имя_файла</p>

<p>  | ADD FILEGROUP имя_группы_файлов</p>

<p>  | REMOVE FILEGROUP имя_группы_файлов</p>

<p>  | MODIFY FILE &lt;определение_файла&gt;</p>

<p>  | MODIFY FILEGROUP имя_группы_файлов</p>

<p>  &lt;свойства_группы_файлов&gt;}</p>

<p>Как видно из синтаксиса, за один вызов команды может быть изменено не более одного параметра конфигурации <emphasis>базы данных</emphasis>. Если необходимо выполнить несколько изменений, придется разбить процесс на ряд отдельных шагов.</p>

<p>В <emphasis>базу данных</emphasis> можно добавить ( ADD ) новые файлы данных (в указанную группу файлов или в группу, принятую по умолчанию) или файлы <emphasis>журнала транзакций</emphasis>.</p>

<p>Параметры файлов и групп файлов можно изменять ( MODIFY ).</p>

<p>Для удаления из <emphasis>базы данных</emphasis> файлов или групп файлов используется параметр REMOVE. Однако удаление файла возможно лишь при условии его освобождения от данных. В противном случае сервер не разрешит удаление.</p>

<p>В качестве свойств группы файлов используются следующие:</p>

<p>READONLY – группа файлов используется только для чтения; READWRITE – в группе файлов разрешаются изменения; DEFAULT – указанная группа файлов принимается по умолчанию.</p>

<p><strong>Удаление базы данных</strong></p>

<p>Удаление <emphasis>базы данных</emphasis> осуществляется командой:</p>

<p>DROP DATABASE имя_базы_данных [,...n]</p>

<p>Удаляются все содержащиеся в <emphasis>базе данных</emphasis> объекты, а также файлы, в которых она размещается. Для исполнения операции удаления <emphasis>базы данных</emphasis> пользователь должен обладать соответствующими правами.</p>

<p><strong>Таблица</strong></p>

<p><strong>Создание таблицы</strong></p>

<p>После создания общей структуры <emphasis>базы данных</emphasis> можно приступить к <emphasis>созданию таблиц</emphasis>, которые представляют собой отношения, входящие в состав проекта <emphasis>базы данных</emphasis>.</p>

<p><strong><emphasis>Таблица</emphasis></strong> – основной объект для хранения информации в реляционной <emphasis>базе данных</emphasis>. Она состоит из содержащих данные <emphasis>строк</emphasis> и <emphasis>столбцов</emphasis>, занимает в <emphasis>базе данных</emphasis> физическое пространство и может быть постоянной или временной.</p>

<p>Поле, также называемое в реляционной <emphasis>базе данных</emphasis> <emphasis>столбцом</emphasis>, является частью <emphasis>таблицы</emphasis>, за которой закреплен определенный тип данных. Каждая <emphasis>таблица</emphasis> <emphasis>базы данных</emphasis> должна содержать хотя бы один <emphasis>столбец</emphasis>. <emphasis>Строка</emphasis> данных – это запись в <emphasis>таблице</emphasis> <emphasis>базы данных</emphasis>, она включает поля, содержащие данные из одной записи <emphasis>таблицы</emphasis>.</p>

<p>Приступая к <emphasis>созданию таблицы</emphasis>, необходимо иметь ответы на ряд вопросов:</p>

<p>Как будет называться <emphasis>таблица</emphasis>?</p>

<p>Как будут называться <emphasis>столбцы</emphasis> (поля) <emphasis>таблицы</emphasis>?</p>

<p>Какие типы данных будут закреплены за каждым <emphasis>столбцом</emphasis>?</p>

<p>Какой размер памяти должен быть выделен для хранения каждого <emphasis>столбца</emphasis>?</p>

<p>Какие <emphasis>столбцы</emphasis> <emphasis>таблицы</emphasis> требуют обязательного ввода?</p>

<p>Из каких <emphasis>столбцов</emphasis> будет состоять первичный ключ?</p>

<p>Базовый синтаксис оператора <emphasis>создания таблицы</emphasis> имеет следующий вид:</p>

<p>&lt;определение_таблицы&gt; ::=</p>

<p>   CREATE TABLE имя_таблицы</p>

<p>   (имя_столбца тип_данных</p>

<p>     [NULL | NOT NULL ] [,...n])</p>

<p>Приведенный стандарт совпадает с реализацией оператора <emphasis>создания таблицы</emphasis> в среде MS SQL Server.</p>

<p>Главное в команде <emphasis>создания таблицы</emphasis> – определение <emphasis>имени таблицы</emphasis> и описание набора имен полей, которые указываются в соответствующем порядке. Кроме того, этой командой оговариваются типы данных и размеры полей <emphasis>таблицы</emphasis>.</p>

<p>Ключевое слово NULL используется для указания того, что в данном <emphasis>столбце</emphasis> могут содержаться значения NULL. Значение NULL отличается от пробела или нуля – к нему прибегают, когда необходимо указать, что данные недоступны, опущены или недопустимы. Если указано ключевое слово NOT NULL, то будут отклонены любые попытки поместить значение NULL в данный <emphasis>столбец</emphasis>. Если указан параметр NULL, помещение значений NULL в <emphasis>столбец</emphasis> разрешено. По умолчанию стандарт SQL предполагает наличие ключевого слова NULL.</p>

<p>Мы использовали упрощенную версию оператора CREATE TABLE стандарта SQL. Его полная версия приводится при обсуждении вопросов обеспечения целостности данных.</p>

<p><strong>Пример 3.2</strong>. Создать <emphasis>таблицу</emphasis> для хранения данных о товарах, поступающих в продажу в некоторой торговой фирме. Необходимо учесть такие сведения, как название и тип товара, его цена, сорт и город, где товар производится.</p>

<p>CREATE TABLE Товар</p>

<p>(Название       VARCHAR(50) NOT NULL,</p>

<p>    Цена        MONEY NOT     NULL,</p>

<p>    Тип         VARCHAR(50) NOT NULL,</p>

<p>    Сорт        VARCHAR(50),</p>

<p>    ГородТовара VARCHAR(50))</p>

<p>Пример 3.2. Создание таблицы для хранения данных о товарах, поступающих в продажу в некоторой торговой фирме.</p>

<p><strong>Пример 3.3</strong>.Создать <emphasis>таблицу</emphasis> для сохранения сведений о постоянных клиентах с указанием названий города и фирмы, фамилии, имени и отчества клиента, номера его телефона.</p>

<p>CREATE TABLE  Клиент</p>

<p>    (Фирма       VARCHAR(50) NOT NULL,</p>

<p>    Фамилия      VARCHAR(50) NOT NULL,</p>

<p>    Имя          VARCHAR(50) NOT NULL,</p>

<p>    Отчество     VARCHAR(50),</p>

<p>    ГородКлиента VARCHAR(50),</p>

<p>    Телефон      CHAR(10) NOT NULL)</p>

<p>Пример 3.3. Создание таблицы для сохранения сведений о постоянных клиентах.</p>

<p><strong>Изменение таблицы</strong></p>

<p>Структура существующей <emphasis>таблицы</emphasis> может быть модифицирована с помощью команды ALTER TABLE, упрощенный синтаксис которой представлен ниже:</p>

<p>ALTER TABLE имя_таблицы</p>

<p>  {[ADD [COLUMN] имя_столбца тип_данных [</p>

<p>    NULL | NOT NULL ]]</p>

<p>  | [DROP [COLUMN] имя_столбца]}</p>

<p>В среде MS SQL Server упрощенный синтаксис команды модификации <emphasis>таблицы</emphasis> имеет вид:</p>

<p>ALTER TABLE имя_таблицы</p>

<p>  {[ALTER COLUMN имя_столбца</p>

<p>  {новый_тип_данных [(точность[,масштаб])]</p>

<p>    [ NULL | NOT NULL ]}]</p>

<p>  | ADD { [имя_столбца тип_данных]</p>

<p>  | имя_столбца AS выражение } [,...n]</p>

<p>  | DROP {COLUMN имя_столбца}[,...n]</p>

<p>  }</p>

<p>Команда позволяет добавлять и удалять <emphasis>столбцы</emphasis>, изменять их определения.</p>

<p>Одно из основных правил при добавлении <emphasis>столбцов</emphasis> в существующую <emphasis>таблицу</emphasis> гласит: когда в <emphasis>таблице</emphasis> уже содержатся данные, добавляемый <emphasis>столбец</emphasis> не может быть определен с атрибутом NOT NULL. Этот атрибут означает, что для каждой <emphasis>строки</emphasis> данных соответствующий <emphasis>столбец</emphasis>должен содержать некоторое значение, поэтому добавление <emphasis>столбца</emphasis> с атрибутом NOT NULL приводит к появлению противоречия – уже существующие <emphasis>строки</emphasis> данных <emphasis>таблицы</emphasis> не будут иметь в новом <emphasis>столбце</emphasis> ненулевых значений.</p>

<p>Тем не менее существует способ добавления обязательных полей в существующую <emphasis>таблицу</emphasis>. Для этого необходимо:</p>

<p>добавить в <emphasis>таблицу</emphasis> новый <emphasis>столбец</emphasis>, определив его с атрибутом NULL (т.е. <emphasis>столбец</emphasis> не обязан содержать каких-либо значений);</p>

<p>ввести в новый <emphasis>столбец</emphasis> какие-либо значения для каждой <emphasis>строки</emphasis> данных <emphasis>таблицы</emphasis> ;</p>

<p>убедившись, что новый <emphasis>столбец</emphasis> содержит ненулевые значения для каждой <emphasis>строки данных</emphasis>, изменить структуру <emphasis>таблицы</emphasis>, заменив атрибут этого <emphasis>столбца</emphasis> на NOT NULL.</p>

<p>При <emphasis>изменении</emphasis> определений <emphasis>столбцов</emphasis> следует принимать во внимание некоторые общепринятые правила:</p>

<p>размер <emphasis>столбца</emphasis> может быть увеличен до максимального значения, допускаемого соответствующим типом данных;</p>

<p>размер <emphasis>столбца</emphasis> может быть уменьшен только в том случае, если содержащееся в нем наибольшее значение не будет превосходить его нового размера;</p>

<p>количество разрядов числового типа данных всегда может быть увеличено;</p>

<p>количество разрядов числового типа данных может быть уменьшено только в том случае, если количество разрядов наибольшего значения в соответствующем <emphasis>столбце</emphasis> не будет превосходить нового числа разрядов, определенного для этого <emphasis>столбца</emphasis> ;</p>

<p>количество десятичных знаков числового типа данных может быть уменьшено или увеличено;</p>

<p><emphasis>тип данных столбца</emphasis>, как правило, может быть изменен.</p>

<p>Некоторые реализации фактически могут ограничить разработчика в использовании некоторых опций команды ALTER TABLE. Например, может оказаться недопустимым удаление <emphasis>столбцов</emphasis> из существующей <emphasis>таблицы</emphasis>. Чтобы добиться этого, сначала потребуется удалить саму <emphasis>таблицу</emphasis> и только потом заново ее построить с нужными <emphasis>столбцами</emphasis>. Причем уже внесенные в <emphasis>таблицу</emphasis> данные будут потеряны.</p>

<p>Возможны трудности, связанные с удалением из <emphasis>таблицы</emphasis> <emphasis>столбца</emphasis>, который зависит от некоторого <emphasis>столбца</emphasis> другой <emphasis>таблицы</emphasis>. В таком случае сначала придется удалить ограничение <emphasis>столбца</emphasis>, а затем сам <emphasis>столбец</emphasis>.</p>

<p><strong>Пример 3.4</strong>. Добавить в <emphasis>таблицу</emphasis> Клиент поле для номера расчетного счета.</p>

<p>ALTER TABLE Клиент ADD Рас_счет CHAR(20)</p>

<p>Пример 3.4. Добавление в таблицу Клиент поля для номера расчетного счета.</p>

<p><strong>Удаление таблицы</strong></p>

<p>С течением времени структура <emphasis>базы данных</emphasis> меняется: создаются новые <emphasis>таблицы</emphasis>, а прежние становятся ненужными и удаляются из <emphasis>базы данных</emphasis> с помощью оператора:</p>

<p>DROP TABLE имя_таблицы [RESTRICT | CASCADE]</p>

<p>Следует отметить, что эта команда удалит не только указанную <emphasis>таблицу</emphasis>, но и все входящие в нее <emphasis>строки</emphasis> данных. Если требуется удалить из <emphasis>таблицы</emphasis> лишь данные, сохранив структуру <emphasis>таблицы</emphasis>, следует воспользоваться командой DELETE.</p>

<p>Оператор DROP TABLE дополнительно позволяет указывать, следует ли операцию <emphasis>удаления</emphasis> выполнять каскадно. Если в операторе указано ключевое слово RESTRICT, то при наличии в <emphasis>базе данных</emphasis> хотя бы одного объекта, существование которого зависит от удаляемой <emphasis>таблицы</emphasis>, выполнение оператора DROP TABLE будет отменено. Если указано ключевое слово CASCADE, автоматически удаляются и все прочие объекты <emphasis>базы данных</emphasis>, чье существование зависит от удаляемой <emphasis>таблицы</emphasis>, а также другие объекты, зависящие от удаляемых объектов. Общий эффект от выполнения оператора DROP TABLE с ключевым словом CASCADE может оказаться весьма ощутимым, поэтому подобные операторы следует использовать с максимальной осторожностью.</p>

<p>Чаще всего оператор DROP TABLE используется для исправления ошибок, допущенных при <emphasis>создании таблицы</emphasis>. Если <emphasis>таблица</emphasis> была создана с некорректной структурой, можно воспользоваться оператором DROP TABLE для ее <emphasis>удаления</emphasis>, после чего создать <emphasis>таблицу</emphasis> заново.</p>

<p><strong>Индексы</strong></p>

<p><strong>Индексы в стандарте языка</strong></p>

<p><strong><emphasis>Индексы</emphasis></strong> представляют собой структуру, позволяющую выполнять ускоренный доступ к <emphasis>строкам</emphasis> <emphasis>таблицы</emphasis> на основе значений одного или более ее <emphasis>столбцов</emphasis> . Наличие <emphasis>индекса</emphasis> может существенно повысить скорость выполнения некоторых запросов и сократить время поиска необходимых данных за счет физического или логического их упорядочивания. <strong><emphasis>Индекс</emphasis></strong> – это набор ссылок, упорядоченных по определенному <emphasis>столбцутаблицы</emphasis>, который в данном случае будет называться индексированным <emphasis>столбцом</emphasis> . Хотя <emphasis>индекс</emphasis> и связан с конкретным <emphasis>столбцом</emphasis> (или <emphasis>столбцами</emphasis>) <emphasis>таблицы</emphasis>, все же он является самостоятельным объектом <emphasis>базы данных</emphasis>.</p>

<p>Физически <emphasis>индекс</emphasis> – всего лишь упорядоченный набор значений из индексированного <emphasis>столбца</emphasis> с указателями на места физического размещения исходных <emphasis>строк</emphasis> в структуре <emphasis>базы данных</emphasis>. Когда пользователь выполняет обращающийся к индексированному <emphasis>столбцу</emphasis> запрос, СУБД автоматически анализирует <emphasis>индекс</emphasis> для поиска требуемых значений.</p>

<p>Однако, поскольку <emphasis>индексы</emphasis> должны обновляться системой при каждом внесении <emphasis>изменений</emphasis> в их базовую <emphasis>таблицу</emphasis>, они создают дополнительную нагрузку на систему.</p>

<p><emphasis>Индексы</emphasis> обычно создаются с целью удовлетворения определенных критериев поиска после того, как <emphasis>таблица</emphasis> уже находилась некоторое время в работе и увеличилась в размерах. <emphasis>Создание индексов</emphasis> не предусмотрено стандартом SQL, однако большинство диалектов поддерживают как минимум следующий оператор:</p>

<p>CREATE [ UNIQUE ] INDEX имя_индекса</p>

<p>  ON имя_таблицы(имя_столбца[ASC|DESC][,...n])</p>

<p>Указанные в операторе <emphasis>столбцы</emphasis> составляют <emphasis>ключ индекса</emphasis>. <emphasis>Индексы</emphasis> могут создаваться только для базовых <emphasis>таблиц</emphasis>, но не для представлений. Если в операторе указано ключевое слово UNIQUE, уникальность значений <emphasis>ключа индекса</emphasis> будет автоматически поддерживаться системой. Требование уникальности значений обязательно для первичных ключей, а также возможно и для других <emphasis>столбцов</emphasis> <emphasis>таблицы</emphasis> (например, для альтернативных ключей). Хотя <emphasis>создание индекса</emphasis> допускается в любой момент, при его построении для уже заполненной данными <emphasis>таблицы</emphasis>могут возникнуть проблемы, связанные с дублированием данных в различных <emphasis>строках</emphasis>. Следовательно, <emphasis>уникальные индексы</emphasis> (по крайней мере, для первичного ключа) имеет смысл создавать непосредственно при формировании <emphasis>таблицы</emphasis>. В результате система сразу возьмет на себя контроль за уникальностью значений данных в соответствующих <emphasis>столбцах</emphasis>.</p>

<p>Если созданный <emphasis>индекс</emphasis> впоследствии окажется ненужным, его можно удалить с помощью оператора</p>

<p>DROP INDEX имя_индекса</p>

<p><strong>Индексы в среде MS SQL Server</strong></p>

<p><strong><emphasis>Индекс</emphasis></strong> представляет собой средство, помогающее ускорить поиск необходимых данных за счет физического или логического их упорядочивания. Индекс представляет собой набор ссылок, упорядоченных по определенному столбцу таблицы, который в данном случае будет называться индексированным столбцом. Индексы - это наборы уникальных значений для некоторой <emphasis>таблицы</emphasis> с соответствующими ссылками на данные. Они расположены в самой <emphasis>таблице</emphasis> и являются удобным внутренним механизмом системы SQL-сервера, с помощью которого осуществляется доступ к данным оптимальным способом. В среде SQL Server реализованы эффективные алгоритмы поиска нужного значения в строго определенной последовательности данных. Ускорение поиска достигается именно за счет того, что данные представляются упорядоченными (хотя физически, в зависимости от типа <emphasis>индекса</emphasis>, они могут храниться в соответствии с очередностью их добавления в <emphasis>таблицу</emphasis> ). К настоящему времени разработаны эффективные математические алгоритмы поиска данных в упорядоченной последовательности. Наиболее эффективной структурой для поиска данных в машинном представлении являются B-деревья – многоуровневая иерархическая структура с переменным количеством элементов в каждом узле.</p>

<p><strong>Создание индекса</strong></p>

<p>Если выборка данных из <emphasis>таблицы</emphasis> требует значительного времени, это означает, что для нее необходимо создать <emphasis>индекс</emphasis>. <emphasis>Индексы</emphasis> могут существенно повысить производительность выполнения операций поиска и выборки данных. При выборе <emphasis>столбца</emphasis> для <emphasis>индекса</emphasis> следует проанализировать, какие типы запросов чаще всего выполняются пользователями и какие <emphasis>столбцы</emphasis> являются ключевыми, т.е. задающими критерии выборки данных, например, порядок сортировки.</p>

<p>В среде SQL Server реализовано несколько типов <emphasis>индексов</emphasis>:</p>

<p><emphasis>кластерные индексы</emphasis> ;</p>

<p><emphasis>некластерные индексы</emphasis> ;</p>

<p><emphasis>уникальные индексы</emphasis>.</p>

<p><strong>Некластерный индекс</strong></p>

<p><strong><emphasis>Некластерные индексы</emphasis></strong> – наиболее типичные представители семейства <emphasis>индексов</emphasis>. В отличие от <emphasis>кластерных</emphasis>, они не перестраивают физическую структуру <emphasis>таблицы</emphasis>, а лишь организуют ссылки на соответствующие <emphasis>строки</emphasis> .</p>

<p>Для идентификации нужной <emphasis>строки</emphasis> в <emphasis>таблице</emphasis> <emphasis>некластерный индекс</emphasis> организует специальные указатели, включающие в себя:</p>

<p>информацию об идентификационном номере файла, в котором хранится <emphasis>строка</emphasis> ;</p>

<p>идентификационный номер страницы соответствующих данных;</p>

<p>номер искомой <emphasis>строки</emphasis> на соответствующей странице;</p>

<p>содержимое <emphasis>столбца</emphasis>.</p>

<p>В большинстве случаев следует ограничиваться 4-5 <emphasis>индексами</emphasis>.</p>

<p><strong>Кластерный индекс</strong></p>

<p>Принципиальным отличием <strong><emphasis>кластерного индекса</emphasis></strong> от <emphasis>индексов</emphasis> других типов является то, что при его определении в <emphasis>таблице</emphasis> физическое расположение данных перестраивается в соответствии со структурой <emphasis>индекса</emphasis> . Логическая структура <emphasis>таблицы</emphasis> в этом случае представляет собой скорее словарь, чем <emphasis>индекс</emphasis>. Данные в словаре физически упорядочены, например по алфавиту.</p>

<p><emphasis>Кластерные индексы</emphasis> могут дать существенное увеличение производительности поиска данных даже по сравнению с обычными <emphasis>индексами</emphasis>. Увеличение производительности особенно заметно при работе с последовательными данными. Если в <emphasis>таблице</emphasis> определен <emphasis>некластерный индекс</emphasis>, то сервер должен сначала обратиться к <emphasis>индексу</emphasis>, а затем найти нужную <emphasis>строку</emphasis> в <emphasis>таблице</emphasis>. При использовании <emphasis>кластерных индексов</emphasis> следующая порция данных располагается сразу после найденных ранее данных. Благодаря этому отпадают лишние операции, связанные с обращением к <emphasis>индексу</emphasis> и новым поиском нужной <emphasis>строки</emphasis> в <emphasis>таблице</emphasis>.</p>

<p>Естественно, в <emphasis>таблице</emphasis> может быть определен только один <emphasis>кластерный индекс</emphasis>. В качестве такового следует выбирать наиболее часто используемые <emphasis>столбцы</emphasis>. При этом стоит следовать общим рекомендациям <emphasis>создания индексов</emphasis> и не индексировать слишком длинные <emphasis>столбцы</emphasis>.</p>

<p><emphasis>Кластерный индекс</emphasis> может включать несколько <emphasis>столбцов</emphasis>. Однако количество таких <emphasis>столбцов</emphasis> рекомендуется по возможности свести к минимуму.</p>

<p>Необходимо избегать <emphasis>создания</emphasis> <emphasis>кластерного индекса</emphasis> для часто изменяемых <emphasis>столбцов</emphasis>, поскольку сервер должен будет выполнять физическое перемещение всех данных в <emphasis>таблице</emphasis>, чтобы они находились в упорядоченном состоянии, как того требует <emphasis>кластерный индекс</emphasis>. Для интенсивно изменяемых <emphasis>столбцов</emphasis> лучше подходит <emphasis>некластерный индекс</emphasis>.</p>

<p>При создании в <emphasis>таблице</emphasis> первичного ключа ( PRIMARY KEY ) сервер автоматически создает для него <emphasis>кластерный индекс</emphasis>, если его не существовало ранее или если при определении ключа не был явно указан другой тип <emphasis>индекса</emphasis>.</p>

<p>Когда же в <emphasis>таблице</emphasis> определен еще и <emphasis>некластерный индекс</emphasis>, то его указатель ссылается не на физическое положение <emphasis>строки</emphasis> в <emphasis>базе данных</emphasis>, а на соответствующий элемент <emphasis>кластерного индекса</emphasis>, описывающего эту <emphasis>строку</emphasis>, что позволяет не перестраивать структуру <emphasis>некластерных индексов</emphasis>всякий раз, когда <emphasis>кластерный индекс</emphasis> меняет физический порядок <emphasis>строк</emphasis> в <emphasis>таблице</emphasis>.</p><empty-line /><p><strong>Основы SQL</strong></p><empty-line /><p>[+]</p>

<p>Записаться</p>

<p>|</p>

<p>Вам нравится?  Нравится 189 студентам</p>

<p> | Поделиться |</p>

<p> Поддержать курс</p>

<p> | Скачать электронную книгу</p>

<p>Лекция 3:</p>

<p>Создание базы данных и проектирование таблиц</p>

<p><strong>A</strong></p>

<p> |</p>

<p>версия для печати</p>

<p>&lt; Лекция 2 || <strong>Лекция 3</strong>: 123<strong>4</strong> || Лекция 4 &gt;</p>

<p><strong>Уникальный индекс</strong></p>

<p>Уникальность значений в индексируемом <emphasis>столбце</emphasis> гарантируют <emphasis>уникальные индексы</emphasis>. При их наличии сервер не разрешит вставить новое или изменить существующее значение таким образом, чтобы в результате этой операции в <emphasis>столбце</emphasis> появились два одинаковых значения.</p>

<p><emphasis>Уникальный индекс</emphasis> является своеобразной надстройкой и может быть реализован как для <emphasis>кластерного</emphasis>, так и для <emphasis>некластерного индекса</emphasis> . В одной <emphasis>таблице</emphasis> может существовать один уникальный <emphasis>кластерный</emphasis> и множество уникальных <emphasis>некластерных индексов</emphasis>.</p>

<p><emphasis>Уникальные индексы</emphasis> следует определять только тогда, когда это действительно необходимо. Для обеспечения целостности данных в <emphasis>столбце</emphasis>можно определить ограничение целостности UNIQUE или PRIMARY KEY, а не прибегать к <emphasis>уникальным индексам</emphasis>. Их использование только для обеспечения целостности данных является неоправданной тратой пространства в <emphasis>базе данных</emphasis>. Кроме того, на их поддержание тратится и процессорное время.</p>

<p>Средства языка SQL предлагают несколько способов определения <emphasis>индекса</emphasis>:</p>

<p>автоматическое <emphasis>создание индекса</emphasis> при создании первичного ключа;</p>

<p>автоматическое <emphasis>создание индекса</emphasis> при определении ограничения целостности UNIQUE ;</p>

<p><emphasis>создание индекса</emphasis> с помощью команды CREATE INDEX.</p>

<p>Последняя команда имеет следующий формат:</p>

<p>&lt;создание_индекса&gt;::=</p>

<p>  CREATE [ UNIQUE ]</p>

<p>    [ CLUSTERED | NONCLUSTERED ]</p>

<p>  INDEX имя_индекса ON имя_таблицы(имя_столбца</p>

<p>    [ASC|DESC][,...n])</p>

<p>  [WITH [PAD_INDEX]</p>

<p>    [[,] FILLFACTOR=фактор_заполнения]</p>

<p>    [[,] IGNORE_DUP_KEY]</p>

<p>    [[,] DROP_EXISTING]</p>

<p>    [[,] STATISTICS_NORECOMPUTE] ]</p>

<p>    [ON имя_группы_файлов ]</p>

<p>Рассмотрим некоторые параметры приведенной команды.</p>

<p>Имя <emphasis>индекса</emphasis> должно быть уникальным в пределах <emphasis>таблицы</emphasis>, а сам <emphasis>индекс</emphasis> создается исключительно для <emphasis>таблицы</emphasis> текущей <emphasis>базы данных</emphasis>.</p>

<p>Параметр UNIQUE используется при необходимости ввода в определенное поле только уникальных значений. При указании этого ключевого слова будет создан <emphasis>уникальный индекс</emphasis>. В индексируемом <emphasis>столбце</emphasis> желательно запретить хранение значений NULL, чтобы избежать проблем, связанных с уникальностью значений. После того как для <emphasis>столбца</emphasis> появится <emphasis>уникальный индекс</emphasis>, сервер не разрешит выполнение команд INSERT и UPDATE, которые приведут к появлению дублирующих значений.</p>

<p>Параметр CLUSTERED использует возможность физического индексирования данных и позволяет произвести так называемое кластерное индексирование, в результате чего будут отсортированы данные в самой <emphasis>таблице</emphasis> согласно порядку этого <emphasis>индекса</emphasis>, а вся добавляемая информация станет приводить к изменению физического порядка данных. <emphasis>Кластерным</emphasis> может быть только один <emphasis>индекс</emphasis> в <emphasis>таблице</emphasis>.</p>

<p>Параметр NONCLUSTERED позволяет создавать <emphasis>некластерные индексы</emphasis>.</p>

<p>Параметр FILLFACTOR осуществляет настройку разбиения <emphasis>индекса</emphasis> на страницы и заметно оптимизирует работу SQL-сервера. Коэффициент FILLFACTOR определяет в процентном соотношении размер создаваемых индексных страниц. При этом имеется обратно пропорциональная зависимость частоты работы с <emphasis>таблицей</emphasis> и коэффициента FILLFACTOR.</p>

<p>Параметр PAD_INDEX определяет заполнение внутреннего пространства <emphasis>индекса</emphasis> и применяется совместно с FILLFACTOR.</p>

<p>Параметр DROP_EXISTING при использовании <emphasis>кластерного индекса</emphasis> определяет его повторное создание, что позволяет предотвратить нежелательное обновление <emphasis>кластерных индексов</emphasis>.</p>

<p>Параметр STATISTICS_NORECOMPUTE определяет функции автоматического обновления статистики для <emphasis>таблицы</emphasis>.</p>

<p>Параметр имя_группы_файлов позволяет осуществить выбор файловой группы, в которой будет находиться создаваемый <emphasis>индекс</emphasis>. Использование <emphasis>индекса</emphasis> из другой файловой группы повышает производительность <emphasis>некластерных индексов</emphasis> в связи с параллельностью выполнения процессов ввода/вывода и работы с самим <emphasis>индексом</emphasis>.</p>

<p><strong>Удаление индекса</strong></p>

<p><emphasis>Удаление индекса</emphasis> выполняется командой</p>

<p>DROP INDEX 'имя_индекса'[,...n]</p>

<p><strong>Пример 3.5</strong>. Создать уникальный <emphasis>кластерный индекс</emphasis> для <emphasis>таблицы</emphasis> Клиент по <emphasis>столбцу</emphasis> Фамилия в первичной группе файлов.</p>

<p>CREATE UNIQUE CLUSTERED INDEX index_klient1</p>

<p>  ON Клиент (Фамилия)</p>

<p>  WITH DROP_EXISTING</p>

<p>  ON PRIMARY</p>

<p>Пример 3.5. Создание уникального кластерного индекса.</p>

<p><strong>Пример 3.6</strong>.Создать уникальный <emphasis>некластерный индекс</emphasis> для <emphasis>таблицы</emphasis> Клиент по <emphasis>столбцам</emphasis> Фамилия и Имя в первичной группе файлов. Кроме того, элементы <emphasis>индекса</emphasis> будут упорядочены по убыванию. Также запретим автоматическое обновление статистики при изменении данных в <emphasis>таблице</emphasis> и установим фактор заполнения индексных страниц на уровне 30%.</p>

<p>CREATE UNIQUE NONCLUSTERED INDEX index_klient2</p>

<p>  ON Клиент (Фамилия DESC,Имя DESC)</p>

<p>  WITH FILLFACTOR=30,</p>

<p>  STATISTICS_NORECOMPUTE</p>

<p>  ON PRIMARY</p>

<p>Пример 3.6. Создание уникального некластерного индекса.</p><empty-line /><p>Лекция 4</p><empty-line /><p><strong>Предложение SELECT</strong></p>

<p>Оператор SELECT – один из наиболее важных и самых распространенных операторов <emphasis>SQL</emphasis>. Он позволяет производить <emphasis>выборки</emphasis> данных из таблиц и преобразовывать к нужному виду полученные результаты. Будучи очень мощным, он способен выполнять действия, эквивалентные операторам реляционной алгебры, причем в пределах единственной выполняемой команды. При его помощи можно реализовать сложные и громоздкие условия отбора данных из различных таблиц.</p>

<p>Оператор SELECT – средство, которое полностью абстрагировано от вопросов представления данных, что помогает сконцентрировать внимание на проблемах доступа к данным. Примеры его использования наглядно демонстрируют один из основополагающих принципов больших (промышленных) <emphasis>СУБД</emphasis>: средства хранения данных и доступа к ним отделены от средств представления данных. <emphasis>Операции</emphasis> над данными производятся в масштабе наборов данных, а не отдельных записей.</p>

<p>Оператор SELECT имеет следующий формат:</p>

<p>SELECT [ALL | DISTINCT ] {*|[имя_столбца</p>

<p>  [AS       новое_имя]]} [,...n]</p>

<p>  FROM  имя_таблицы [[AS] псевдоним] [,...n]</p>

<p>  [WHERE  &lt;условие_поиска&gt;]</p>

<p>  [GROUP BY  имя_столбца [,...n]]</p>

<p>  [HAVING &lt;критерии выбора групп&gt;]</p>

<p>  [ORDER BY имя_столбца [,...n]]</p>

<p>Оператор SELECT определяет поля (столбцы), которые будут входить в <emphasis>результат выполнения запроса</emphasis>. В списке они разделяются запятыми и приводятся в такой очередности, в какой должны быть представлены в <emphasis>результате запроса</emphasis>. Если используется имя поля, содержащее пробелы или разделители, его следует заключить в квадратные скобки. Символом * можно выбрать все поля, а вместо имени поля применить <emphasis>выражение</emphasis> из нескольких имен.</p>

<p>Если обрабатывается ряд таблиц, то (при наличии одноименных полей в разных таблицах) в списке полей используется полная спецификация поля, т.е. Имя_таблицы.Имя_поля.</p>

<p><strong>Предложение FROM</strong></p>

<p>Предложение FROM задает имена таблиц и представлений, которые содержат поля, перечисленные в операторе SELECT. Необязательный <emphasis>параметр</emphasis> псевдонима – это сокращение, устанавливаемое для имени таблицы.</p>

<p>Обработка элементов оператора SELECT выполняется в следующей последовательности:</p>

<p>FROM – определяются имена используемых таблиц;</p>

<p>WHERE – выполняется <emphasis>фильтрация строк</emphasis> объекта в соответствии с заданными условиями;</p>

<p>GROUP BY – образуются <emphasis>группы строк,</emphasis> имеющих одно и то же значение в указанном столбце;</p>

<p>HAVING – фильтруются группы строк объекта в соответствии с указанным условием;</p>

<p>SELECT – устанавливается, какие столбцы должны присутствовать в выходных данных;</p>

<p>ORDER BY – определяется упорядоченность результатов выполнения операторов.</p>

<p>Порядок предложений и фраз в операторе SELECT не может быть изменен. Только два предложения SELECT и FROM являются обязательными, все остальные могут быть опущены. SELECT – закрытая операция: <emphasis>результат запроса</emphasis> к таблице представляет собой другую таблицу. Существует множество вариантов записи данного оператора, что иллюстрируется приведенными ниже примерами.</p>

<p><strong>Пример 4.1</strong>. Составить <emphasis>список</emphasis> сведений о всех клиентах.</p>

<p>SELECT * FROM Клиент</p>

<p>Пример 4.1. Список сведений о всех клиентах.</p>

<p><emphasis>Параметр</emphasis> WHERE определяет <emphasis>критерий отбора</emphasis> записей из входного набора. Но в таблице могут присутствовать повторяющиеся записи (дубликаты). <emphasis>Предикат</emphasis> ALL задает включение в выходной набор всех дубликатов, отобранных по критерию WHERE. Нет необходимости указывать ALL явно, поскольку это <emphasis>значение</emphasis> действует по умолчанию.</p>

<p><strong>Пример 4.2</strong>. Составить <emphasis>список</emphasis> всех фирм.</p>

<p>SELECT ALL Клиент.Фирма FROM Клиент</p><empty-line /><p>Или (что эквивалентно)</p><empty-line /><p>SELECT Клиент.Фирма FROM Клиент</p>

<p>Пример 4.2. Список всех фирм.</p>

<p><emphasis>Результат выполнения запроса</emphasis> может содержать <emphasis>дублирующиеся значения</emphasis>, поскольку в отличие от <emphasis>операций реляционной алгебры</emphasis> оператор SELECT не исключает повторяющихся значений при выполнении <emphasis>выборки данных</emphasis>.</p>

<p><emphasis>Предикат</emphasis> DISTINCT следует применять в тех случаях, когда требуется отбросить блоки данных, содержащие <emphasis>дублирующие записи</emphasis> в выбранных полях. Значения для каждого из приведенных в инструкции SELECT полей должны быть уникальными, чтобы содержащая их <emphasis>запись</emphasis> смогла войти в выходной набор.</p>

<p>Причиной ограничения в применении DISTINCT является то обстоятельство, что его использование может резко замедлить выполнение запросов.</p>

<p>Откорректированный пример 4.2 выглядит следующим образом:</p>

<p>SELECT DISTINCT Клиент.Фирма</p>

<p>   FROM Клиент</p>

<p><strong>Предложение WHERE</strong></p>

<p>С помощью <emphasis>WHERE</emphasis>-параметра <emphasis>пользователь</emphasis> определяет, какие блоки данных из приведенных в списке <emphasis>FROM</emphasis> таблиц появятся в <emphasis>результате запроса</emphasis>. За ключевым словом WHERE следует перечень <emphasis>условий поиска</emphasis>, определяющих те строки, которые должны быть выбраны при выполнении запроса. Существует пять основных типов <emphasis>условий поиска</emphasis> (или предикатов):</p>

<p><emphasis>Сравнение</emphasis>: сравниваются результаты вычисления одного выражения с результатами вычисления другого.</p>

<p><emphasis>Диапазон</emphasis>: проверяется, попадает ли результат вычисления выражения в заданный <emphasis>диапазон</emphasis> значений.</p>

<p><emphasis>Принадлежность множеству</emphasis>: проверяется, принадлежит ли результат вычислений выражения заданному множеству значений.</p>

<p><emphasis>Соответствие шаблону</emphasis>: проверяется, отвечает ли некоторое строковое значение заданному шаблону.</p>

<p><emphasis>Значение</emphasis> NULL: проверяется, содержит ли данный столбец определитель NULL (неизвестное значение).</p>

<p><strong>Сравнение</strong></p>

<p>В языке SQL можно использовать следующие операторы <emphasis>сравнения</emphasis>: = – равенство; &lt; – меньше; &gt; – больше; &lt;= – меньше или равно; &gt;=– больше или равно; &lt;&gt; – не равно.</p>

<p><strong>Пример 4.3</strong>. Показать все операции отпуска товаров объемом больше 20.</p>

<p>SELECT * FROM Сделка</p>

<p>    WHERE Количество&gt;20</p>

<p>Пример 4.3. Операции отпуска товаров объемом больше 20.</p>

<p>Более сложные предикаты могут быть построены с помощью логических операторов AND, OR или NOT, а также скобок, используемых для определения порядка вычисления выражения. Вычисление выражения в <emphasis>условиях</emphasis> выполняется по следующим правилам:</p>

<p>Выражение вычисляется слева направо.</p>

<p>Первыми вычисляются подвыражения в скобках.</p>

<p>Операторы NOT выполняются до выполнения операторов AND и OR.</p>

<p>Операторы AND выполняются до выполнения операторов OR.</p>

<p>Для устранения любой возможной неоднозначности рекомендуется использовать скобки.</p>

<p><strong>Пример 4.4</strong>. Вывести список товаров, цена которых больше или равна 100 и меньше или равна 150.</p>

<p>SELECT Название, Цена</p>

<p>    FROM Товар</p>

<p>    WHERE Цена&gt;=100 And Цена&lt;=150</p>

<p>Пример 4.4. Список товаров, цена которых больше или равна 100 и меньше или равна 150.</p>

<p><strong>Пример 4.5</strong>. Вывести список клиентов из Москвы или из Самары.</p>

<p>SELECT Фамилия, ГородКлиента</p>

<p>    FROM Клиент</p>

<p>    WHERE ГородКлиента="Москва" Or</p>

<p>          ГородКлиента="Самара"</p>

<p>Пример 4.5. Список клиентов из Москвы или из Самары.</p>

<p><strong>Диапазон</strong></p>

<p>Оператор BETWEEN используется для поиска значения внутри некоторого интервала, определяемого своими минимальным и максимальным значениями. При этом указанные значения включаются в <emphasis>условие поиска</emphasis>.</p>

<p><strong>Пример 4.6</strong>. Вывести список товаров, цена которых лежит в диапазоне от 100 до 150 (запрос эквивалентен примеру 4.4).</p>

<p>SELECT Название, Цена</p>

<p>    FROM Товар</p>

<p>    WHERE Цена BETWEEN 100 And 150</p>

<p>Пример 4.6. Список товаров, цена которых лежит в диапазоне от 100 до 150.</p>

<p>При использовании отрицания NOT BETWEEN требуется, чтобы проверяемое значение лежало вне границ заданного <emphasis>диапазона</emphasis>.</p>

<p><strong>Пример 4.7</strong>. Вывести список товаров, цена которых не лежит в диапазоне от 100 до 150.</p>

<p>SELECT Товар.Название, Товар.Цена</p>

<p>    FROM Товар</p>

<p>    WHERE Товар.Цена NOT BETWEEN 100 And 150</p><empty-line /><p>Или (что эквивалентно)</p><empty-line /><p>SELECT Товар.Название, Товар.Цена</p>

<p>   FROM Товар</p>

<p>   WHERE (Товар.Цена&lt;100) OR (Товар.Цена&gt;150)</p>

<p>Пример 4.7. Список товаров, цена которых не лежит в диапазоне от 100 до 150.</p>

<p><strong>Принадлежность множеству</strong></p>

<p>Оператор IN используется для <emphasis>сравнения</emphasis> некоторого значения со списком заданных значений, при этом проверяется, соответствует ли результат вычисления выражения одному из значений в предоставленном списке. При помощи оператора IN может быть достигнут тот же результат, что и в случае применения оператора OR, однако оператор IN выполняется быстрее.</p>

<p><strong>Пример 4.8</strong>. Вывести список клиентов из Москвы или из Самары (запрос эквивалентен примеру 4.5).</p>

<p>SELECT Фамилия, ГородКлиента</p>

<p>   FROM Клиент</p>

<p>   WHERE ГородКлиента IN ("Москва", "Самара")</p>

<p>Пример 4.8. Список клиентов из Москвы или из Самары</p>

<p>NOT IN используется для отбора любых значений, кроме тех, которые указаны в представленном списке.</p>

<p><strong>Пример 4.9</strong>. Вывести список клиентов, проживающих не в Москве и не в Самаре.</p>

<p>SELECT Фамилия, ГородКлиента</p>

<p>    FROM Клиент</p>

<p>    WHERE ГородКлиента</p>

<p>  NOT IN ("Москва","Самара")</p>

<p>Пример 4.9. Список клиентов, проживающих не в Москве и не в Самаре.</p>

<p><strong>Соответствие шаблону</strong></p>

<p>С помощью оператора LIKE можно выполнять <emphasis>сравнение</emphasis> выражения с заданным шаблоном, в котором допускается использование символов-заменителей:</p>

<p>Символ % – вместо этого символа может быть подставлено любое количество произвольных символов.</p>

<p>Символ _ заменяет один символ строки.</p>

<p>[] – вместо символа строки будет подставлен один из возможных символов, указанный в этих ограничителях.</p>

<p>[^] – вместо соответствующего символа строки будут подставлены все символы, кроме указанных в ограничителях.</p>

<p><strong>Пример 4.10</strong>. Найти клиентов, у которых в номере телефона вторая цифра – 4.</p>

<p>SELECT Клиент.Фамилия, Клиент.Телефон</p>

<p>    FROM Клиент</p>

<p>    WHERE Клиент.Телефон LIKE '_4%'</p>

<p>Пример 4.10. Выборка клиентов, у которых в номере телефона вторая цифра – 4.</p>

<p><strong>Пример 4.11</strong>. Найти клиентов, у которых в номере телефона вторая цифра – 2 или 4.</p>

<p>SELECT Клиент.Фамилия, Клиент.Телефон</p>

<p>    FROM Клиент</p>

<p>    WHERE Клиент.Телефон LIKE '_[2,4]%'</p>

<p>Пример 4.11. Выборка клиентов, у которых в номере телефона вторая цифра – 2 или 4.</p>

<p><strong>Пример 4.12</strong>. Найти клиентов, у которых в номере телефона вторая цифра 2, 3 или 4.</p>

<p>SELECT Клиент.Фамилия, Клиент.Телефон</p>

<p>    FROM Клиент</p>

<p>    WHERE Клиент.Телефон LIKE '_[2-4]%'</p>

<p>Пример 4.12. Выборка клиентов, у которых в номере телефона вторая цифра 2, 3 или 4.</p>

<p><strong>Пример 4.13</strong>. Найти клиентов, у которых в фамилии встречается слог "ро".</p>

<p>SELECT Клиент.Фамилия</p>

<p>    FROM Клиент</p>

<p>    WHERE Клиент.Фамилия LIKE "%ро%"</p>

<p>Пример 4.13. Выборка клиентов, у которых в фамилии встречается слог "ро".</p>

<p><strong>Значение NULL</strong></p>

<p>Оператор IS NULL используется для <emphasis>сравнения</emphasis> текущего значения со <emphasis>значением</emphasis> NULL – специальным значением, указывающим на отсутствие любого значения. NULL – это не то же самое, что знак пробела (пробел – допустимый символ) или ноль (0 – допустимое число). NULL отличается и от строки нулевой длины (пустой строки).</p>

<p><strong>Пример 4.14</strong>. Найти сотрудников, у которых нет телефона (поле Телефон не содержит никакого значения).</p>

<p>SELECT Фамилия, Телефон</p>

<p>    FROM Клиент</p>

<p>    WHERE Телефон IS NULL</p>

<p>Пример 4.14. Выборка сотрудников, у которых нет телефона (поле Телефон не содержит никакого значения).</p>

<p>IS NOT NULL используется для проверки присутствия значения в поле.</p>

<p><strong>Пример 4.15</strong>. Выборка клиентов, у которых есть телефон (поле Телефон содержит какое-либо значение).</p>

<p>SELECT Клиент.Фамилия, Клиент.Телефон</p>

<p>    FROM Клиент</p>

<p>    WHERE Клиент.Телефон Is Not Null</p>

<p>Пример 4.15. Найти клиентов, у которых есть телефон (поле Телефон содержит какое-либо значение).</p>

<p><strong>Предложение ORDER BY</strong></p>

<p>В общем случае строки в результирующей таблице SQL-запроса никак не упорядочены. Однако их можно требуемым образом отсортировать, для чего в оператор SELECT помещается фраза ORDER BY, которая сортирует данные выходного набора в заданной последовательности. Сортировка может выполняться по нескольким полям, в этом случае они перечисляются за ключевым словом ORDER BY через запятую. Способ сортировки задается ключевым словом, указываемым в рамках параметра ORDER BY следом за названием поля, по которому выполняется сортировка. По умолчанию реализуется сортировка по возрастанию. Явно она задается ключевым словом ASC. Для выполнения сортировки в обратной последовательности необходимо после имени поля, по которому она выполняется, указать ключевое слово DESC. Фраза ORDER BYпозволяет упорядочить выбранные записи в порядке возрастания или убывания значений любого столбца или комбинации столбцов, независимо от того, присутствуют эти столбцы в таблице результата или нет. Фраза ORDER BY всегда должна быть последним элементом в операторе SELECT.</p>

<p><strong>Пример 4.16</strong>.Вывести список клиентов в алфавитном порядке.</p>

<p>SELECT Клиент.Фамилия, Клиент.Фирма</p>

<p>    FROM Клиент</p>

<p>    ORDER BY Клиент.Фамилия</p>

<p>Пример 4.16. Список клиентов в алфавитном порядке.</p>

<p>Во фразе ORDER BY может быть указано и больше одного элемента. Главный (первый) ключ сортировки определяет общую упорядоченность строк результирующей таблицы. Если во всех строках результирующей таблицы значения главного ключа сортировки являются уникальными, нет необходимости использовать дополнительные ключи сортировки. Однако, если значения главного ключа не уникальны, в результирующей таблице будет присутствовать несколько строк с одним и тем же значением старшего ключа сортировки. В этом случае, возможно, придется упорядочить строки с одним и тем же значением главного ключа по какому-либо дополнительному ключу сортировки.</p>

<p><strong>Пример 4.17</strong>. Вывести список фирм и клиентов. Названия фирм упорядочить в алфавитном порядке, имена клиентов в каждой фирме отсортировать в обратном порядке.</p>

<p>SELECT Клиент.Фирма, Клиент.Фамилия</p>

<p>    FROM Клиент</p>

<p>    ORDER BY Клиент.Фирма, Клиент.Фамилия DESC</p>

<p>Пример 4.17. Список фирм и клиентов. Названия фирм в алфавитном порядке, имена клиентов в каждой фирме в обратном порядке.</p><empty-line /><p>Лекция 5</p><empty-line /><p>Рассмотрим основные <emphasis>операции</emphasis> над отношениями, которые могут представлять интерес с точки зрения извлечения данных из реляционных таблиц. Это <emphasis>объединение</emphasis>, <emphasis>пересечение</emphasis>, <emphasis>разность</emphasis>, расширенное <emphasis>декартово произведение</emphasis> отношений, а также специальные <emphasis>операции</emphasis> над отношениями: <emphasis>выборка</emphasis>, <emphasis>проекция</emphasis> и <emphasis>соединение</emphasis>.</p>

<p>Для иллюстрации <emphasis>теоретико-множественных операций</emphasis> над отношениями введем абстрактные отношения (таблицы) с некоторыми атрибутами (полями).</p><empty-line /><p><strong>Отношение </strong><strong>R</strong></p><empty-line /><p><strong>R.a1</strong></p>

<p><strong>R.a2</strong></p><empty-line /><p>A</p>

<p>1</p><empty-line /><p>A</p>

<p>2</p><empty-line /><p>B</p>

<p>1</p><empty-line /><p>B</p>

<p>3</p><empty-line /><p>B</p>

<p>4</p><empty-line /><p>CREATE TABLE R</p>

<p>(a1 CHAR(1), a2 INT, PRIMARY KEY(a1,a2))</p><empty-line /><p><strong>Отношение </strong><strong>S</strong></p><empty-line /><p><strong>S.b1</strong></p>

<p><strong>S.b2</strong></p><empty-line /><p>1</p>

<p>h</p><empty-line /><p>2</p>

<p>g</p><empty-line /><p>3</p>

<p>h</p><empty-line /><p>CREATE TABLE S</p>

<p>(b1 INT PRIMARY KEY, b2 CHAR(1))</p>

<p><emphasis>Операции</emphasis> <emphasis>выборки</emphasis> и <emphasis>проекции</emphasis> являются унарными, поскольку они работают с одним отношением.</p>

<p><strong>Операция выборки</strong></p>

<p>Операция <strong><emphasis>выборки</emphasis></strong> - построение горизонтального подмножества, т.е. подмножества кортежей, обладающих заданными свойствами.</p>

<p>Операция <emphasis>выборки</emphasis> работает с одним отношением R и определяет результирующее <emphasis>отношение</emphasis>, которое содержит только те кортежи (строки) отношения R, которые удовлетворяют заданному условию F (предикату).</p>

<p><image xlink:href="#_0.jpg" /> или <image xlink:href="#_1.jpg" />.</p>

<p><strong>Пример 5.1</strong>. Операция выборки в <emphasis>SQL</emphasis>.</p>

<p><emphasis>Выборка</emphasis> <image xlink:href="#_2.jpg" /> записывается следующим образом:</p>

<p>SELECT a1, a2</p>

<p>FROM R</p>

<p>WHERE a2=1</p>

<p>5.1. Операция выборки в SQL.</p>

<p><strong>Операция проекции</strong></p>

<p>Операция <strong><emphasis>проекции</emphasis></strong> - построение вертикального подмножества отношения, т.е. подмножества кортежей, получаемого выбором одних и исключением других атрибутов.</p>

<p>Операция <emphasis>проекции</emphasis> работает с одним отношением R и определяет новое <emphasis>отношение</emphasis>, которое содержит вертикальное <emphasis>подмножество</emphasis> отношения R, создаваемое посредством извлечения значений указанных атрибутов и исключения из результата строк-дубликатов.</p>

<p><image xlink:href="#_3.jpg" /></p>

<p><strong>Пример 5.2</strong>. <emphasis>Операция проекции</emphasis> в <emphasis>SQL</emphasis>.</p>

<p><emphasis>Проекция</emphasis> <image xlink:href="#_4.jpg" /> записывается следующим образом:</p>

<p>SELECT DISTINCT b2</p>

<p>FROM S</p>

<p>5.2. Операция проекции в SQL.</p>

<p>К основным операциям над отношениями относится <emphasis>декартово произведение</emphasis>.</p>

<p><strong>Декартово произведение</strong></p>

<p><strong><emphasis>Декартово произведение</emphasis></strong> RxS двух отношений (двух таблиц) определяет новое отношение - результат конкатенации (т.е. сцепления) каждого кортежа (каждой записи) из отношения R с каждым кортежем (каждой записью) из отношения S .</p>

<p>RxS={(a, 1, 1, h), (a, 2, 1, h),</p>

<p>     (b, 1, 1, h), ... }</p>

<p>SELECT R.a1, R.a2, S.b1, S.b2</p>

<p>FROM R, S</p>

<p>5.3. Декартово произведение отношений в SQL.</p>

<p>Результат <emphasis>декартова произведения</emphasis> двух отношений показан в таблице.</p><empty-line /><p>Таблица 5.1.</p><empty-line /><p><strong>R x S</strong></p><empty-line /><p><strong>R.a1</strong></p>

<p><strong>R.a2</strong></p>

<p><strong>S.b1</strong></p>

<p><strong>S.b2</strong></p><empty-line /><p>a</p>

<p>1</p>

<p>1</p>

<p>h</p><empty-line /><p>a</p>

<p>1</p>

<p>2</p>

<p>g</p><empty-line /><p>a</p>

<p>1</p>

<p>3</p>

<p>h</p><empty-line /><p>a</p>

<p>2</p>

<p>1</p>

<p>h</p><empty-line /><p>a</p>

<p>2</p>

<p>2</p>

<p>g</p><empty-line /><p>a</p>

<p>2</p>

<p>3</p>

<p>h</p><empty-line /><p>b</p>

<p>1</p>

<p>1</p>

<p>h</p><empty-line /><p>b</p>

<p>1</p>

<p>2</p>

<p>g</p><empty-line /><p>b</p>

<p>1</p>

<p>3</p>

<p>h</p><empty-line /><p>b</p>

<p>3</p>

<p>1</p>

<p>h</p><empty-line /><p>b</p>

<p>3</p>

<p>2</p>

<p>g</p><empty-line /><p>b</p>

<p>3</p>

<p>3</p>

<p>h</p><empty-line /><p>b</p>

<p>4</p>

<p>1</p>

<p>h</p><empty-line /><p>b</p>

<p>4</p>

<p>2</p>

<p>g</p><empty-line /><p>b</p>

<p>4</p>

<p>3</p>

<p>h</p><empty-line /><p>Если одно <emphasis>отношение</emphasis> имеет N записей и K полей, а другое M записей и L полей, то <emphasis>отношение</emphasis> с их <emphasis>декартовым произведением</emphasis> будет содержать NxM записей и K+L полей. Исходные отношения могут содержать поля с одинаковыми именами, тогда имена полей будут содержать названия таблиц в виде префиксов для обеспечения уникальности имен полей в отношении, полученном как результат выполнения <emphasis>декартова произведения</emphasis>.</p>

<p>Однако в таком виде (пример 5.3.) <emphasis>отношение</emphasis> содержит больше информации, чем обычно необходимо пользователю. Как правило, пользователей интересует лишь некоторая часть всех комбинаций записей в <emphasis>декартовом произведении</emphasis>, удовлетворяющая некоторому условию. Поэтому вместо <emphasis>декартова произведения</emphasis> обычно используется одна из самых важных <emphasis>операций реляционной алгебры</emphasis> - операция <emphasis>соединения</emphasis>, которая является производной от <emphasis>операции</emphasis> <emphasis>декартова произведения</emphasis>. С точки зрения эффективности реализации в реляционных <emphasis>СУБД</emphasis> эта операция - одна из самых трудных и часто входит в число основных причин, вызывающих свойственные всем реляционным системам проблемы с производительностью.</p>

<p><strong>Операция соединения по двум отношениям (таблицам)</strong></p>

<p><strong><emphasis>Соединение</emphasis></strong> - это процесс, когда две или более таблицы объединяются в одну. Способность объединять информацию из нескольких таблиц или запросов в виде одного логического набора данных обусловливает широкие возможности <emphasis>SQL</emphasis>.</p>

<p>В языке <emphasis>SQL</emphasis> для задания типа <emphasis>соединения</emphasis> таблиц в <emphasis>логический</emphasis> набор записей, из которого будет выбираться необходимая <emphasis>информация</emphasis>, используется операция JOIN в предложении FROM.</p>

<p>Формат <emphasis>операции</emphasis>:</p>

<p>FROM имя_таблицы_1 {INNER | LEFT | RIGHT}</p>

<p>    JOIN имя_таблицы_2</p>

<p>ON условие_соединения</p>

<p>Существуют различные типы операций <emphasis>соединения</emphasis>:</p>

<p>тета-соединение <image xlink:href="#_5.jpg" /> ;</p>

<p><emphasis>соединение по эквивалентности</emphasis> <image xlink:href="#_6.jpg" /> ;</p>

<p>естественное соединение <image xlink:href="#_7.jpg" /> ;</p>

<p><emphasis>внешнее соединение</emphasis> <image xlink:href="#_8.jpg" />, <image xlink:href="#_9.jpg" /> ;</p>

<p><emphasis>полусоединение</emphasis> <image xlink:href="#_10.jpg" />.</p>

<p><strong>Операция тета-соединения</strong></p>

<p>Операция тета-соединения <image xlink:href="#_11.jpg" /> определяет отношение, которое содержит кортежи из <emphasis>декартова произведения</emphasis> отношений R и S, удовлетворяющие предикату F. Предикат F имеет вид <image xlink:href="#_12.jpg" />, где вместо <image xlink:href="#_13.jpg" /> может быть указан один из операторов сравнения ( &gt;, &gt;=, &lt;, &lt;=, =, &lt;&gt; ).</p>

<p>Если предикат F содержит только оператор равенства ( = ), то <emphasis>соединение</emphasis> называется <emphasis>соединением по эквивалентности</emphasis>.</p><empty-line /><p>Таблица 5.2.</p><empty-line /><p><strong><image xlink:href="#_14.jpg" /></strong></p><empty-line /><p><strong>R.a1</strong></p>

<p><strong>R.a2</strong></p>

<p><strong>S.b1</strong></p>

<p><strong>S.b2</strong></p><empty-line /><p>a</p>

<p>1</p>

<p>1</p>

<p>h</p><empty-line /><p>a</p>

<p>2</p>

<p>2</p>

<p>g</p><empty-line /><p>b</p>

<p>3</p>

<p>3</p>

<p>h</p><empty-line /><p>b</p>

<p>1</p>

<p>1</p>

<p>h</p><empty-line /><p>Операция тета-соединения в языке SQL называется INNER JOIN (внутреннее <emphasis>соединение</emphasis> ) и используется, когда нужно включить все строки из обеих таблиц, удовлетворяющие условию объединения. Внутреннее <emphasis>соединение</emphasis> имеет место и тогда, когда в предложении WHEREсравниваются значения полей из разных таблиц. В этом случае строится <emphasis>декартово произведение</emphasis> строк первой и второй таблиц, а из полученного набора данных отбираются записи, удовлетворяющие условиям объединения.</p>

<p>В условиях объединения могут участвовать поля, относящиеся к одному и тому же типу данных и содержащие один и тот же вид данных, но они не обязательно должны иметь одинаковые имена.</p>

<p>Блоки данных из двух таблиц объединяются, как только в указанных полях будут найдены совпадающие значения.</p>

<p>Если в предложении FROM перечислено несколько таблиц и при этом не употребляется спецификация JOIN, а для указания соответствия полей из таблиц используется условие в предложении WHERE, то некоторые реляционные СУБД (например, Access) оптимизируют выполнение запроса, интерпретируя его как <emphasis>соединение</emphasis>.</p>

<p>Если перечислять ряд таблиц или запросов и не указывать условия объединения, в качестве исходной таблицы будет выбрано <emphasis>декартово (прямое) произведение</emphasis> всех таблиц.</p>

<p>SELECT R.a1, R.a2, S.b1, S.b2</p>

<p>FROM R, S</p>

<p>WHERE R.a2=S.b1</p><empty-line /><p>    или</p><empty-line /><p>SELECT R.a1, R.a2, S.b1, S.b2</p>

<p>FROM R INNER JOIN S ON  R.a2=S.b1</p>

<p>5.4. Тета-соединение отношений в SQL.</p>

<p><strong>Естественное соединение</strong></p>

<p>Естественным <emphasis>соединением</emphasis> называется <emphasis>соединение по эквивалентности</emphasis> двух отношений R и S, выполненное по всем общим атрибутам, из результатов которого исключается по одному экземпляру каждого общего атрибута.</p><empty-line /><p>Таблица 5.3.</p><empty-line /><p><strong><image xlink:href="#_15.jpg" /></strong></p><empty-line /><p><strong>R.a1</strong></p>

<p><strong>R.a2</strong><strong> или </strong><strong>S.b1</strong></p>

<p><strong>S.b2</strong></p><empty-line /><p>a</p>

<p>1</p>

<p>h</p><empty-line /><p>a</p>

<p>2</p>

<p>g</p><empty-line /><p>b</p>

<p>3</p>

<p>h</p><empty-line /><p>b</p>

<p>1</p>

<p>h</p><empty-line /><p>SELECT R.a1, R.a2, S.b2</p>

<p>FROM R, S</p>

<p>WHERE R.a2=S.b1</p><empty-line /><p>    или</p><empty-line /><p>SELECT R.a1, S.b1, S.b2</p>

<p>FROM R INNER JOIN S ON  R.a2=S.b1</p>

<p>5.5. Естественное соединение отношений в SQL.</p>

<p><strong>Пример 5.6</strong>. Вывести информацию о проданных товарах.</p>

<p>SELECT *</p>

<p>FROM Сделка, Товар</p>

<p>WHERE Сделка.КодТовара=Товар.КодТовара</p><empty-line /><p>    Или (что эквивалентно)</p><empty-line /><p>SELECT *</p>

<p>FROM Товар INNER JOIN Сделка</p>

<p>    ON Товар.КодТовара=Сделка.КодТовара</p>

<p>5.6. Выборка информации о проданных товарах.</p>

<p>Можно создать вложенные объединения, добавив третью таблицу к результату объединения двух других таблиц.</p>

<p><strong>Пример 5.7</strong>. Получить сведения о товарах, дате сделок, количестве проданного товара и покупателях.</p>

<p>SELECT Товар.Название, Сделка.Количество, Сделка.</p>

<p>    Дата, Клиент.Фирма</p>

<p>FROM Клиент INNER JOIN</p>

<p>    (Товар INNER JOIN Сделка</p>

<p>ON Товар.КодТовара=Сделка.КодТовара)</p>

<p>ON Клиент.КодКлиента=Сделка.КодКлиента</p>

<p>5.7. Выборка сведений о товарах, дате сделок, количестве проданного товара и покупателях.</p>

<p>Использование общих имен таблиц для идентификации столбцов неудобно из-за их громоздкости. Каждой таблице можно присвоить какое-нибудь краткое обозначение, псевдоним.</p>

<p><strong>Пример 5.8</strong>. Получить сведения о товарах, дате сделок, количестве проданного товара и покупателях. В запросе используются псевдонимы таблиц.</p>

<p>SELECT Т.Название, С.Количество,</p>

<p>       С.Дата, К.Фирма</p>

<p>FROM Клиент AS К INNER JOIN</p>

<p>    (Товар AS Т INNER JOIN</p>

<p>    Сделка AS С</p>

<p>ON Т.КодТовара=С.КодТовара)</p>

<p>ON К.КодКлиента=С.КодКлиента;</p>

<p>5.8. Выборка сведений о товарах, дате сделок, количестве проданного товара и покупателях с использованием псевдонима.</p>

<p><emphasis>Внешнее соединение</emphasis> похоже на внутреннее, но в результирующий набор данных включаются также записи ведущей таблицы <emphasis>соединения</emphasis>, которые объединяются с пустым множеством записей другой таблицы.</p>

<p>Какая из таблиц будет ведущей, определяет вид <emphasis>соединения</emphasis>. LEFT - левое <emphasis>внешнее соединение</emphasis>, ведущей является таблица, расположенная слева от вида <emphasis>соединения</emphasis> ; RIGHT - правое <emphasis>внешнее соединение</emphasis>, ведущая таблица расположена справа от вида <emphasis>соединения</emphasis>.</p>

<p><strong>Левое внешнее соединение</strong></p>

<p>Левым <emphasis>внешним соединением</emphasis> называется <emphasis>соединение</emphasis>, при котором <emphasis>кортежи отношения</emphasis> R, не имеющие совпадающих значений в общих столбцах отношения S, также включаются в результирующее отношение.</p><empty-line /><p>Таблица 5.4.</p><empty-line /><p><strong><image xlink:href="#_16.jpg" /></strong></p><empty-line /><p><strong>R.a1</strong></p>

<p><strong>R.a2</strong></p>

<p><strong>S.b1</strong></p>

<p><strong>S.b2</strong></p><empty-line /><p>a</p>

<p>1</p>

<p>1</p>

<p>h</p><empty-line /><p>a</p>

<p>2</p>

<p>2</p>

<p>g</p><empty-line /><p>b</p>

<p>1</p>

<p>1</p>

<p>h</p><empty-line /><p>b</p>

<p>3</p>

<p>3</p>

<p>h</p><empty-line /><p>b</p>

<p>4</p>

<p>null</p>

<p>null</p><empty-line /><p>SELECT R.a1,  R.a2, S.b1, S.b2</p>

<p>FROM R LEFT JOIN S ON R.a2=S.b1</p>

<p>5.9. Левое внешнее соединение отношений в SQL.</p>

<p>Существует и правое <emphasis>внешнее соединение</emphasis> <image xlink:href="#_17.jpg" />, называемое так потому, что в результирующем отношении содержатся все кортежи правого отношения. Кроме того, имеется и полное <emphasis>внешнее соединение</emphasis>, в его результирующее отношение помещаются все кортежи из обоих отношений, а для обозначения несовпадающих значений кортежей в нем используются определители NULL.</p>

<p>SELECT R.a1,  R.a2, S.b1, S.b2</p>

<p>FROM R RIGHT JOIN S ON  R.a2=S.b1</p>

<p>5.10. Правое внешнее соединение отношений в SQL.</p>

<p><strong>Пример 5.11</strong>. Вывести информацию о всех товарах. Для проданных товаров будет указана дата сделки и количество. Для непроданных эти поля останутся пустыми.</p>

<p>SELECT Товар.*, Сделка.*</p>

<p>FROM Товар LEFT JOIN Сделка</p>

<p>ON Товар.КодТовара=Сделка.КодТовара;</p>

<p>5.11. Выборка информации о всех товарах.</p>

<p><strong>Полусоединение</strong></p>

<p>Операция <strong><emphasis>полусоединения</emphasis></strong> определяет отношение, содержащее те <emphasis>кортежи отношения</emphasis> R, которые входят в <emphasis>соединение</emphasis> отношений R и S.</p><empty-line /><p>Таблица 5.5.</p><empty-line /><p><strong><image xlink:href="#_18.jpg" /></strong></p><empty-line /><p><strong>R.a1</strong></p>

<p><strong>R.a2</strong></p><empty-line /><p>a</p>

<p>1</p><empty-line /><p>a</p>

<p>2</p><empty-line /><p>b</p>

<p>3</p><empty-line /><p>b</p>

<p>1</p><empty-line /><p>SELECT R.a1, R.a2</p>

<p>FROM R, S</p>

<p>WHERE R.a2=S.b1</p><empty-line /><p>    или</p><empty-line /><p>SELECT R.a1,   R.a2</p>

<p>FROM R INNER JOIN S ON R.a2=S.b1</p>

<p>5.12. Полусоединение отношений в SQL.</p>

<p><strong>Операция объединения</strong></p>

<p><emphasis>Объединение</emphasis> ( UNION ) <image xlink:href="#_19.jpg" /> отношений R и S можно получить в результате их конкатенации с образованием одного отношения с исключением кортежей-дубликатов. При этом отношения R и S должны быть совместимы, т.е. иметь одинаковое количество полей с совпадающими типами данных. Иначе говоря, отношения должны быть совместимы по <emphasis>объединению</emphasis>.</p>

<p>Объединением двух таблиц R и S является таблица, содержащая все строки, которые имеются в первой таблице R, во второй таблице Sили в обеих таблицах сразу.</p>

<p>SELECT R.a1, R.a2</p>

<p>FROM R</p>

<p>UNION</p>

<p>SELECT S.b2, S.b1</p>

<p>FROM S</p>

<p>5.13. Объединение отношений в SQL.</p>

<p><strong>Операция пересечения</strong></p>

<p>Операция <strong><emphasis>пересечения</emphasis></strong> ( INTERSECT ) <image xlink:href="#_20.jpg" /> определяет отношение, которое содержит кортежи, присутствующие как в отношении R, так и в отношении S. Отношения R и S должны быть совместимы по <emphasis>объединению</emphasis> .</p>

<p><emphasis>Пересечением</emphasis> двух таблиц R и S является таблица, содержащая все строки, присутствующие в обеих исходных таблицах одновременно.</p>

<p>SELECT R.a1, R.a2</p>

<p>FROM R,S</p>

<p>WHERE R.a1=S.b1 AND R.a2=S.b2</p><empty-line /><p>   или</p><empty-line /><p>SELECT R.a1, R.a2</p>

<p>FROM R</p>

<p>WHERE R.a1 IN</p>

<p>    (SELECT S.b1 FROM S</p>

<p>     WHERE S.b1=R.a1) AND R.a2 IN</p>

<p>         (SELECT S.b2</p>

<p>          FROM S</p>

<p>          WHERE S.b2=R.a2)</p>

<p>5.14. Пересечение отношений в SQL.</p>

<p><strong>Операция разности</strong></p>

<p><strong><emphasis>Разность</emphasis></strong> ( EXCEPT ) R-S двух отношений R и S состоит из кортежей, которые имеются в отношении R, но отсутствуют в отношении S. Причем отношения R и S должны быть совместимы по <emphasis>объединению</emphasis>.</p>

<p><emphasis>Разностью</emphasis> двух таблиц R и S является <emphasis>таблица</emphasis>, содержащая все строки, которые присутствуют в таблице R, но отсутствуют в таблице S.</p>

<p>SELECT R.a1, R.a2</p>

<p>FROM R</p>

<p>WHERE NOT EXISTS</p>

<p>    (SELECT S.b1,S.b2</p>

<p>     FROM S</p>

<p>     WHERE S.b1=R.a2 AND S.b2=R.a1)</p>

<p>5.15. Разность отношений в SQL.</p>

<p><strong>Операция деления отношений</strong></p>

<p>Результат операции <strong><emphasis>деления</emphasis></strong> R:S - набор <emphasis>кортежей отношения</emphasis> R, определенных на множестве атрибутов C, которые соответствуют комбинации всех <emphasis>кортежей отношения</emphasis> S .</p>

<p>T1=П<sub>C</sub>( R );</p>

<p>T2=П<sub>C</sub>( (S X T1) -R );</p>

<p>T=T1 - T2.</p>

<p><emphasis>Отношение</emphasis> R определено на множестве атрибутов A, а <emphasis>отношение</emphasis> S - на множестве атрибутов B, причем <image xlink:href="#_21.jpg" /> и C=A - B.</p>

<p>Пусть A ={имя, пол, рост, возраст, <emphasis>вес</emphasis>}; B ={имя, пол, возраст}; C ={рост, <emphasis>вес</emphasis>}.</p><empty-line /><p>Таблица 5.6.</p><empty-line /><p><strong>Отношение </strong><strong>R</strong></p><empty-line /><p><strong>имя</strong></p>

<p><strong>пол</strong></p>

<p><strong>рост</strong></p>

<p><strong>возраст</strong></p>

<p><strong>вес</strong></p><empty-line /><p>a</p>

<p>ж</p>

<p>160</p>

<p>20</p>

<p>60</p><empty-line /><p>b</p>

<p>м</p>

<p>180</p>

<p>30</p>

<p>70</p><empty-line /><p>c</p>

<p>ж</p>

<p>150</p>

<p>16</p>

<p>40</p><empty-line /><p><strong>Отношение </strong><strong>S</strong></p><empty-line /><p><strong>имя</strong></p>

<p><strong>пол</strong></p>

<p><strong>возраст</strong></p><empty-line /><p>a</p>

<p>ж</p>

<p>20</p><empty-line /><p><strong>T1=П</strong><strong><sub>C</sub></strong><strong>(R)</strong></p><empty-line /><p><strong>рост</strong></p>

<p><strong>вес</strong></p><empty-line /><p>160</p>

<p>60</p><empty-line /><p>180</p>

<p>70</p><empty-line /><p>150</p>

<p>40</p><empty-line /><p><strong>TT=(S X T1)-R</strong></p><empty-line /><p><strong>имя</strong></p>

<p><strong>пол</strong></p>

<p><strong>возраст</strong></p>

<p><strong>рост</strong></p>

<p><strong>вес</strong></p><empty-line /><p>a</p>

<p>ж</p>

<p>20</p>

<p>180</p>

<p>70</p><empty-line /><p>a</p>

<p>ж</p>

<p>20</p>

<p>150</p>

<p>40</p><empty-line /><p><strong>T2=П</strong><strong><sub>C</sub></strong><strong>((S X T1)-R)</strong></p><empty-line /><p><strong>рост</strong></p>

<p><strong>вес</strong></p><empty-line /><p>180</p>

<p>70</p><empty-line /><p>150</p>

<p>40</p><empty-line /><p><strong>T=T1-T2</strong></p><empty-line /><p><strong>рост</strong></p>

<p><strong>вес</strong></p><empty-line /><p>160</p>

<p>60</p><empty-line /><p><strong>Пример 5.16</strong>. <emphasis>Деление</emphasis> отношений в <emphasis>SQL</emphasis>.</p>

<p>Создание отношения R</p>

<p>CREATE TABLE R</p>

<p>(i     int primary key,</p>

<p>имя    varchar(3),</p>

<p>пол    varchar(3),</p>

<p>рост   int,</p>

<p>возраст int,</p>

<p>вес    int)</p>

<p>5.16a. Деление отношений в SQL.</p>

<p>Создание отношения S</p>

<p>CREATE TABLE S</p>

<p>(i     int primary key,</p>

<p>имя    varchar(3),</p>

<p>пол    varchar(3),</p>

<p>возраст int)</p>

<p>5.16b. Деление отношений в SQL.</p>

<p>Создание отношения T1</p>

<p>CREATE VIEW T1</p>

<p>AS</p>

<p>SELECT рост,вес</p>

<p>FROM R</p>

<p>5.16c. Деление отношений в SQL.</p>

<p>Создание отношения TT</p>

<p>CREATE VIEW TT AS</p>

<p>SELECT S.имя, S.пол, S.возраст,</p>

<p>       T1.рост, T1.вес</p>

<p>FROM S, T1</p>

<p>5.16d. Деление отношений в SQL.</p>

<p>Создание отношения T2</p>

<p>CREATE VIEW T2</p>

<p>AS</p>

<p>SELECT TT.рост, TT.вес</p>

<p>FROM TT</p>

<p>WHERE NOT EXISTS</p>

<p>    (SELECT R.рост, R.вес</p>

<p>     FROM R</p>

<p>     WHERE TT.имя=R.имя AND TT.пол=R.пол</p>

<p>           AND TT.возраст=R.возраст</p>

<p>           AND TT.рост=R.рост</p>

<p>         AND TT.вес=R.вес)</p>

<p>5.16e. Деление отношений в SQL.</p>

<p>Создание отношения T</p>

<p>SELECT T1.рост, T1.вес</p>

<p>FROM T1</p>

<p>WHERE NOT EXISTS</p>

<p>    (SELECT T2.рост,T2.вес</p>

<p>     FROM T2</p>

<p>     WHERE T1.рост=T2.рост AND T1.вес=T2.вес)</p>

<p>5.16f. Деление отношений в SQL.</p><empty-line /><p>Лекция 6</p><empty-line /><p><strong>Построение вычисляемых полей</strong></p>

<p>В общем случае для создания <emphasis>вычисляемого (производного) поля</emphasis> в списке SELECT следует указать некоторое <emphasis>выражение</emphasis> языка <emphasis>SQL</emphasis>. В этих выражениях применяются арифметические <emphasis>операции</emphasis> сложения, вычитания, умножения и деления, а также встроенные функции языка <emphasis>SQL</emphasis>. Можно указать имя любого столбца (поля) таблицы или запроса, но использовать имя столбца только той таблицы или запроса, которые указаны в списке предложения FROM соответствующей инструкции. При построении сложных выражений могут понадобиться скобки.</p>

<p>Стандарты <emphasis>SQL</emphasis> позволяют явным образом задавать имена столбцов результирующей таблицы, для чего применяется фраза AS.</p>

<p><strong>Пример 6.1</strong>. Рассчитать общую <emphasis>стоимость</emphasis> для каждой сделки. Этот <emphasis>запрос</emphasis> использует расчет результирующих столбцов на основе арифметических выражений.</p>

<p>SELECT Товар.Название, Товар.Цена,</p>

<p>    Сделка.Количество,</p>

<p>    Товар.Цена*Сделка.Количество AS Стоимость</p>

<p>FROM Товар INNER JOIN Сделка</p>

<p>    ON Товар.КодТовара=Сделка.КодТовара</p>

<p>6.1. Расчет общей стоимости для каждой сделки.</p>

<p><strong>Пример 6.2</strong>. Получить <emphasis>список</emphasis> фирм с указанием фамилии и инициалов клиентов.</p>

<p>SELECT Фирма, Фамилия+" "+</p>

<p>    Left(Имя,1)+"."+Left(Отчество,1)+"."AS ФИО</p>

<p>FROM Клиент</p>

<p>6.2. Получение списка фирм с указанием фамилии и инициалов клиентов.</p>

<p>В запросе использована <emphasis>встроенная функция</emphasis> Left, позволяющая вырезать в текстовой переменной один символ слева в данном случае.</p>

<p><strong>Пример 6.3</strong>. Получить <emphasis>список</emphasis> товаров с указанием года и месяца продажи.</p>

<p>SELECT Товар.Название, Year(Сделка.Дата)</p>

<p>    AS Год, Month(Сделка.Дата) AS Месяц</p>

<p>FROM Товар INNER JOIN Сделка</p>

<p>    ON Товар.КодТовара=Сделка.КодТовара</p>

<p>6.3. Получение списка товаров с указанием года и месяца продажи.</p>

<p>В запросе использованы встроенные функции Year и Month для выделения года и месяца из даты.</p>

<p><strong>Использование итоговых функций</strong></p>

<p>С помощью <emphasis>итоговых (агрегатных) функций</emphasis> в рамках <emphasis>SQL</emphasis>-запроса можно получить ряд обобщающих статистических сведений о множестве отобранных значений выходного набора.</p>

<p>Пользователю доступны следующие основные <emphasis>итоговые функции</emphasis>:</p>

<p>Count (Выражение) - определяет количество записей в выходном наборе SQL-запроса;</p>

<p>Min/Max (Выражение) - определяют наименьшее и наибольшее из множества значений в некотором поле запроса;</p>

<p>Avg (Выражение) - эта функция позволяет рассчитать среднее значение множества значений, хранящихся в определенном поле отобранных запросом записей. Оно является арифметическим средним значением, т.е. суммой значений, деленной на их количество.</p>

<p>Sum (Выражение) - вычисляет сумму множества значений, содержащихся в определенном поле отобранных запросом записей.</p>

<p>Чаще всего в качестве выражения выступают имена столбцов. <emphasis>Выражение</emphasis> может вычисляться и по значениям нескольких таблиц.</p>

<p>Все эти функции оперируют со значениями в единственном столбце таблицы или с арифметическим выражением и возвращают единственное <emphasis>значение</emphasis>. Функции COUNT, MIN и MAX применимы как к числовым, так и к нечисловым полям, тогда как функции SUM и AVG могут использоваться только в случае числовых полей, за исключением COUNT(*). При вычислении результатов любых функций сначала исключаются все пустые значения, после чего требуемая операция применяется только к оставшимся конкретным значениям столбца. Вариант COUNT(*) - особый случай использования функции COUNT, его назначение состоит в подсчете всех строк в результирующей таблице, независимо от того, содержатся там пустые, дублирующиеся или любые другие значения.</p>

<p>Если до применения обобщающей функции необходимо исключить дублирующиеся значения, следует перед именем столбца в определении функции поместить <emphasis>ключевое слово</emphasis> DISTINCT. Оно не имеет смысла для функций MIN и MAX, однако его использование может повлиять на результаты выполнения функций SUM и AVG, поэтому необходимо заранее обдумать, должно ли оно присутствовать в каждом конкретном случае. Кроме того, <emphasis>ключевое слово</emphasis> DISTINCT может быть указано в любом запросе не более одного раза.</p>

<p>Очень важно отметить, что <emphasis>итоговые функции</emphasis> могут использоваться только в списке предложения SELECT и в составе предложения HAVING. Во всех других случаях это недопустимо. Если <emphasis>список</emphasis> в предложении SELECT содержит <emphasis>итоговые функции</emphasis>, а в тексте запроса отсутствует фраза GROUP BY, обеспечивающая <emphasis>объединение</emphasis> данных в группы, то ни один из элементов списка предложения SELECT не может включать каких-либо ссылок на поля, за исключением ситуации, когда поля выступают в качестве аргументов <emphasis>итоговых функций</emphasis>.</p>

<p><strong>Пример 6.4</strong>. Определить первое по алфавиту название товара.</p>

<p>SELECT Min(Товар.Название) AS Min_Название</p>

<p>FROM Товар</p>

<p>6.4. Определение первого по алфавиту названия товара.</p>

<p><strong>Пример 6.5</strong>. Определить количество сделок.</p>

<p>SELECT Count(*) AS Количество_сделок</p>

<p>FROM Сделка</p>

<p>6.5. Определить количество сделок.</p>

<p><strong>Пример 6.6</strong>. Определить суммарное количество проданного товара.</p>

<p>SELECT Sum(Сделка.Количество)</p>

<p>    AS Количество_товара</p>

<p>FROM Сделка</p>

<p>6.6. Определение суммарного количества проданного товара.</p>

<p><strong>Пример 6.7</strong>. Определить среднюю цену проданного товара.</p>

<p>SELECT Avg(Товар.Цена) AS Avg_Цена</p>

<p>FROM Товар INNER JOIN Сделка</p>

<p>    ON Товар.КодТовара=Сделка.КодТовара;</p>

<p>6.7. Определение средней цены проданного товара.</p>

<p><strong>Пример 6.8</strong>. Подсчитать общую <emphasis>стоимость</emphasis> проданных товаров.</p>

<p>SELECT Sum(Товар.Цена*Сделка.Количество)</p>

<p>    AS Стоимость</p>

<p>FROM Товар INNER JOIN Сделка</p>

<p>ON Товар.КодТовара=Сделка.КодТовара</p>

<p>6.8. Подсчет общей стоимости проданных товаров.</p>

<p><strong>Предложение GROUP BY</strong></p>

<p>Часто в запросах требуется формировать промежуточные итоги, что обычно отображается появлением в запросе фразы "для каждого...". Для этой цели в операторе SELECT используется предложение GROUP BY. <emphasis>Запрос</emphasis>, в котором присутствует GROUP BY, называется группирующим запросом, поскольку в нем группируются данные, полученные в результате выполнения <emphasis>операции</emphasis> SELECT, после чего для каждой отдельной группы создается единственная суммарная строка. Стандарт <emphasis>SQL</emphasis> требует, чтобы предложение SELECT и фраза GROUP BY были тесно связаны между собой. При наличии в операторе SELECT фразы GROUP BY каждый <emphasis>элемент списка</emphasis> в предложении SELECT должен иметь единственное <emphasis>значение</emphasis> для всей группы. Более того, предложение SELECT может включать только следующие типы элементов: имена полей, <emphasis>итоговые функции</emphasis>, <emphasis>константы</emphasis> и выражения, включающие комбинации перечисленных выше элементов.</p>

<p>Все имена полей, приведенные в списке предложения SELECT, должны присутствовать и во фразе GROUP BY - за исключением случаев, когда имя столбца используется в <emphasis>итоговой функции</emphasis>. Обратное правило не является справедливым - во фразе GROUP BY могут быть имена столбцов, отсутствующие в списке предложения SELECT.</p>

<p>Если совместно с GROUP BY используется предложение WHERE, то оно обрабатывается первым, а <emphasis>группированию</emphasis> подвергаются только те строки, которые удовлетворяют условию поиска.</p>

<p>Стандартом <emphasis>SQL</emphasis> определено, что при проведении <emphasis>группирования</emphasis> все отсутствующие значения рассматриваются как равные. Если две строки таблицы в одном и том же группируемом столбце содержат <emphasis>значение</emphasis> NULL и идентичные значения во всех остальных непустых группируемых столбцах, они помещаются в одну и ту же группу.</p>

<p><strong>Пример 6.9</strong>. Вычислить средний объем покупок, совершенных каждым покупателем.</p>

<p>SELECT Клиент.Фамилия, Avg(Сделка.Количество)</p>

<p>    AS Среднее_количество</p>

<p>FROM Клиент INNER JOIN Сделка</p>

<p>    ON Клиент.КодКлиента=Сделка.КодКлиента</p>

<p>GROUP BY Клиент.Фамилия</p>

<p>6.9. Вычисление среднего объема покупок, совершенных каждым покупателем.</p>

<p>Фраза "каждым покупателем" нашла свое отражение в <emphasis>SQL</emphasis>-запросе в виде предложения GROUP BY Клиент.Фамилия.</p>

<p><strong>Пример 6.10</strong>. Определить, на какую сумму был продан <emphasis>товар</emphasis> каждого наименования.</p>

<p>SELECT Товар.Название,</p>

<p>    Sum(Товар.Цена*Сделка.Количество)</p>

<p>    AS Стоимость</p>

<p>FROM Товар INNER JOIN Сделка</p>

<p>    ON Товар.КодТовара=Сделка.КодТовара</p>

<p>GROUP BY Товар.Название</p>

<p>6.10. Определение, на какую сумму был продан товар каждого наименования.</p>

<p><strong>Пример 6.11</strong>. Подсчитать количество сделок, осуществленных каждой фирмой.</p>

<p>SELECT Клиент.Фирма, Count(Сделка.КодСделки)</p>

<p>    AS Количество_сделок</p>

<p>FROM Клиент INNER JOIN Сделка</p>

<p>    ON Клиент.КодКлиента=Сделка.КодКлиента</p>

<p>GROUP BY Клиент.Фирма</p>

<p>6.11. Подсчет количества сделок, осуществленных каждой фирмой.</p>

<p><strong>Пример 6.12</strong>. Подсчитать общее количество купленного для каждой фирмы товара и его <emphasis>стоимость</emphasis>.</p>

<p>SELECT Клиент.Фирма, Sum(Сделка.Количество)</p>

<p>    AS Общее_Количество,</p>

<p>    Sum(Товар.Цена*Сделка.Количество)</p>

<p>    AS Стоимость</p>

<p>FROM Товар INNER JOIN</p>

<p>    (Клиент INNER JOIN Сделка</p>

<p>    ON Клиент.КодКлиента=Сделка.КодКлиента)</p>

<p>    ON Товар.КодТовара=Сделка.КодТовара</p>

<p>GROUP BY Клиент.Фирма</p>

<p>6.12. Подсчет общего количества купленного для каждой фирмы товара и его стоимости.</p>

<p><strong>Пример 6.13</strong>. Определить суммарную <emphasis>стоимость</emphasis> каждого товара за каждый месяц.</p>

<p>SELECT Товар.Название, Month(Сделка.Дата)</p>

<p>    AS Месяц,</p>

<p>    Sum(Товар.Цена*Сделка.Количество)</p>

<p>    AS Стоимость</p>

<p>FROM Товар INNER JOIN Сделка</p>

<p>    ON Товар.КодТовара=Сделка.КодТовара</p>

<p>GROUP BY Товар.Название, Month(Сделка.Дата)</p>

<p>6.13. Определение суммарной стоимости каждого товара за каждый месяц.</p>

<p><strong>Пример 6.14</strong>. Определить суммарную <emphasis>стоимость</emphasis> каждого товара первого сорта за каждый месяц.</p>

<p>SELECT Товар.Название, Month(Сделка.Дата)</p>

<p>    AS Месяц,</p>

<p>    Sum(Товар.Цена*Сделка.Количество)</p>

<p>    AS Стоимость</p>

<p>FROM Товар INNER JOIN Сделка</p>

<p>    ON Товар.КодТовара=Сделка.КодТовара</p>

<p>WHERE Товар.Сорт="Первый"</p>

<p>GROUP BY Товар.Название, Month(Сделка.Дата)</p>

<p>6.14. Определение суммарной стоимости каждого товара первого сорта за каждый месяц.</p>

<p><strong>Предложение HAVING</strong></p>

<p>При помощи HAVING отражаются все предварительно сгруппированные посредством GROUP BY блоки данных, удовлетворяющие заданным в HAVING условиям. Это дополнительная возможность "профильтровать" выходной набор.</p>

<p>Условия в HAVING отличаются от условий в WHERE:</p>

<p>HAVING исключает из результирующего набора данных группы с результатами агрегированных значений;</p>

<p>WHERE исключает из расчета агрегатных значений по группировке записи, не удовлетворяющие условию;</p>

<p>в условии поиска WHERE нельзя задавать агрегатные функции.</p>

<p><strong>Пример 6.15</strong>. Определить фирмы, у которых общее количество сделок превысило три.</p>

<p>SELECT Клиент.Фирма, Count(Сделка.Количество)</p>

<p>    AS Количество_сделок</p>

<p>FROM Клиент INNER JOIN Сделка</p>

<p>    ON Клиент.КодКлиента=Сделка.КодКлиента</p>

<p>GROUP BY Клиент.Фирма</p>

<p>HAVING Count(Сделка.Количество)&gt;3</p>

<p>6.15. Определение фирм, у которых общее количество сделок превысило три.</p>

<p><strong>Пример 6.16</strong>. Вывести <emphasis>список</emphasis> товаров, проданных на сумму более 10000 руб.</p>

<p>SELECT Товар.Название,</p>

<p>    Sum(Товар.Цена*Сделка.Количество)</p>

<p>    AS Стоимость</p>

<p>FROM Товар INNER JOIN Сделка</p>

<p>    ON Товар.КодТовара=Сделка.КодТовара</p>

<p>GROUP BY Товар.Название</p>

<p>HAVING Sum(Товар.Цена*Сделка.Количество)&gt;10000</p>

<p>6.16. Вывод списка товаров, проданных на сумму более 10000 руб.</p>

<p><strong>Пример 6.17</strong>. Вывести <emphasis>список</emphasis> товаров, проданных на сумму более 10000 без указания суммы.</p>

<p>SELECT Товар.Название</p>

<p>FROM Товар INNER JOIN Сделка</p>

<p>    ON Товар.КодТовара=Сделка.КодТовара</p>

<p>GROUP BY Товар.Название</p>

<p>HAVING Sum(Товар.Цена*Сделка.Количество)&gt;10000</p>

<p>6.17. Вывод списка товаров, проданных на сумму более 10000 без указания суммы.</p><empty-line /><p>Лекция 7</p><empty-line /><p><strong>Понятие подзапроса</strong></p>

<p>Часто невозможно решить поставленную задачу путем одного запроса. Это особенно актуально, когда при использовании <emphasis>условия поиска</emphasis> в предложении WHERE <emphasis>значение</emphasis>, с которым надо сравнивать, заранее не определено и должно быть вычислено в момент выполнения оператора SELECT. В таком случае приходят на помощь законченные <emphasis>операторы</emphasis> SELECT, внедренные в тело другого оператора SELECT. Внутренний <emphasis>подзапрос</emphasis> представляет собой также оператор SELECT, а <emphasis>кодирование</emphasis> его предложений подчиняется тем же правилам, что и основного оператора SELECT. Внешний оператор SELECT использует результат выполнения внутреннего оператора для определения содержания окончательного результата всей <emphasis>операции</emphasis>. Внутренние запросы могут быть помещены непосредственно после оператора сравнения ( =, &lt;, &gt;, &lt;=, &gt;=, &lt;&gt; ) в предложения WHERE и HAVING внешнего оператора SELECT – они получают название <emphasis>подзапросов</emphasis> или вложенных запросов. Кроме того, внутренние <emphasis>операторы</emphasis> SELECT могут применяться в операторах INSERT, UPDATE и DELETE.</p>

<p><strong><emphasis>Подзапрос</emphasis></strong> – это инструмент создания временной таблицы, содержимое которой извлекается и обрабатывается внешним оператором. Текст <emphasis>подзапроса</emphasis> должен быть заключен в скобки. К <emphasis>подзапросам</emphasis> применяются следующие правила и ограничения:</p>

<p>фраза ORDER BY не используется, хотя и может присутствовать во внешнем <emphasis>подзапросе</emphasis> ;</p>

<p>список в предложении SELECT состоит из имен отдельных столбцов или составленных из них выражений – за исключением случая, когда в <emphasis>подзапросе</emphasis> присутствует ключевое слово <emphasis>EXISTS</emphasis> ;</p>

<p>по умолчанию имена столбцов в <emphasis>подзапросе</emphasis> относятся к таблице, имя которой указано в предложении FROM. Однако допускается ссылка и на столбцы таблицы, указанной во фразе FROM внешнего запроса, для чего применяются квалифицированные имена столбцов (т.е. с указанием таблицы);</p>

<p>если <emphasis>подзапрос</emphasis> является одним из двух операндов, участвующих в операции сравнения, то запрос должен указываться в правой части этой операции.</p>

<p>Существует два типа <emphasis>подзапросов</emphasis>:</p>

<p><strong>Скалярный</strong> <emphasis>подзапрос</emphasis> возвращает единственное значение. В принципе, он может использоваться везде, где требуется указать единственное значение.</p>

<p><strong>Табличный</strong> <emphasis>подзапрос</emphasis> возвращает множество значений, т.е. значения одного или нескольких столбцов таблицы, размещенные в более чем одной строке. Он возможен везде, где допускается наличие таблицы.</p>

<p><strong>Использование подзапросов, возвращающих единичное значение</strong></p>

<p><strong>Пример 7.1</strong>. Определить дату продажи максимальной партии товара.</p>

<p>SELECT Дата, Количество</p>

<p>FROM Сделка</p>

<p>WHERE Количество=(SELECT Max(Количество) FROM Сделка)</p>

<p>Пример 7.1. Определение даты продажи максимальной партии товара.</p>

<p>Во вложенном <emphasis>подзапросе</emphasis> определяется максимальное количество товара. Во внешнем <emphasis>подзапросе</emphasis> – дата, для которой количество товара оказалось равным максимальному. Необходимо отметить, что нельзя прямо использовать предложение WHERE Количество=Max(Количество), поскольку применять обобщающие функции в предложениях WHERE запрещено. Для достижения желаемого результата следует создать <emphasis>подзапрос</emphasis>, вычисляющий максимальное <emphasis>значение</emphasis> количества, а затем использовать его во внешнем операторе SELECT, предназначенном для выборки дат сделок, где количество товара совпало с максимальным значением.</p>

<p><strong>Пример 7.2</strong>. Определить даты сделок, превысивших по количеству товара среднее <emphasis>значение</emphasis> и указать для этих сделок превышение над средним уровнем.</p>

<p>SELECT Дата, Количество,</p>

<p>Количество-(SELECT Avg(Количество)</p>

<p>        FROM Сделка) AS Превышение</p>

<p>FROM Сделка</p>

<p>WHERE Количество&gt;</p>

<p>    (SELECT Avg(Количество)</p>

<p>        FROM Сделка)</p>

<p>Пример 7.2. Определение даты сделок, превысивших по количеству товара среднее значение и указать для этих сделок превышение над средним уровнем.</p>

<p>В приведенном примере результат <emphasis>подзапроса</emphasis>, представляющий собой среднее <emphasis>значение</emphasis> количества товара по всем сделкам вообще, используется во внешнем операторе SELECT как для вычисления отклонения количества от среднего уровня, так и для отбора сведений о датах.</p>

<p><strong>Пример 7.3</strong>. Определить клиентов, совершивших сделки с максимальным количеством товара.</p>

<p>SELECT Клиент.Фамилия</p>

<p>FROM Клиент INNER JOIN Сделка</p>

<p>ON Клиент.КодКлиента=Сделка.КодКлиента</p>

<p>WHERE  Сделка.Количество=</p>

<p>    (SELECT Max(Сделка.Количество)</p>

<p>    FROM Сделка)</p>

<p>Пример 7.3. Определение клиентов, совершивших сделки с максимальным количеством товара.</p>

<p>Здесь показан пример использования <emphasis>подзапроса</emphasis> при выборке данных из разных таблиц.</p>

<p><strong>Пример 7.4</strong>. Определить клиентов, в сделках которых количество товара отличается от максимального не более чем на 10%.</p>

<p>SELECT Клиент.Фамилия,</p>

<p>    Сделка.Количество</p>

<p>FROM Клиент INNER JOIN Сделка</p>

<p>ON Клиент.КодКлиента=</p>

<p>    Сделка.КодКлиента</p>

<p>WHERE  Сделка.Количество&gt;=0.9*</p>

<p>    (SELECT Max(Сделка.Количество)</p>

<p>    FROM Сделка)</p>

<p>Пример 7.4. Определение клиентов, в сделках которых количество товара отличается от максимального не более чем на 10%.</p>

<p>Покажем, как применяются <emphasis>подзапросы</emphasis> в предложении HAVING.</p>

<p><strong>Пример 7.5</strong>. Определить даты, когда среднее количество проданного за день товара оказалось больше 20 единиц.</p>

<p>SELECT Сделка.Дата, Avg(Сделка.Количество) AS</p>

<p>    Среднее_за_день</p>

<p>FROM Сделка</p>

<p>GROUP BY Сделка.Дата</p>

<p>HAVING Avg(Сделка.Количество)&gt;20</p>

<p>Пример 7.5. Определение даты, когда среднее количество проданного за день товара оказалось больше 20 единиц.</p>

<p>За каждый день определяется среднее количество товара, которое сравнивается с числом 20. Добавим в <emphasis>запрос</emphasis> <emphasis>подзапрос</emphasis>.</p>

<p><strong>Пример 7.6</strong>. Определить даты, когда среднее количество проданного за день товара оказалось больше среднего показателя по всем сделкам вообще.</p>

<p>SELECT Сделка.Дата,</p>

<p>    Avg(Сделка.Количество)</p>

<p>    AS Среднее_за_день</p>

<p>FROM Сделка</p>

<p>GROUP BY Сделка.Дата</p>

<p>HAVING Avg(Сделка.Количество)&gt;</p>

<p>    (SELECT Avg(Сделка.Количество)</p>

<p>        FROM Сделка)</p>

<p>Пример 7.6. Определение даты, когда среднее количество проданного за день товара оказалось больше среднего показателя по всем сделкам вообще.</p>

<p>Внутренний <emphasis>подзапрос</emphasis> определяет средний по всем сделкам показатель, с которым во внешнем запросе сравнивается среднее за каждый день количество товара.</p>

<p><strong>Использование подзапросов, возвращающих множество значений</strong></p>

<p>Во многих случаях <emphasis>значение</emphasis>, подлежащее сравнению в предложениях WHERE или HAVING, представляет собой не одно, а несколько значений. Вложенные <emphasis>подзапросы</emphasis> генерируют непоименованное промежуточное <emphasis>отношение</emphasis>, временную таблицу. Оно может использоваться только в том месте, где появляется в <emphasis>подзапросе</emphasis>. К такому отношению невозможно обратиться по имени из какого-либо другого места запроса. Применяемые к <emphasis>подзапросу</emphasis> <emphasis>операции</emphasis> основаны на тех операциях, которые, в свою <emphasis>очередь</emphasis>, применяются к множеству, а именно:</p>

<p>{ WHERE | HAVING } выражение [ NOT ] <emphasis>IN</emphasis> ( <emphasis>подзапрос</emphasis> );</p>

<p>{ WHERE | HAVING } выражение оператор_сравнения { ALL | SOME | ANY } ( <emphasis>подзапрос</emphasis> );</p>

<p>{WHERE | HAVING } [ NOT ] <emphasis>EXISTS</emphasis> ( <emphasis>подзапрос</emphasis> );</p>

<p><strong>Использование операций IN и NOT IN</strong></p>

<p>Оператор <emphasis>IN</emphasis> используется для сравнения некоторого значения со списком значений, при этом проверяется, входит ли значение в предоставленный список или сравниваемое значение не является элементом представленного списка.</p>

<p><strong>Пример 7.7</strong>. Определить список товаров, которые имеются на складе.</p>

<p>SELECT  Название</p>

<p>FROM  Товар</p>

<p>WHERE КодТовара In</p>

<p>    (SELECT КодТовара FROM Склад)</p>

<p>Пример 7.7. Определение списка товаров, которые имеются на складе.</p>

<p><strong>Пример 7.8</strong>. Определить список отсутствующих на складе товаров.</p>

<p>SELECT  Название</p>

<p>FROM  Товар</p>

<p>WHERE КодТовара Not In (SELECT КодТовара</p>

<p>    FROM Склад)</p>

<p>Пример 7.8. Определение списка отсутствующих на складе товаров.</p>

<p><strong>Пример 7.9</strong>. Определить товары, которые покупают клиенты из Москвы.</p>

<p>SELECT DISTINCT Товар.Название,</p>

<p>    Клиент.ГородКлиента</p>

<p>FROM Товар INNER JOIN</p>

<p>    (Клиент INNER JOIN Сделка</p>

<p>ON Клиент.КодКлиента=Сделка.КодКлиента)</p>

<p>ON Товар.КодТовара=Сделка.КодТовара</p>

<p>WHERE Клиент.ГородКлиента='Москва'</p>

<p>Пример 7.9. Определение товаров, которые покупают клиенты из Москвы.</p>

<p>В результат включаются товары, приобретенные клиентами из Москвы, однако не исключено, что покупателями таких товаров были и клиенты из других городов.</p>

<p>Введение в запрос фразы "только" требует использования операции NOT IN.</p>

<p><strong>Пример 7.10</strong>. Определить товары, покупку которых осуществляют только клиенты из Москвы, и никто другой.</p>

<p>SELECT DISTINCT Товар.Название,</p>

<p>    Клиент.ГородКлиента</p>

<p>FROM Товар INNER JOIN</p>

<p>    (Клиент INNER JOIN Сделка</p>

<p>ON Клиент.КодКлиента=Сделка.КодКлиента)</p>

<p>ON Товар.КодТовара=Сделка.КодТовара</p>

<p>WHERE Товар.Название NOT IN</p>

<p>    (SELECT Товар.Название</p>

<p>    FROM Товар INNER JOIN</p>

<p>       (Клиент INNER JOIN Сделка</p>

<p>    ON Клиент.КодКлиента=Сделка.КодКлиента)</p>

<p>    ON Товар.КодТовара=Сделка.КодТовара</p>

<p>    WHERE Клиент.ГородКлиента&lt;&gt;'Москва')</p>

<p>Пример 7.10. Определение товаров, покупку которых осуществляют только клиенты из Москвы, и никто другой.</p>

<p><strong>Пример 7.11</strong>. Какие товары ни разу не купили московские клиенты?</p>

<p>SELECT DISTINCT Товар.Название,</p>

<p>    Клиент.ГородКлиента</p>

<p>FROM Товар INNER JOIN</p>

<p>    (Клиент INNER JOIN Сделка</p>

<p>    ON Клиент.КодКлиента=Сделка.КодКлиента)</p>

<p>    ON Товар.КодТовара=Сделка.КодТовара</p>

<p>WHERE Товар.Название NOT IN</p>

<p>    (SELECT Товар.Название</p>

<p>FROM Товар INNER JOIN</p>

<p>    (Клиент INNER JOIN Сделка</p>

<p>    ON Клиент.КодКлиента=Сделка.КодКлиента)</p>

<p>    ON Товар.КодТовара=Сделка.КодТовара</p>

<p>WHERE Клиент.ГородКлиента='Москва')</p>

<p>Пример 7.11. Определение товаров, которые ни разу не купили московские клиенты?</p>

<p>Во вложенном запросе определяется список товаров, приобретаемых клиентами из Москвы. Во внешнем запросе выбираются только те товары, которые не входят в этот список.</p>

<p><strong>Пример 7.12</strong>. Определить фирмы, покупающие товары местного производства.</p>

<p>SELECT DISTINCT Клиент.Фирма, Клиент.ГородКлиента,</p>

<p>    Товар.ГородТовара</p>

<p>FROM Товар INNER JOIN</p>

<p>    (Клиент INNER JOIN Сделка</p>

<p>    ON Клиент.КодКлиента=Сделка.КодКлиента)</p>

<p>    ON Товар.КодТовара=Сделка.КодТовара</p>

<p>WHERE Клиент.ГородКлиента=Товар.ГородТовара</p>

<p>Пример 7.12. Определение фирм, покупающих товары местного производства.</p>

<p>В результате выполнения запроса перечисляются сделки, когда клиенту был продан товар, изготовленный в его городе, что совсем не исключает наличие сделок этих же клиентов, связанных с приобретением товара из другого города.</p>

<p>Введем в запрос фразу "только" – сразу потребуется привлечение операции NOT IN.</p>

<p><strong>Пример 7.13</strong>. Определить фирмы, которые покупают только товары, произведенные в своем городе, и никакие другие.</p>

<p>SELECT DISTINCT Клиент.Фирма,</p>

<p>    Клиент.ГородКлиента,</p>

<p>    Товар.ГородТовара</p>

<p>FROM Товар INNER JOIN</p>

<p>    (Клиент INNER JOIN Сделка</p>

<p>    ON Клиент.КодКлиента=Сделка.КодКлиента)</p>

<p>    ON Товар.КодТовара=Сделка.КодТовара</p>

<p>WHERE Клиент.ГородКлиента NOT IN</p>

<p>    (SELECT DISTINCT  Клиент.ГородКлиента</p>

<p>    FROM Товар INNER JOIN</p>

<p>    (Клиент INNER JOIN Сделка</p>

<p>    ON Клиент.КодКлиента=Сделка.КодКлиента)</p>

<p>    ON Товар.КодТовара=Сделка.КодТовара</p>

<p>    WHERE Клиент.ГородКлиента&lt;&gt;</p>

<p>       Товар.ГородТовара)</p>

<p>Пример 7.13. Определение фирм, которые покупают только товары, произведенные в своем городе, и никакие другие.</p>

<p>Во вложенном запросе определяется множество фирм, совершивших хотя бы одну покупку товара из чужого города. Затем определяются фирмы, не входящие в это множество.</p>

<p><strong>Использование ключевых слов ANY и ALL</strong></p>

<p>Ключевые слова ANY и ALL могут использоваться с <emphasis>подзапросами</emphasis>, возвращающими один столбец чисел.</p>

<p>Если <emphasis>подзапросу</emphasis> будет предшествовать ключевое слово ALL, условие сравнения считается выполненным, только когда оно выполняется для всех значений в результирующем столбце <emphasis>подзапроса</emphasis>.</p>

<p>Если записи <emphasis>подзапроса</emphasis> предшествует ключевое слово ANY, то условие сравнения считается выполненным, когда оно выполняется хотя бы для одного из значений в результирующем столбце <emphasis>подзапроса</emphasis>.</p>

<p>Если в результате выполнения <emphasis>подзапроса</emphasis> получено пустое значение, то для ключевого слова ALL условие сравнения будет считаться выполненным, а для ключевого слова ANY – невыполненным. Ключевое слово SOME является синонимом слова ANY.</p>

<p><strong>Пример 7.14</strong>. Определить клиентов, совершивших сделки с максимальным количеством товара (эквивалентно запросу 7.3.)</p>

<p>SELECT Клиент.Фамилия, Сделка.Количество</p>

<p>FROM Клиент INNER JOIN Сделка</p>

<p>    ON Клиент.КодКлиента=Сделка.КодКлиента</p>

<p>WHERE Сделка.Количество&gt;=ALL(SELECT Количество</p>

<p>    FROM Сделка)</p>

<p>Пример 7.14. Определение клиентов, совершивших сделки с максимальным количеством товара.</p>

<p>В примере определены клиенты, в сделках которых количество товара больше или равно количеству товара в каждой из всех сделок.</p>

<p><strong>Пример 7.15</strong>. Найти фирму, купившую товаров на сумму, превышающую 10000 руб.</p>

<p>SELECT Клиент.Фирма,</p>

<p>    Sum(Товар.Цена*Сделка.Количество)</p>

<p>    AS Общ_стоимость</p>

<p>FROM Товар INNER JOIN</p>

<p>    (Клиент INNER JOIN Сделка</p>

<p>    ON Клиент.КодКлиента=Сделка.КодКлиента)</p>

<p>    ON Товар.КодТовара=Сделка.КодТовара</p>

<p>GROUP BY Клиент.Фирма</p>

<p>HAVING Sum(Товар.Цена*Сделка.Количество)&gt;10000</p>

<p>Пример 7.15. Определение фирмы, купившей товаров на сумму, превышающую 10000 руб.</p>

<p>Добавим в запрос <emphasis>подзапрос</emphasis>.</p>

<p><strong>Пример 7.16</strong>. Найти фирму, которая приобрела товаров на самую большую сумму.</p>

<p>SELECT Клиент.Фирма,</p>

<p>    Sum(Товар.Цена*Сделка.Количество)</p>

<p>    AS Общ_стоимость</p>

<p>FROM Товар INNER JOIN</p>

<p>    (Клиент INNER JOIN Сделка</p>

<p>    ON Клиент.КодКлиента=Сделка.КодКлиента)</p>

<p>    ON Товар.КодТовара=Сделка.КодТовара</p>

<p>GROUP BY Клиент.Фирма</p>

<p>HAVING Sum(Товар.Цена*Сделка.Количество)&gt;=</p>

<p>ALL(SELECT Sum(Товар.Цена*Сделка.Количество)</p>

<p>    FROM Товар INNER JOIN Сделка</p>

<p>    ON Товар.КодТовара=Сделка.КодТовара</p>

<p>GROUP BY Сделка.КодКлиента)</p>

<p>Пример 7.16. Определение фирмы, которая приобрела товаров на самую большую сумму.</p>

<p>Вложенный <emphasis>подзапрос</emphasis> подсчитывает общую стоимость покупок каждого клиента. Внешний <emphasis>подзапрос</emphasis> также подсчитывает общую стоимость покупок каждого клиента и определяет тех, для кого эта сумма, по сравнению с другими покупателями, оказалась больше или точно такой же.</p>

<p><strong>Пример 7.17</strong>. Найти фирмы, в сделках которых количество товара превышает такой же показатель хотя бы в одной сделке клиентов из Самары.</p>

<p>SELECT Клиент.Фирма, Сделка.Количество</p>

<p>FROM Клиент INNER JOIN Сделка</p>

<p>    ON Клиент.КодКлиента=Сделка.КодКлиента</p>

<p>WHERE Сделка.Количество&gt;</p>

<p>ANY(SELECT Сделка.Количество</p>

<p>    FROM Клиент INNER JOIN Сделка</p>

<p>    ON Клиент.КодКлиента=Сделка.КодКлиента</p>

<p>WHERE Клиент.ГородКлиента='Самара')</p>

<p>Пример 7.17. Определение фирм, в сделках которых количество товара превышает такой же показатель хотя бы в одной сделке клиентов из Самары.</p>

<p><strong>Использование операций EXISTS и NOT EXISTS</strong></p>

<p>Ключевые слова <emphasis>EXISTS</emphasis> и NOT EXISTS предназначены для использования только совместно с <emphasis>подзапросами</emphasis>. Результат их обработки представляет собой логическое значение TRUE или FALSE. Для ключевого слова <emphasis>EXISTS</emphasis> результат равен TRUE в том и только в том случае, если в возвращаемой <emphasis>подзапросом</emphasis> результирующей таблице присутствует хотя бы одна строка. Если результирующая таблица <emphasis>подзапроса</emphasis> пуста, результатом обработки операции <emphasis>EXISTS</emphasis> будет значение FALSE. Для ключевого слова NOT EXISTS используются правила обработки, обратные по отношению к ключевому слову <emphasis>EXISTS</emphasis> . Поскольку по ключевым словам <emphasis>EXISTS</emphasis> и NOT EXISTSпроверяется лишь наличие строк в результирующей таблице <emphasis>подзапроса</emphasis>, то эта таблица может содержать произвольное количество столбцов.</p>

<p><strong>Пример 7.18</strong>. Определить список имеющихся на складе товаров (запрос эквивалентен примеру 7.7).</p>

<p>SELECT Название</p>

<p>FROM Товар</p>

<p>WHERE EXISTS (SELECT КодТовара</p>

<p>    FROM Склад</p>

<p>WHERE Товар.КодТовара=Склад.КодТовара)</p>

<p>Пример 7.18. Определение списка имеющихся на складе товаров.</p>

<p><strong>Пример 7.19</strong>. Определить список отсутствующих на складе товаров (запрос эквивалентен примеру 7.8).</p>

<p>SELECT Название</p>

<p>FROM Товар</p>

<p>WHERE NOT EXISTS (SELECT КодТовара</p>

<p>    FROM Склад</p>

<p>WHERE Товар.КодТовара=Склад.КодТовара)</p>

<p>Пример 7.19. Определение списка отсутствующих на складе товаров.</p><empty-line /><p>Лекция 8</p>

<p>Язык <emphasis>SQL</emphasis> ориентирован на выполнение операций над группами записей, хотя в некоторых случаях их можно проводить и над отдельной записью.</p>

<p><emphasis>Запросы действия</emphasis> представляют собой достаточно мощное средство, так как позволяют оперировать не только отдельными строками, но и набором строк. С помощью <emphasis>запросов действия</emphasis> <emphasis>пользователь</emphasis> может добавить, удалить или обновить блоки данных. Существует три вида <emphasis>запросов действия</emphasis>:</p>

<p>INSERT INTO – <emphasis>запрос добавления</emphasis> ;</p>

<p>DELETE – <emphasis>запрос удаления</emphasis> ;</p>

<p>UPDATE – <emphasis>запрос обновления</emphasis>.</p>

<p><strong>Запрос добавления</strong></p>

<p>Оператор INSERT применяется для <emphasis>добавления записей</emphasis> в таблицу. Формат оператора:</p>

<p>&lt;оператор_вставки&gt;::=INSERT INTO &lt;имя_таблицы&gt;</p>

<p>    [(имя_столбца [,...n])]</p>

<p>    {VALUES (значение[,...n])|</p>

<p>    &lt;SELECT_оператор&gt;}</p>

<p>Здесь параметр имя_таблицы представляет собой либо <emphasis>имя таблицы</emphasis> <emphasis>базы данных</emphasis>, либо имя обновляемого представления.</p>

<p>Первая форма оператора INSERT с параметром VALUES предназначена для вставки единственной строки в указанную таблицу. <emphasis>Список</emphasis>столбцов указывает столбцы, которым будут присвоены значения в добавляемых записях. <emphasis>Список</emphasis> может быть опущен, тогда подразумеваются все столбцы таблицы (кроме объявленных как <emphasis>счетчик</emphasis>), причем в определенном порядке, установленном при создании таблицы. Если в операторе INSERT указывается конкретный <emphasis>список</emphasis> имен полей, то любые пропущенные в нем столбцы должны быть объявлены при создании таблицы как допускающие <emphasis>значение</emphasis> NULL, за исключением тех случаев, когда при описании столбца использовался <emphasis>параметр</emphasis> DEFAULT. <emphasis>Список</emphasis> значений должен следующим образом соответствовать списку столбцов:</p>

<p>количество элементов в обоих списках должно быть одинаковым;</p>

<p>должно существовать прямое соответствие между позицией одного и того же элемента в обоих списках, поэтому первый элемент списка значений должен относиться к первому столбцу в списке столбцов, второй – ко второму столбцу и т.д.</p>

<p>типы данных элементов в списке значений должны быть совместимы с типами данных соответствующих столбцов таблицы.</p>

<p><strong>Пример 8.1</strong>. Добавить в таблицу ТОВАР новую <emphasis>запись</emphasis>.</p>

<p>INSERT INTO Товар (Название, Тип, Цена)</p>

<p>    VALUES(" Славянский ", " шоколад ", 12)</p>

<p>Пример 8.1. Добавление в таблицу ТОВАР новой записи.</p>

<p>Если столбцы таблицы ТОВАР указаны в полном составе и в том порядке, в котором они перечислены при создании таблицы ТОВАР, оператор можно упростить.</p>

<p>INSERT INTO Товар VALUES (" Славянский ",</p>

<p>    " шоколад ", 12)</p>

<p>Вторая форма оператора INSERT с параметром SELECT позволяет скопировать множество строк из одной таблицы в другую. Предложение SELECT может представлять собой любой допустимый оператор SELECT. Вставляемые в указанную таблицу строки в точности должны соответствовать строкам результирующей таблицы, созданной при выполнении вложенного запроса. Все ограничения, указанные выше для первой формы оператора INSERT, применимы и в этом случае.</p>

<p>Поскольку оператор SELECT в общем случае возвращает множество записей, то оператор INSERT в такой форме приводит к <emphasis>добавлению</emphasis> в таблицу аналогичного числа новых записей.</p>

<p><strong>Пример 8.2</strong>. Добавить в итоговую таблицу сведения об общей сумме ежемесячных продаж каждого наименования товара.</p>

<p>INSERT INTO Итог</p>

<p>   (Название, Месяц, Стоимость )</p>

<p>SELECT Товар.Название, Month(Сделка.Дата)</p>

<p>   AS Месяц, Sum(Товар.Цена*Сделка.Количество)</p>

<p>   AS Стоимость</p>

<p>FROM Товар INNER JOIN Сделка</p>

<p>   ON Товар.КодТовара= Сделка.КодТовара</p>

<p>GROUP BY Товар.Название, Month(Сделка.Дата)</p>

<p>Пример 8.2. Добавление в итоговую таблицу сведений об общей сумме ежемесячных продаж каждого наименования товара.</p>

<p><strong>Запрос удаления</strong></p>

<p>Оператор DELETE предназначен для <emphasis>удаления группы записей</emphasis> из таблицы.</p>

<p>Формат оператора:</p>

<p>&lt;оператор_удаления&gt; ::=DELETE</p>

<p>    FROM &lt;имя_таблицы&gt;[WHERE &lt;условие_отбора&gt;]</p>

<p>Здесь <emphasis>параметр</emphasis> имя_таблицы представляет собой либо <emphasis>имя таблицы</emphasis> <emphasis>базы данных</emphasis>, либо имя обновляемого представления.</p>

<p>Если предложение WHERE присутствует, удаляются записи из таблицы, удовлетворяющие условию отбора. Если опустить предложение WHERE, из таблицы будут <emphasis>удалены все записи</emphasis>, однако сама <emphasis>таблица</emphasis> сохранится.</p>

<p><strong>Пример 8.3</strong>. Удалить все прошлогодние сделки.</p>

<p>DELETE</p>

<p>FROM Сделка</p>

<p>WHERE Year(Сделка.Дата)=Year(GETDATE())-1</p>

<p>Пример 8.3. Удаление всех прошлогодних сделок.</p>

<p>В приведенном примере условие отбора формируется с учетом года (<emphasis>функция</emphasis> Year ) от текущей даты (<emphasis>функция</emphasis> GETDATE() ).</p>

<p><strong>Запрос обновления</strong></p>

<p>Оператор UPDATE применяется для <emphasis>изменения</emphasis> значений в группе записей или в одной записи указанной таблицы.</p>

<p>Формат оператора:</p>

<p>&lt;оператор_изменения&gt; ::=</p>

<p>    UPDATE имя_таблицы SET имя_столбца=</p>

<p>        &lt;выражение&gt;[,...n]</p>

<p>    [WHERE &lt;условие_отбора&gt;]</p>

<p><emphasis>Параметр</emphasis> имя_таблицы – это либо <emphasis>имя таблицы</emphasis> <emphasis>базы данных</emphasis>, либо имя обновляемого представления. В предложении SET указываются имена одного и более столбцов, данные в которых необходимо изменить. Предложение WHERE является необязательным. Если оно опущено, значения указанных столбцов будут изменены во всех строках таблицы. Если предложение WHERE присутствует, то обновлены будут только те строки, которые удовлетворяют условию отбора. <emphasis>Выражение</emphasis> представляет собой новое <emphasis>значение</emphasis> соответствующего столбца и должно быть совместимо с ним по типу данных.</p>

<p><strong>Пример 8.4</strong>. Для товаров первого сорта установить цену в <emphasis>значение</emphasis> 140 и <emphasis>остаток</emphasis> – в <emphasis>значение</emphasis> 20 единиц.</p>

<p>UPDATE Товар SET Товар.Цена=140, Товар.Остаток=20</p>

<p>WHERE Товар.Сорт=" Первый "</p>

<p>Пример 8.4. Обновление выбранных записей.</p>

<p><strong>Пример 8.5</strong>. Увеличить цену товаров первого сорта на 25%.</p>

<p>UPDATE Товар SET Товар.Цена=Товар.Цена*1.25</p>

<p>WHERE Товар.Сорт=" Первый "</p>

<p>Пример 8.5. Обновление выбранных записей.</p>

<p><strong>Пример 8.6</strong>. В сделке с максимальным количеством товара увеличить число товаров на 10%.</p>

<p>UPDATE Сделка SET Сделка.Количество=</p>

<p>    Сделка.Количество*1.1</p>

<p>WHERE Сделка.Количество=</p>

<p>    (SELECT Max(Сделка.Количество) FROM Сделка)</p>

<p>Пример 8.6. Обновление выбранных записей.</p>

<p><strong>Введение в понятие "целостность данных"</strong></p>

<p>Выполнение операторов модификации данных в таблицах <emphasis>базы данных</emphasis> INSERT, DELETE и UPDATE может привести к нарушению <emphasis>целостности данных</emphasis> и их корректности, т.е. к потере их достоверности и непротиворечивости.</p>

<p>Чтобы <emphasis>информация</emphasis>, хранящаяся в базе данных, была однозначной и непротиворечивой, в реляционной модели устанавливаются некоторые ограничительные условия – правила, определяющие возможные значения данных и обеспечивающие логическую основу для поддержания корректных значений. <emphasis>Ограничения целостности</emphasis> позволяют свести к минимуму ошибки, возникающие при обновлении и обработке данных.</p>

<p>В базе данных, построенной на реляционной модели, задается ряд правил целостности, которые, по сути, являются ограничениями для всех допустимых состояний <emphasis>базы данных</emphasis> и гарантируют <emphasis>корректность</emphasis> данных. Рассмотрим следующие <emphasis>типы ограничений</emphasis>   <emphasis>целостности данных</emphasis>:</p>

<p>обязательные данные;</p>

<p>ограничения для доменов полей;</p>

<p>корпоративные ограничения;</p>

<p><emphasis>целостность сущностей;</emphasis></p>

<p><emphasis>ссылочная целостность</emphasis>.</p>

<p><strong>Обязательные данные</strong></p>

<p>Некоторые поля всегда должны содержать одно из допустимых значений, другими словами, эти поля не могут иметь пустого значения.</p>

<p><strong>Ограничения для доменов полей</strong></p>

<p>Каждое поле имеет свой домен, представляющий собой набор его допустимых значений.</p>

<p><strong>Корпоративные ограничения целостности</strong></p>

<p>Существует понятие "корпоративные <emphasis>ограничения целостности</emphasis> " как дополнительные правила поддержки <emphasis>целостности данных</emphasis>, определяемые пользователями, принятые на предприятии или администраторами баз данных. Ограничения предприятия называются бизнес-правилами.</p>

<p><strong>Целостность сущностей</strong></p>

<p>Это <emphasis>ограничение целостности</emphasis> касается <emphasis>первичных ключей</emphasis> базовых таблиц. По определению, <strong><emphasis>первичный ключ</emphasis></strong> – минимальный идентификатор (одно или несколько полей), который используется для уникальной идентификации записей в таблице. Таким образом, никакое подмножество <emphasis>первичного ключа</emphasis> не может быть достаточным для уникальной идентификации записей.</p>

<p><emphasis>Целостность сущностей</emphasis> определяет, что в базовой таблице ни одно поле <emphasis>первичного ключа</emphasis> не может содержать отсутствующих значений, обозначенных NULL.</p>

<p>Если допустить присутствие определителя NULL в любой части <emphasis>первичного ключа</emphasis>, это равносильно утверждению, что не все его поля необходимы для уникальной идентификации записей, и противоречит определению <emphasis>первичного ключа</emphasis>.</p>

<p><strong>Ссылочная целостность</strong></p>

<p>Указанное <emphasis>ограничение целостности</emphasis> касается <emphasis>внешних ключей</emphasis>. <strong><emphasis>Внешний ключ</emphasis></strong> – это поле (или множество полей) одной таблицы, являющееся ключом другой (или той же самой) таблицы. <emphasis>Внешние ключи</emphasis> используются для установления логических связей между таблицами. Связь устанавливается путем присвоения значений <emphasis>внешнего ключа</emphasis> одной таблицы значениям ключа другой.</p>

<p>Между двумя или более таблицами базы данных могут существовать <emphasis>отношения подчиненности</emphasis>, которые определяют, что для каждой записи <emphasis>главной таблицы</emphasis> (называемой еще <strong><emphasis>родительской</emphasis></strong> ) может существовать одна или несколько записей в <emphasis>подчиненной таблице</emphasis> (называемой также <strong><emphasis>дочерней</emphasis></strong> ).</p>

<p>Существует три разновидности связи между таблицами базы данных:</p>

<p>"один-ко-многим";</p>

<p>"один-к-одному";</p>

<p>"многие-ко-многим".</p>

<p>Отношение "один-ко-многим" имеет место, когда одной записи <emphasis>родительской таблицы</emphasis> может соответствовать несколько записей <emphasis>дочерней</emphasis>. Связь "один-ко-многим" иногда называют связью "многие-к-одному". И в том, и в другом случае сущность связи между таблицами остается неизменной.</p>

<p>Связь "один-ко-многим" наиболее распространена для реляционных баз данных. Она позволяет моделировать также иерархические структуры данных.</p>

<p>Отношение "один-к-одному" имеет место, когда одной записи в <emphasis>родительской таблице</emphasis> соответствует одна запись в <emphasis>дочерней</emphasis>. Это отношение встречается намного реже, чем отношение "один-ко-многим". Его используют, если не хотят, чтобы таблица БД "распухала" от второстепенной информации. Использование связи "один-к-одному" приводит к тому, что для чтения связанной информации в нескольких таблицах приходится производить несколько операций чтения вместо одной, когда данные хранятся в одной таблице.</p>

<p>Отношение "многие-ко-многим" имеет место в следующих случаях:</p>

<p>одной записи в <emphasis>родительской таблице</emphasis> соответствует более одной записи в <emphasis>дочерней таблице</emphasis> ;</p>

<p>одной записи в <emphasis>дочерней таблице</emphasis> соответствует более одной записи в <emphasis>родительской таблице</emphasis>.</p>

<p>Считается, что всякая связь "многие-ко-многим" может быть заменена на связь "один-ко-многим" (одну или несколько).</p>

<p>Часто связь между таблицами устанавливается по <emphasis>первичному ключу</emphasis>, т.е. значениям <emphasis>внешнего ключа</emphasis> одной таблицы присваиваются значения <emphasis>первичного ключа</emphasis> другой. Однако это не является обязательным – в общем случае связь может устанавливаться и с помощью вторичных ключей. Кроме того, при установлении связей между таблицами не требуется непременная уникальность ключа, обеспечивающего установление связи. Поля <emphasis>внешнего ключа</emphasis> не обязаны иметь те же имена, что и имена ключей, которым они соответствуют. <emphasis>Внешний ключ</emphasis>может ссылаться на свою собственную таблицу – в таком случае <emphasis>внешний ключ</emphasis> называется рекурсивным.</p>

<p><emphasis>Ссылочная целостность</emphasis> определяет: если в таблице существует <emphasis>внешний ключ</emphasis>, то его значение должно либо соответствовать значению <emphasis>первичного ключа</emphasis> некоторой записи в базовой таблице, либо задаваться определителем NULL.</p>

<p>Существует несколько важных моментов, связанных с <emphasis>внешними ключами</emphasis>. Во-первых, следует проанализировать, допустимо ли использование во <emphasis>внешних ключах</emphasis> пустых значений. В общем случае, если участие <emphasis>дочерней таблицы</emphasis> в связи является обязательным, то рекомендуется запрещать применение пустых значений в соответствующем <emphasis>внешнем ключе</emphasis>. В то же время, если имеет место частичное участие <emphasis>дочерней таблицы</emphasis> в связи, то помещение пустых значений в поле <emphasis>внешнего ключа</emphasis> должно быть разрешено. Например, если в операции фиксации сделок некоторой торговой фирмы необходимо указать покупателя, то поле КодКлиента должно иметь атрибут NOT NULL. Если допускается продажа или покупка товара без указания клиента, то для поля КодКлиента можно указать атрибут NULL.</p>

<p>Следующая проблема связана с организацией <emphasis>поддержки ссылочной целостности</emphasis> при выполнении операций модификации данных в базе. Здесь возможны следующие ситуации:</p>

<p>Вставка новой строки в <emphasis>дочернюю таблицу</emphasis>. Для обеспечения <emphasis>ссылочной целостности</emphasis> необходимо убедиться, что значение <emphasis>внешнего ключа</emphasis>новой строки <emphasis>дочерней таблицы</emphasis> равно пустому значению либо некоторому конкретному значению, присутствующему в поле <emphasis>первичного ключа</emphasis> одной из строк <emphasis>родительской таблицы</emphasis>.</p>

<p>Удаление строки из <emphasis>дочерней таблицы</emphasis>. Никаких нарушений <emphasis>ссылочной целостности</emphasis> не происходит.</p>

<p>Обновление <emphasis>внешнего ключа</emphasis> в строке <emphasis>дочерней таблицы</emphasis>. Этот случай подобен описанной выше первой ситуации. Для сохранения <emphasis>ссылочной целостности</emphasis> необходимо убедиться, что значение <emphasis>внешнего ключа</emphasis> в обновленной строке <emphasis>дочерней таблицы</emphasis> равно пустому значению либо некоторому конкретному значению, присутствующему в поле <emphasis>первичного ключа</emphasis> одной из строк <emphasis>родительской таблицы</emphasis>.</p>

<p>Вставка строки в <emphasis>родительскую таблицу</emphasis>. Такая вставка не может вызвать нарушения <emphasis>ссылочной целостности</emphasis>. Добавленная строка просто становится родительским объектом, не имеющим дочерних объектов.</p>

<p>Удаление строки из <emphasis>родительской таблицы</emphasis>. <emphasis>Ссылочная целостность</emphasis> окажется нарушенной, если в <emphasis>дочерней таблице</emphasis> будут существовать строки, ссылающиеся на удаленную строку <emphasis>родительской таблицы</emphasis>. В этом случае может использоваться одна из следующих стратегий:</p><empty-line /><p>NO ACTION. Удаление строки из <emphasis>родительской таблицы</emphasis> запрещается, если в <emphasis>дочерней таблице</emphasis> существует хотя бы одна ссылающаяся на нее строка.</p>

<p>CASCADE. При <emphasis>удалении</emphasis> строки из <emphasis>родительской таблицы</emphasis> автоматически удаляются все ссылающиеся на нее строки <emphasis>дочерней таблицы</emphasis>. Если любая из удаляемых строк <emphasis>дочерней таблицы</emphasis> выступает в качестве родительской стороны в какой-либо другой связи, то операция <emphasis>удаления</emphasis> применяется ко всем строкам <emphasis>дочерней таблицы</emphasis> этой связи и т.д. Другими словами, <emphasis>удаление</emphasis> строки <emphasis>родительской таблицы</emphasis> автоматически распространяется на любые <emphasis>дочерние таблицы</emphasis>.</p>

<p>SET NULL. При удалении строки из <emphasis>родительской таблицы</emphasis> во всех ссылающихся на нее строках дочернего отношения в поле <emphasis>внешнего ключа</emphasis>, соответствующего <emphasis>первичному ключу</emphasis> удаленной строки, записывается пустое значение. Следовательно, удаление строк из <emphasis>родительской таблицы</emphasis> вызовет занесение пустого значения в соответствующее поле <emphasis>дочерней таблицы</emphasis>. Эта стратегия может использоваться, только когда в поле <emphasis>внешнего ключа</emphasis>   <emphasis>дочерней таблицы</emphasis> разрешается помещать пустые значения.</p>

<p>SET DEFAULT. При удалении строки из <emphasis>родительской таблицы</emphasis> в поле <emphasis>внешнего ключа</emphasis> всех ссылающихся на нее строк <emphasis>дочерней таблицы</emphasis> автоматически помещается значение, указанное для этого поля как значение по умолчанию. Таким образом, удаление строки из <emphasis>родительской таблицы</emphasis> вызывает помещение принимаемого по умолчанию значения в поле <emphasis>внешнего ключа</emphasis> всех строк <emphasis>дочерней таблицы</emphasis>, ссылающихся на удаленную строку. Эта стратегия применима лишь в тех случаях, когда полю <emphasis>внешнего ключа</emphasis>   <emphasis>дочерней таблицы</emphasis> назначено некоторое значение, принимаемое по умолчанию.</p>

<p>NO CHECK. При удалении строки из <emphasis>родительской таблицы</emphasis> никаких действий по сохранению <emphasis>ссылочной целостности</emphasis> данных не предпринимается.</p><empty-line /><p>Обновление <emphasis>первичного ключа</emphasis> в строке <emphasis>родительской таблицы</emphasis>. Если значение <emphasis>первичного ключа</emphasis> некоторой строки <emphasis>родительской таблицы</emphasis>будет обновлено, нарушение <emphasis>ссылочной целостности</emphasis> случится при том условии, что в дочернем отношении существуют строки, ссылающиеся на исходное значение <emphasis>первичного ключа</emphasis>. Для сохранения <emphasis>ссылочной целостности</emphasis> может применяться любая из описанных выше стратегий. При использовании стратегии CASCADE   <emphasis>обновление</emphasis> значения <emphasis>первичного ключа</emphasis> в строке <emphasis>родительской таблицы</emphasis> будет отображено в любой строке <emphasis>дочерней таблицы</emphasis>, ссылающейся на данную строку.</p>

<p>Существует и другой вид целостности – <emphasis>смысловая (семантическая) целостность</emphasis> базы данных. Требование <strong><emphasis>смысловой целостности</emphasis></strong>определяет, что данные в базе данных должны изменяться таким образом, чтобы не нарушалась сложившаяся между ними смысловая связь.</p>

<p>Уровень поддержания <emphasis>целостности данных</emphasis> в разных системах существенно варьируется.</p>

<p>Идеология архитектуры клиент-сервер требует переноса максимально возможного числа правил <emphasis>целостности данных</emphasis> на сервер. К преимуществам такого подхода относятся:</p>

<p>гарантия целостности базы данных, поскольку все правила сосредоточены в одном месте (в базе данных);</p>

<p>автоматическое применение определенных на сервере <emphasis>ограничений целостности</emphasis> для любых приложений;</p>

<p>отсутствие различных реализаций ограничений в разных клиентских приложениях, работающих с базой данных;</p>

<p>быстрое срабатывание ограничений, поскольку они реализованы на сервере и, следовательно, нет необходимости посылать данные клиенту, увеличивая при этом сетевой трафик;</p>

<p>доступность внесенных в ограничения на сервере изменений для всех клиентских приложений, работающих с базой данных, и отсутствие необходимости повторного распространения измененных приложений клиентов среди пользователей.</p>

<p>К недостаткам хранения <emphasis>ограничений целостности</emphasis> на сервере можно отнести:</p>

<p>отсутствие у клиентского приложения возможности реагировать на некоторые ошибочные ситуации, возникающие на сервере при реализации тех или иных правил (например, ошибок при выполнении хранимых процедур на сервере);</p>

<p>ограниченность возможностей языка SQL и языка хранимых процедур и триггеров для реализации всех возникающих потребностей определения <emphasis>целостности данных</emphasis>.</p>

<p>На практике в клиентских приложениях реализуют лишь такие правила, которые тяжело или невозможно реализовать с применением средств сервера. Все остальные <emphasis>ограничения целостности</emphasis> данных переносятся на сервер.</p><empty-line /><p>Лекция 9</p><empty-line /><p><strong>Таблицы с ограничениями в стандарте языка</strong></p>

<p>При создании баз данных большое внимание должно быть уделено средствам поддержания данных в <emphasis>целостном состоянии</emphasis>. Рассмотрим предусмотренные стандартом языка <emphasis>SQL</emphasis> функции, которые предназначены для поддержания <emphasis>целостности данных</emphasis>. Эта <emphasis>поддержка</emphasis> включает средства задания ограничений, они вводятся с целью защиты <emphasis>базы данных</emphasis> от нарушения согласованности сохраняемых в ней данных. К таким типам поддержки <emphasis>целостности данных</emphasis> относятся:</p>

<p>обязательные данные;</p>

<p>ограничения для доменов полей;</p>

<p><emphasis>целостность сущностей</emphasis>;</p>

<p><emphasis>ссылочная целостность</emphasis> ;</p>

<p>требования конкретного предприятия.</p>

<p>Большая часть перечисленных ограничений задается в операторах CREATE TABLE и ALTER TABLE.</p>

<p><strong>Создание таблицы</strong></p>

<p>В стандарте SQL дано несколько вариантов определения оператора <emphasis>создания таблицы</emphasis>, однако его базовый формат имеет следующий вид:</p>

<p>&lt;определение_таблицы&gt; ::=</p>

<p>CREATE TABLE имя_таблицы</p>

<p>{(имя_столбца тип_данных [ NOT NULL ][ UNIQUE]</p>

<p>[DEFAULT &lt;значение&gt;]</p>

<p>[ CHECK (&lt;условие_выбора&gt;)][,...n]}</p>

<p>[CONSTRAINT имя_ограничения]</p>

<p>[PRIMARY KEY (имя_столбца [,...n])</p>

<p>{[UNIQUE (имя_столбца [,...n])}</p>

<p>[FOREIGN KEY (имя_столбца_внешнего_ключа</p>

<p>    [,...n])</p>

<p>REFERENCES имя_род_таблицы</p>

<p>    [(имя_столбца_род_таблицы [,...n])],</p>

<p>[MATCH {PARTIAL | FULL}]</p>

<p>[ON UPDATE {CASCADE| SET NULL |SET DEFAULT</p>

<p>    |NO ACTION}]</p>

<p>[ON DELETE {CASCADE| SET NULL |SET DEFAULT</p>

<p>         |NO ACTION}]</p>

<p>{[CHECK(&lt;условие_выбора&gt;)][,...n]})</p>

<p><strong>Ограничения</strong></p>

<p>Представленная версия оператора <emphasis>создания таблицы</emphasis> включает средства определения требований <emphasis>целостности данных</emphasis>, а также другие конструкции. Имеются очень большие вариации в наборе функциональных возможностей этого оператора, реализованных в различных диалектах языка SQL. Рассмотрим назначение параметров команды, используемых для поддержания <emphasis>целостности данных</emphasis>.</p>

<p><strong>Обязательные данные</strong></p>

<p>Для некоторых столбцов требуется наличие в каждой строке таблицы конкретного и допустимого значения, отличного от опущенного значения или значения NULL. Для заданий ограничений подобного типа стандарт SQL предусматривает использование спецификации NOT NULL.</p>

<p><strong>Требования конкретного предприятия</strong></p>

<p>Обновления данных в таблицах могут быть ограничены существующими в организации требованиями (бизнес-правилами). Стандарт SQL позволяет реализовать бизнес-правила предприятий с помощью предложения CHECK и ключевого слова UNIQUE.</p>

<p><strong>Ограничения для доменов полей</strong></p>

<p>Каждый столбец имеет собственный домен - некоторый набор допустимых значений. Стандарт SQL предусматривает два различных механизма определения доменов. Первый состоит в использовании предложения CHECK, позволяющего задать требуемые ограничения для столбца или таблицы в целом, а второй предполагает применение оператора CREATE DOMAIN.</p>

<p><strong>Целостность сущностей</strong></p>

<p><emphasis>Первичный ключ</emphasis> таблицы должен иметь уникальное непустое значение в каждой строке. Стандарт SQL позволяет задавать подобные требования поддержки <emphasis>целостности данных</emphasis> с помощью фразы PRIMARY KEY. В пределах таблицы она может указываться только один раз. Однако существует возможность гарантировать уникальность значений и для любых <emphasis>альтернативных ключей</emphasis> таблицы, что обеспечивает ключевое слово UNIQUE. Кроме того, при определении <emphasis>альтернативных ключей</emphasis> рекомендуется использовать и спецификаторы NOT NULL.</p>

<p><strong>Ссылочная целостность</strong></p>

<p><strong><emphasis>Внешние ключи</emphasis></strong> представляют собой столбцы или наборы столбцов, предназначенные для связывания каждой из строк дочерней таблицы, содержащей этот <emphasis>внешний ключ</emphasis>, со строкой родительской таблицы, содержащей соответствующее значение <emphasis>потенциального ключа</emphasis>. Стандарт SQL предусматривает механизм определения <emphasis>внешних ключей</emphasis> с помощью предложения FOREIGN KEY, а фраза REFERENCES определяет имя родительской таблицы, т.е. таблицы, где находится соответствующий потенциальный ключ. При использовании этого предложения система отклонит выполнение любых операторов INSERT или UPDATE, с помощью которых будет предпринята попытка создать в дочерней таблице значение <emphasis>внешнего ключа</emphasis>, не соответствующее одному из уже существующих значений <emphasis>потенциального ключа</emphasis> родительской таблицы. Когда действия системы выполняются при поступлении операторов UPDATE и DELETE, содержащих попытку обновить или удалить значение <emphasis>потенциального ключа</emphasis> в родительской таблице, которому соответствует одна или более строк дочерней таблицы, то они зависят от <emphasis>правил</emphasis>поддержки <emphasis>ссылочной целостности</emphasis>, указанных во фразах ON UPDATE и ON DELETE предложения FOREIGN KEY. Если пользователь предпринимает попытку удалить из родительской таблицы строку, на которую ссылается одна или более строк дочерней таблицы, язык SQL предоставляет следующие возможности:</p>

<p>CASCADE - выполняется удаление строки из родительской таблицы, сопровождающееся автоматическим удалением всех ссылающихся на нее строк дочерней таблицы;</p>

<p><emphasis>SET NULL</emphasis> - выполняется удаление строки из родительской таблицы, а во <emphasis>внешние ключи</emphasis> всех ссылающихся на нее строк дочерней таблицы записывается значение NULL ;</p>

<p><emphasis>SET DEFAULT</emphasis> - выполняется удаление строки из родительской таблицы, а во <emphasis>внешние ключи</emphasis> всех ссылающихся на нее строк дочерней таблицы заносится значение, принимаемое по умолчанию;</p>

<p>NO ACTION - операция удаления строки из родительской таблицы отменяется. Именно это значение используется по умолчанию в тех случаях, когда в описании <emphasis>внешнего ключа</emphasis> фраза ON DELETE опущена.</p>

<p>Те же самые <emphasis>правила</emphasis> применяются в языке SQL и тогда, когда значение <emphasis>потенциального ключа</emphasis> родительской таблицы обновляется.</p>

<p>Определитель MATCH позволяет уточнить способ обработки значения NULL во <emphasis>внешнем ключе</emphasis>.</p>

<p>При определении таблицы предложение FOREIGN KEY может указываться произвольное количество раз.</p>

<p>В операторе CREATE TABLE используется необязательная фраза DEFAULT, которая предназначена для задания принимаемого по умолчанию значения, когда в операторе INSERT значение в данном столбце будет отсутствовать.</p>

<p>Фраза CONSTRAINT позволяет задать имя ограничению, что позволит впоследствии отменить то или иное ограничение с помощью оператора ALTER TABLE.</p>

<p><strong>Изменение и удаление таблицы</strong></p>

<p>Для внесения изменений в уже созданные таблицы стандартом SQL предусмотрен оператор ALTER TABLE, предназначенный для выполнения следующих действий:</p>

<p>добавление в таблицу нового столбца;</p>

<p>удаление столбца из таблицы;</p>

<p>добавление в определение таблицы нового ограничения;</p>

<p>удаление из определения таблицы существующего ограничения;</p>

<p>задание для столбца значения по умолчанию;</p>

<p>отмена для столбца значения по умолчанию.</p>

<p>Оператор <emphasis>изменения таблицы</emphasis> имеет следующий обобщенный формат:</p>

<p>&lt;изменение_таблицы&gt; ::=</p>

<p>ALTER TABLE имя_таблицы</p>

<p>[ADD [COLUMN]имя_столбца тип_данных</p>

<p>        [ NOT NULL ][UNIQUE]</p>

<p>[DEFAULT &lt;значение&gt;][ CHECK (&lt;условие_выбора&gt;)]]</p>

<p>[DROP [COLUMN] имя_столбца [RESTRICT | CASCADE ]]</p>

<p>[ADD [CONSTRAINT [имя_ограничения]]</p>

<p>[{PRIMARY KEY (имя_столбца [,...n])</p>

<p>    |[UNIQUE (имя_столбца [,...n])}</p>

<p>|[FOREIGN KEY (имя_столбца_внешнего_ключа [,...n])</p>

<p>    REFERENCES имя_род_таблицы</p>

<p>       [(имя_столбца_род_таблицы [,...n])],</p>

<p>[ MATCH {PARTIAL | FULL}</p>

<p>    [ON UPDATE {CASCADE| SET NULL |</p>

<p>        SET DEFAULT | NO ACTION}]</p>

<p>    [ON DELETE {CASCADE| SET NULL |</p>

<p>        SET DEFAULT | NO ACTION}]</p>

<p>    |[CHECK(&lt;условие_выбора&gt;)][,...n]}]</p>

<p>[DROP CONSTRAINT имя_ограничения</p>

<p>     [RESTRICT | CASCADE]]</p>

<p>[ALTER [COLUMN] SET DEFAULT &lt;значение&gt;]</p>

<p>[ALTER [COLUMN] DROP DEFAULT]</p>

<p>Здесь параметры имеют то же самое назначение, что и в определении оператора CREATE TABLE.</p>

<p>Оператор ALTER TABLE реализован не во всех диалектах языка SQL. В некоторых диалектах он поддерживается, однако не позволяет удалять из таблицы уже существующие столбцы.</p>

<p>Для <emphasis>удаления таблицы</emphasis> используется команда DROP TABLE.</p>

<p><strong>Таблицы в среде MS SQL Server</strong></p>

<p><strong>Создание таблицы</strong></p>

<p>В процессе проектирования базы данных принимается решение о том, какие таблицы должны входить в базу данных, какие у них будут имена (идентификаторы), какие типы данных потребуются для построения таблиц и какие пользователи получат доступ к каждой из них. Кроме того, для эффективного <emphasis>создания таблиц</emphasis> необходимо ответить на следующие вопросы:</p>

<p>Столбцы какого типа и размера будут составлять каждую из таблиц, какие требуется выбрать имена для столбцов таблиц?</p>

<p>Какие столбцы могут содержать значение NULL?</p>

<p>Будут ли использованы <emphasis>ограничения целостности</emphasis>, значения по умолчанию и <emphasis>правила</emphasis> для столбцов?</p>

<p>Необходимо ли индексирование столбцов, какие типы индексов будут применены для конкретных столбцов?</p>

<p>Какие столбцы будут входить в <emphasis>первичные</emphasis> и <emphasis>внешние ключи</emphasis>.</p>

<p>Для <emphasis>создания таблиц</emphasis> в среде MS SQL Server используется команда:</p>

<p>&lt;определение_таблицы&gt; ::=</p>

<p>CREATE TABLE [ имя_базы_данных.[владелец].</p>

<p>             | владелец. ]имя_таблицы</p>

<p>             (&lt;элемент_таблицы&gt;[,...n])</p>

<p>где</p>

<p>&lt;элемент_таблицы&gt; ::=</p>

<p>{&lt;определение_столбца&gt;}</p>

<p>| &lt;имя_столбца&gt; AS &lt;выражение&gt;</p>

<p>| &lt;ограничение_таблицы&gt;</p>

<p>Обычно владельцем таблицы (dbo) является тот, кто ее создал.</p>

<p>&lt;Выражение&gt; задает значение для <emphasis>вычисляемого столбца</emphasis>. <strong><emphasis>Вычисляемые столбцы</emphasis></strong> - это виртуальные столбцы, т. е. физически в таблице они не хранятся и вычисляются с использованием значений столбцов той же таблицы. В выражении для <emphasis>вычисляемого столбца</emphasis> могут присутствовать имена обычных столбцов, константы и функции, связанные одним или несколькими операторами. Подзапросы в таком выражении участвовать не могут. <emphasis>Вычисляемые столбцы</emphasis> могут быть включены в раздел SELECT при указании списка столбцов, которые должны быть возвращены в результате выполнения запроса. <emphasis>Вычисляемые столбцы</emphasis> не могут входить во <emphasis>внешний ключ</emphasis>, для них не используются значения по умолчанию. Кроме того, <emphasis>вычисляемые столбцы</emphasis> не могут участвовать в операциях INSERT и DELETE.</p>

<p>&lt;определение_столбца&gt; ::=</p>

<p>{ имя_столбца &lt;тип_данных&gt;}</p>

<p>[ [ DEFAULT &lt;выражение&gt; ]</p>

<p>| [ IDENTITY (начало, шаг) [NOT FOR REPLICATION]]]]</p>

<p>[ROWGUIDCOL][&lt;ограничение_столбца&gt;][...n]]</p>

<p>В определении столбца обратим внимание на параметр IDENTITY, который указывает, что соответствующий столбец будет <emphasis>столбцом-счетчиком</emphasis>. Для таблицы может быть определен только один столбец с таким свойством. Можно дополнительно указать начальное значение и шаг приращения. Если эти значения не указываются, то по умолчанию они оба равны 1. Если с ключевым словом IDENTITY указано NOT FOR REPLICATION, то сервер не будет выполнять автоматического генерирования значений для этого столбца, а разрешит вставку в столбец произвольных значений.</p>

<p>В качестве ограничений используются <emphasis>ограничения столбца</emphasis> и <emphasis>ограничения таблицы</emphasis>. Различие между ними в том, что <strong><emphasis>ограничение столбца</emphasis></strong>применяется только к определенному полю, а <strong><emphasis>ограничение таблицы</emphasis></strong> - к группам из одного или более полей.</p>

<p>&lt;ограничение_столбца&gt;::=</p>

<p>[ CONSTRAINT имя_ограничения ]</p>

<p>{ [ NULL | NOT NULL ]</p>

<p>| [ {PRIMARY KEY | UNIQUE }</p>

<p>[ CLUSTERED | NONCLUSTERED ]</p>

<p>[ WITH FILLFACTOR=фактор_заполнения ]</p>

<p>[ ON {имя_группы_файлов | DEFAULT } ] ] ]</p>

<p>| [ [ FOREIGN KEY ]</p>

<p>REFERENCES имя_род_таблицы</p>

<p>    [(имя_столбца_род_таблицы) ]</p>

<p>[ ON DELETE { CASCADE | NO ACTION } ]</p>

<p>[ ON UPDATE { CASCADE | NO ACTION } ]</p>

<p>[ NOT FOR REPLICATION ]]</p>

<p>| CHECK [ NOT FOR REPLICATION](&lt;лог_выражение&gt;) }</p><empty-line /><p>&lt;ограничение_таблицы&gt;::=</p>

<p>[CONSTRAINT имя_ограничения ]</p>

<p>{ [ {PRIMARY KEY | UNIQUE }</p>

<p>    [ CLUSTERED | NONCLUSTERED ]</p>

<p>{(имя_столбца [ASC | DESC][,...n])}</p>

<p>[WITH FILLFACTOR=фактор_заполнения ]</p>

<p>[ON {имя_группы_файлов | DEFAULT } ]]</p>

<p>|FOREIGN KEY[(имя_столбца [,...n])]</p>

<p>REFERENCES имя_род_таблицы</p>

<p>    [(имя_столбца_род_таблицы [,...n])]</p>

<p>[ ON DELETE { CASCADE | NO ACTION } ]</p>

<p>[ ON UPDATE { CASCADE | NO ACTION } ]</p>

<p>| NOT  FOR REPLICATION ]</p>

<p>| CHECK [ NOT FOR REPLICATION ] (лог_выражение) }</p>

<p>Рассмотрим отдельные параметры представленных конструкций, связанные с ограничениями <emphasis>целостности данных</emphasis>. <emphasis>Ограничения целостности</emphasis>имеют приоритет над триггерами, <emphasis>правилами</emphasis> и значениями по умолчанию. К <strong><emphasis>ограничениям целостности</emphasis></strong> относятся <emphasis>ограничение первичного ключа</emphasis> PRIMARY KEY, <emphasis>ограничение внешнего ключа</emphasis> FOREIGN KEY, ограничение уникальности UNIQUE, ограничение значения NULL, ограничение на проверку CHECK .</p>

<p><strong>Ограничение первичного ключа (PRIMARY KEY)</strong></p>

<p>Таблица обычно имеет столбец или комбинацию столбцов, значения которых уникально идентифицируют каждую строку в таблице. Этот столбец (или столбцы) называется <strong><emphasis>первичным ключом</emphasis></strong> таблицы и нужен для обеспечения ее целостности. Если в <emphasis>первичный ключ</emphasis> входит более одного столбца, то значения в пределах одного столбца могут дублироваться, но любая комбинация значений всех столбцов <emphasis>первичного ключа</emphasis> должна быть уникальна.</p>

<p>При создании <emphasis>первичного ключа</emphasis> SQL Server автоматически создает уникальный индекс для столбцов, входящих в <emphasis>первичный ключ</emphasis>. Он ускоряет доступ к данным этих столбцов при использовании <emphasis>первичного ключа</emphasis> в запросах.</p>

<p>Таблица может иметь только одно ограничение PRIMARY KEY, причем ни один из включенных в <emphasis>первичный ключ</emphasis> столбцов не может принимать значение NULL. При попытке использовать в качестве <emphasis>первичного ключа</emphasis> столбец (или группу столбцов), для которого <emphasis>ограничения первичного ключа</emphasis> не выполняются, <emphasis>первичный ключ</emphasis> создан не будет, а система выдаст сообщение об ошибке.</p>

<p>Поскольку ограничение PRIMARY KEY гарантирует уникальность данных, оно часто определяется для <emphasis>столбцов-счетчиков</emphasis>. Создание <emphasis>ограничения целостности</emphasis> PRIMARY KEY возможно как при создании, так и при <emphasis>изменении таблицы</emphasis>. Одним из назначений <emphasis>первичного ключа</emphasis>является обеспечение <emphasis>ссылочной целостности</emphasis> данных нескольких таблиц. Естественно, это может быть реализовано только при определении соответствующих <emphasis>внешних ключей</emphasis> в других таблицах.</p>

<p><strong>Ограничение внешнего ключа (FOREIGN KEY)</strong></p>

<p><strong><emphasis>Ограничение внешнего ключа</emphasis></strong> - это основной механизм для поддержания <emphasis>ссылочной целостности</emphasis> между таблицами реляционной базы данных. Столбец дочерней таблицы, определенный в качестве <emphasis>внешнего ключа</emphasis> в параметре FOREIGN KEY, применяется для ссылки на столбец родительской таблицы, являющийся в ней <emphasis>первичным ключом</emphasis>. Имя родительской таблицы и столбцы ее <emphasis>первичного ключа</emphasis>указываются в предложении REFERENCES. Данные в столбцах, определенных в качестве <emphasis>внешнего ключа</emphasis>, могут принимать только такие же значения, какие находятся в связанных с ним столбцах <emphasis>первичного ключа</emphasis> родительской таблицы. Совпадение имен столбцов для связи дочерней и родительской таблиц необязательно. <emphasis>Первичный ключ</emphasis> может быть определен для столбца с одним именем, в то время как столбец, на который наложено ограничение FOREIGN KEY, может иметь совершенно другое имя. Единственным требованием остается соответствие столбцов по типу и размеру данных.</p>

<p>На <emphasis>первичный ключ</emphasis> могут ссылаться не только столбцы других таблиц, но и столбцы, расположенные в той же таблице, что и собственно <emphasis>первичный ключ</emphasis> ; это позволяет создавать рекурсивные структуры.</p>

<p><emphasis>Внешний ключ</emphasis> может быть связан не только с <emphasis>первичным ключом</emphasis> другой таблицы. Он может быть определен и для столбцов с ограничением UNIQUE второй таблицы или любых других столбцов, но таблицы должны находиться в одной базе данных.</p>

<p>Столбцы <emphasis>внешнего ключа</emphasis> могут содержать значение NULL, однако проверка на ограничение FOREIGN KEY игнорируется. <emphasis>Внешний ключ</emphasis>может быть проиндексирован, тогда сервер будет быстрее отыскивать нужные данные. <emphasis>Внешний ключ</emphasis> определяется как при создании, так и при <emphasis>изменении таблиц</emphasis>.</p>

<p>Ограничение <emphasis>ссылочной целостности</emphasis> задает требование, согласно которому для каждой записи в дочерней таблице должна иметься запись в родительской таблице. При этом изменение значения столбца связи в записи родительской таблицы при наличии дочерней записи блокируется, равно как и удаление родительской записи (запрет каскадного изменения и удаления), что гарантируется параметрами ON DELETE NO ACTIONи ON UPDATE NO ACTION, принятыми по умолчанию. Для разрешения каскадного воздействия следует использовать параметры ON DELETE CASCADE и ON UPDATE CASCADE.</p>

<p><strong>Ограничение уникального ключа (UNIQUE)</strong></p>

<p>Это ограничение задает требование уникальности значения поля (столбца) или группы полей (столбцов), входящих в <emphasis>уникальный ключ</emphasis>, по отношению к другим записям. Ограничение UNIQUE для столбца таблицы похоже на <emphasis>первичный ключ</emphasis>: для каждой строки данных в нем должны содержаться уникальные значения. Установив для некоторого столбца <emphasis>ограничение первичного ключа</emphasis>, можно одновременно установить для другого столбца ограничение UNIQUE. Отличие в <emphasis>ограничении первичного</emphasis> и <emphasis>уникального ключа</emphasis> заключается в том, что <emphasis>первичный ключ</emphasis> служит как для упорядочения данных в таблице, так и для соединения связанных между собой таблиц. Кроме того, при использовании ограничения UNIQUE допускается существование значения NULL, но лишь единственный раз.</p>

<p><strong>Ограничение на значение (NOT NULL)</strong></p>

<p>Для каждого столбца таблицы можно установить ограничение NOT NULL, запрещающее ввод в этот столбец нулевого значения.</p>

<p><strong>Ограничение проверочное (CHECK) и правила</strong></p>

<p>Данное ограничение используется для проверки допустимости данных, вводимых в конкретный столбец таблицы, т.е. ограничение CHECKобеспечивает еще один уровень защиты данных.</p>

<p><emphasis>Ограничения целостности</emphasis> CHECK задают диапазон возможных значений для столбца или столбцов. В основе <emphasis>ограничений целостности</emphasis> CHECKлежит использование логических выражений.</p>

<p>Допускается применение нескольких ограничений CHECK к одному и тому же столбцу. В этом случае они будут применимы в той последовательности, в которой происходило их создание. Возможно применение одного и того же ограничения к разным столбцам и использование в логических выражениях значений других столбцов. Указание параметра NOT FOR REPLICATION предписывает не выполнять проверочных действий, если они выполняются подсистемой репликации.</p>

<p><emphasis>Проверочные ограничения</emphasis> могут быть реализованы и с помощью <emphasis>правил</emphasis>. <strong><emphasis>Правило</emphasis></strong> представляет собой самостоятельный объект базы данных, который связывается со столбцом таблицы или пользовательским типом данных. Причем одно и то же <emphasis>правило</emphasis> может быть одновременно связано с несколькими столбцами и пользовательскими типами данных, что является неоспоримым преимуществом. Однако существенный недостаток заключается в том, что с каждым столбцом или типом данных может быть связано только одно <emphasis>правило</emphasis>. Разрешается комбинирование <emphasis>ограничений целостности</emphasis> CHECK с <emphasis>правилами</emphasis>. В этом случае выполняется проверка соответствия вводимого значения как <emphasis>ограничениям целостности</emphasis>, так и <emphasis>правилам</emphasis>.</p>

<p><emphasis>Правило</emphasis> может быть создано командой:</p>

<p>CREATE RULE имя_правила AS выражение</p>

<p>Чтобы связать <emphasis>правило</emphasis> с тем или иным столбцом какой-либо таблицы, необходимо использовать системную хранимую процедуру:</p>

<p>sp_bindrule [@rulename=] 'rule'</p>

<p>[@objname=] 'object_name'</p>

<p>[,[@futureonly=['futureonly_flag']</p>

<p>Чтобы отменить <emphasis>правила</emphasis>, следует выполнить следующую процедуру:</p>

<p>sp_unbindrule [@objname=] 'object_name'</p>

<p>[,[@futureonly=['futureonly_flag']</p>

<p>Удаление <emphasis>правила</emphasis> производится командой</p>

<p>DROP RULE {имя_правила} [,...n].</p>

<p><strong>Ограничение по умолчанию (DEFAULT)</strong></p>

<p>Столбцу может быть присвоено значение по умолчанию. Оно будет актуальным в том случае, если пользователь не введет в столбец никакого иного значения.</p>

<p>Отдельно необходимо отметить пользу от использования значений по умолчанию при добавлении нового столбца в таблицу. Если для добавляемого столбца не разрешено хранение значений NULL и не определено значение по умолчанию, то операция добавления столбца закончится неудачей.</p>

<p>При определении в таблице столбца с параметром ROWGUIDCOL сервер автоматически определяет для него значение по умолчанию в виде функции NEWID(). Таким образом, для каждой новой строки будет автоматически генерироваться глобальный уникальный идентификатор.</p>

<p>Дополнительным механизмом использования значений по умолчанию являются объекты базы данных, созданные командой:</p>

<p>CREATE DEFAULT имя_умолчания AS константа</p>

<p>Умолчание связывается с тем или иным столбцом какой-либо таблицы с помощью процедуры:</p>

<p>sp_bindefault [@defname=] 'default',</p>

<p>[@objname=]  'object_name'</p>

<p>[,[@futureonly=] 'futureonly_flag'],</p>

<p>где</p>

<p>'object_name'</p>

<p>может быть представлен как</p>

<p>'имя_таблицы.имя_столбца'</p>

<p>Удаление <emphasis>ограничения по умолчанию</emphasis> выполняется командой</p>

<p>DROP DEFAULT {имя_умолчания} [,...n]</p>

<p>если предварительно это ограничение было удалено из всех таблиц процедурой</p>

<p>sp_unbindefault [@objname=] 'object_name'</p>

<p>[,[@futureonly=] 'futureonly_flag']</p>

<p>При <emphasis>создании таблицы</emphasis>, кроме рассмотренных приемов, можно указать необязательное ключевое слово CONSTRAINT, чтобы присвоить ограничению имя, уникальное в пределах базы данных.</p>

<p>Ключевые слова CLUSTERED и NONCLUSTERED позволяют создать для столбца <emphasis>кластерный</emphasis> или <emphasis>некластерный индекс</emphasis>. Для ограничения PRIMARY KEY по умолчанию создается <emphasis>кластерный индекс</emphasis>, а для ограничения UNIQUE - <emphasis>некластерный</emphasis>. В каждой таблице может быть создан лишь один <emphasis>кластерный индекс</emphasis>, отличительной особенностью которого является то, что в соответствии с ним изменяется физический порядок строк в таблице. ASC и DESC определяют метод упорядочения данных в индексе.</p>

<p>С помощью параметра WITH FILLFACTOR=фактор_заполнения задается степень заполнения индексных страниц при создании индекса. Значение фактора заполнения указывается в процентах и может изменяться в промежутке от 0 до 100.</p>

<p>Параметр ON имя_группы_файлов обозначает группу, в которой предполагается хранить таблицу.</p>

<p><strong>Изменение таблицы</strong></p>

<p><emphasis>Изменения в таблицу</emphasis> можно внести командой:</p>

<p>&lt;изменение_таблицы&gt; ::=</p>

<p>ALTER TABLE имя_таблицы</p>

<p>{[ALTER COLUMN имя_столбца</p>

<p>{ тип_данных [(точность[,масштаб])]</p>

<p>[ NULL | NOT NULL ]</p>

<p>| {ADD | DROP } ROWGUIDCOL }]</p>

<p>| ADD { [&lt;определение_столбца&gt;]</p>

<p>| имя_столбца AS выражение } [,...n]</p>

<p>| [WITH CHECK | WITH NOCHECK ]</p>

<p>     ADD  { &lt;ограничение-таблицы&gt; } [,...n]</p>

<p>| DROP</p>

<p>{ [CONSTRAINT ] имя_ограничения</p>

<p>| COLUMN имя_столбца}[,...n]</p>

<p>| {CHECK | NOCHECK } CONSTRAINT</p>

<p>{ALL | имя_ограничения[,...n]}</p>

<p>| {ENABLE | DISABLE } TRIGGER</p>

<p>{ALL | имя_триггера [,...n]}}</p>

<p>В дополнение к уже названным параметрам определим параметр {ENABLE | DISABLE } TRIGGER ALL, предписывающий задействовать или отключить конкретный триггер или все триггера, связанные с таблицей.</p>

<p><strong>Удаление таблицы</strong></p>

<p><emphasis>Удаление таблицы</emphasis> выполняется командой:</p>

<p>DROP TABLE имя_таблицы</p>

<p>Удалить можно любую таблицу, даже системную. К этому вопросу нужно подходить очень осторожно. Однако удалению не подлежат таблицы, если существуют объекты, ссылающиеся на них. К таким объектам относятся таблицы, связанные с удаляемой таблицей посредством <emphasis>внешнего ключа</emphasis>. Поэтому, прежде чем удалять родительскую таблицу, необходимо удалить либо <emphasis>ограничение внешнего ключа</emphasis>, либо дочерние таблицы. Если с таблицей связано хотя бы одно представление, то таблицу также удалить не удастся. Кроме того, связь с таблицей может быть установлена со стороны функций и процедур. Следовательно, перед <emphasis>удалением таблицы</emphasis> необходимо удалить все объекты базы данных, которые на нее ссылаются, либо изменить их таким образом, чтобы ссылок на удаляемую таблицу не было.</p>

<p>CREATE TABLE Товар</p>

<p>(КодТовара INT IDENTITY(1,1) PRIMARY KEY,</p>

<p> Название  VARCHAR(50)       NOT NULL UNIQUE,</p>

<p> Цена      MONEY             NOT NULL,</p>

<p> Тип       VARCHAR(50)       NOT NULL,</p>

<p> Сорт      VARCHAR(50)       NOT NULL</p>

<p>   CHECK(сорт in('первый','второй','третий')),</p>

<p> Город     VARCHAR(50)       NOT NULL,</p>

<p> Остаток   INT</p>

<p>   CHECK(остаток&gt;=0))</p>

<p>Пример 9.1. Создание родительской таблицы Товар с ограничениями.</p>

<p>CREATE TABLE  Клиент</p>

<p>(КодКлиента INT IDENTITY(1,1) PRIMARY KEY,</p>

<p> Фирма           VARCHAR(50)       NOT NULL,</p>

<p> Фамилия    VARCHAR(50)       NOT NULL,</p>

<p> Город      VARCHAR(50)       NOT NULL,</p>

<p> Телефон    CHAR(10)          NOT NULL</p>

<p>   CHECK(Телефон LIKE</p>

<p>     '[1-9][0-9]-[0-9][0-9]-[0-9][0-9]'))</p>

<p>Пример 9.2. Создание родительской таблицы Клиент с ограничениями.</p>

<p>CREATE TABLE Сделка</p>

<p>(КодСделки  INT IDENTITY(1,1) PRIMARY KEY,</p>

<p> КодТовара  INT       NOT NULL,</p>

<p> КодКлиента INT       NOT NULL,</p>

<p> Количество INT       NOT NULL DEFAULT 0,</p>

<p> Дата       DATETIME  NOT NULL DEFAULT</p>

<p>                      GETDATE(),</p>

<p>CONSTRAINT  fk_Товар</p>

<p>FOREIGN KEY(КодТовара)  REFERENCES Товар,</p>

<p>CONSTRAINT  fk_Клиент</p>

<p>FOREIGN KEY(КодКлиента) REFERENCES Клиент)</p>

<p>Пример 9.3. Создание дочерней таблицы Сделка с ограничениями.</p>

<p>CREATE TABLE Склад</p>

<p>(КодТовара     INT PRIMARY KEY,</p>

<p> Остаток       INT)</p>

<p>Пример 9.4. Создание таблицы Склад.</p>

<p>ALTER TABLE Сделка DROP CONSTRAINT fk_Товар</p>

<p>Пример 9.5. Удаление ограничения внешнего ключа.</p>

<p>ALTER TABLE Сделка ADD CONSTRAINT fk_Товар</p>

<p>FOREIGN KEY (КодТовара) REFERENCES товар</p>

<p>ON UPDATE NO ACTION ON DELETE NO ACTION</p>

<p>Пример 9.6. Добавление ограничения внешнего ключа, реализующего декларативную ссылочную целостность.</p>

<p>ALTER TABLE Сделка ADD CONSTRAINT fk_Товар</p>

<p>FOREIGN KEY (КодТовара) REFERENCES Товар</p>

<p>ON UPDATE CASCADE ON DELETE CASCADE</p>

<p>Пример 9.7. Добавления ограничения внешнего ключа, реализующего каскадные обновления и изменения.</p>

<p>ALTER TABLE Товар ADD Налог AS Цена*0.05</p>

<p>ALTER TABLE Товар DROP COLUMN Налог</p>

<p>Пример 9.8. Пример создания и удаления вычисляемого поля.</p>

<p>Пусть создана <emphasis>таблица</emphasis> без ограничений:</p>

<p>CREATE TABLE Товар</p>

<p>(КодТовара     INT,</p>

<p> Название      VARCHAR(20),</p>

<p> Тип           VARCHAR(20),</p>

<p> Дата          DATETIME,</p>

<p> Цена          MONEY,</p>

<p> Остаток       INT)</p>

<p>Рассмотрим примеры внесения в таблицу всевозможных ограничений.</p>

<p><strong>Пример 9.9</strong>. <emphasis>Поле</emphasis> КодТовара необходимо сделать первичным ключом. Выполнение следующей команды будет отвергнуто, поскольку <emphasis>поле</emphasis>КодТовара допускает внесение значений NULL.</p>

<p>ALTER TABLE Товар ADD CONSTRAINT pk1</p>

<p>PRIMARY KEY(КодТовара)</p>

<p>Пример 9.9. Поле КодТовара необходимо сделать первичным ключом.</p>

<p>Сначала нужно изменить объявление столбца КодТовара, запретив внесение значений NULL:</p>

<p>ALTER TABLE Товар</p>

<p>ALTER COLUMN КодТовара INT NOT NULL</p>

<p>И только потом создать <emphasis>ограничение первичного ключа</emphasis>:</p>

<p>ALTER TABLE Товар ADD CONSTRAINT pk1</p>

<p>PRIMARY KEY(КодТовара)</p>

<p><strong>Пример 9.10</strong>. Удалить столбец целого типа и добавить столбец-счетчик.</p>

<p>ALTER TABLE Товар DROP  COLUMN КодТовара</p>

<p>ALTER TABLE Товар ADD</p>

<p>    КодТовара INT IDENTITY(1,1)</p>

<p>Пример 9.10. Удаление столбца целого типа и добавление столбца-счетчика.</p>

<p><strong>Пример 9.11</strong>. Добавить <emphasis>ограничение первичного ключа</emphasis>.</p>

<p>ALTER TABLE Товар ADD CONSTRAINT pk1</p>

<p>PRIMARY KEY(КодТовара)</p>

<p>Пример 9.11. Добавление ограничений первичного ключа.</p>

<p><strong>Пример 9.12</strong>. Изменить столбец, добавив ограничение NOT NULL.</p>

<p>ALTER TABLE Товар ALTER COLUMN</p>

<p>    Название VARCHAR(40) NOT NULL</p>

<p>Пример 9.12. Добавление ограничения NOT NULL.</p>

<p><strong>Пример 9.13</strong>. Добавить ограничение уникальности значения.</p>

<p>ALTER TABLE Товар ADD CONSTRAINT</p>

<p>    u1 UNIQUE(Название)</p>

<p>Пример 9.13. Добавление ограничения уникальности значения.</p>

<p><strong>Пример 9.14</strong>. Создать умолчание и добавить умолчание столбцу.</p>

<p>CREATE DEFAULT df1 AS 0</p>

<p>sp_bindefault 'df1', 'Товар.Остаток'</p><empty-line /><p>CREATE DEFAULT df2 AS GETDATE()</p>

<p>sp_bindefault 'df2', 'Товар.Дата'</p>

<p>Пример 9.14. Создание и добавление умолчания столбцу.</p>

<p><strong>Пример 9.15</strong>. Создать правило и добавить правило столбцу.</p>

<p>CREATE RULE r1 AS @m IN</p>

<p>    ('мебель','бытовая химия','косметика')</p>

<p>sp_bindrule 'r1','Товар.Тип'</p>

<p>Пример 9.15. Создание и добавление правила столбцу.</p><empty-line /><p>Лекция 10</p><empty-line /><p><strong>Определение представления</strong></p>

<p><strong><emphasis>Представления</emphasis></strong>, или <emphasis>просмотры</emphasis> ( VIEW ), представляют собой временные, производные (иначе - виртуальные) таблицы и являются объектами базы данных, информация в которых не хранится постоянно, как в базовых таблицах, а формируется динамически при обращении к ним. Обычные таблицы относятся к базовым, т.е. содержащим данные и постоянно находящимся на устройстве хранения информации. <emphasis>Представление</emphasis> не может существовать само <emphasis>по</emphasis> себе, а определяется только в терминах одной или нескольких таблиц. Применение <emphasis>представлений</emphasis> позволяет разработчику <emphasis>базы данных</emphasis> обеспечить каждому пользователю или группе пользователей наиболее подходящие способы работы с данными, что решает проблему простоты их использования и безопасности. Содержимое <emphasis>представлений</emphasis> выбирается из других таблиц с помощью выполнения запроса, причем при изменении значений в таблицах данные в <emphasis>представлении</emphasis> автоматически меняются. <emphasis>Представление</emphasis> - это фактически тот же <emphasis>запрос</emphasis>, который выполняется всякий раз при участии в какой-либо команде. Результат выполнения этого запроса в каждый момент времени становится содержанием <emphasis>представления</emphasis>. У пользователя создается впечатление, что он работает с настоящей, реально существующей таблицей.</p>

<p>У <emphasis>СУБД</emphasis> есть две возможности <emphasis>реализации представлений</emphasis>. Если его <emphasis>определение</emphasis> простое, то система формирует каждую <emphasis>запись</emphasis> <emphasis>представленияпо</emphasis> мере необходимости, постепенно считывая исходные данные из базовых таблиц. В случае сложного определения <emphasis>СУБД</emphasis> приходится сначала выполнить такую операцию, как материализация <emphasis>представления</emphasis>, т.е. сохранить информацию, из которой состоит <emphasis>представление</emphasis>, во временной таблице. Затем система приступает к выполнению пользовательской команды и формированию ее результатов, после чего временная <emphasis>таблица</emphasis>удаляется.</p>

<p><strong><emphasis>Представление</emphasis></strong> - это предопределенный запрос, хранящийся в базе данных, который выглядит подобно обычной таблице и не требует для своего хранения дисковой памяти. Для хранения <emphasis>представления</emphasis> используется только оперативная <emphasis>память</emphasis>. В отличие от других объектов <emphasis>базы данных</emphasis> <emphasis>представление</emphasis> не занимает дисковой памяти за исключением памяти, необходимой для хранения определения самого <emphasis>представления</emphasis>.</p>

<p>Создания и изменения <emphasis>представлений</emphasis> в стандарте языка и реализации в MS <emphasis>SQL</emphasis> <emphasis>Server</emphasis> совпадают и представлены следующей командой:</p>

<p>&lt;определение_представления&gt; ::=</p>

<p>    { CREATE| ALTER} VIEW имя_представления</p>

<p>    [(имя_столбца [,...n])]</p>

<p>    [WITH ENCRYPTION]</p>

<p>    AS SELECT_оператор</p>

<p>    [WITH CHECK OPTION]</p>

<p>Рассмотрим назначение основных параметров.</p>

<p><emphasis>По</emphasis> умолчанию имена столбцов в <emphasis>представлении</emphasis> соответствуют именам столбцов в исходных таблицах. Явное указание имени столбца требуется для вычисляемых столбцов или при объединении нескольких таблиц, имеющих столбцы с одинаковыми именами. Имена столбцов перечисляются через запятую, в соответствии с порядком их следования в <emphasis>представлении</emphasis>.</p>

<p><emphasis>Параметр</emphasis> WITH ENCRYPTION предписывает серверу шифровать <emphasis>SQL</emphasis>-код запроса, что гарантирует невозможность его несанкционированного просмотра и использования. Если при определении <emphasis>представления</emphasis> необходимо скрыть имена исходных таблиц и столбцов, а также <emphasis>алгоритм</emphasis>объединения данных, необходимо применить этот <emphasis>аргумент</emphasis>.</p>

<p><emphasis>Параметр</emphasis> WITH CHECK OPTION предписывает серверу исполнять проверку изменений, производимых через <emphasis>представление</emphasis>, на соответствие критериям, определенным в операторе SELECT. Это означает, что не допускается выполнение изменений, которые приведут к исчезновению строки из <emphasis>представления</emphasis>. Такое случается, если для <emphasis>представления</emphasis> установлен горизонтальный фильтр и изменение данных приводит к несоответствию строки установленным фильтрам. Использование аргумента WITH CHECK OPTION гарантирует, что сделанные изменения будут отображены в <emphasis>представлении</emphasis>. Если <emphasis>пользователь</emphasis> пытается выполнить изменения, приводящие к исключению строки из <emphasis>представления</emphasis>, при заданном аргументе WITH CHECK OPTION <emphasis>сервер</emphasis> выдаст <emphasis>сообщение об ошибке</emphasis> и все изменения будут отклонены.</p>

<p><strong>Пример 10.1</strong>. Показать в представлении клиентов из Москвы.</p>

<p>Создание представления:</p>

<p>CREATE  VIEW view1 AS</p>

<p>SELECT КодКлиента, Фамилия, ГородКлиента</p>

<p>FROM Клиент</p>

<p>WHERE ГородКлиента='Москва'</p>

<p>Пример 10.1. Представление клиентов из Москвы.</p>

<p><emphasis>Выборка данных</emphasis> из представления:</p>

<p>SELECT * FROM view1</p>

<p>Обращение к <emphasis>представлению</emphasis> осуществляется с помощью оператора SELECT как к обычной таблице.</p>

<p><emphasis>Представление</emphasis> можно использовать в команде так же, как и любую другую таблицу. К <emphasis>представлению</emphasis> можно строить <emphasis>запрос</emphasis>, модифицировать его (если оно отвечает определенным требованиям), соединять с другими таблицами. Содержание <emphasis>представления</emphasis> не фиксировано и обновляется каждый раз, когда на него ссылаются в команде. <emphasis>Представления</emphasis> значительно расширяют возможности управления данными. В частности, это прекрасный способ разрешить <emphasis>доступ</emphasis> к информации в таблице, скрыв часть данных.</p>

<p>Так, в примере 10.1 <emphasis>представление</emphasis> просто ограничивает <emphasis>доступ</emphasis> пользователя к данным таблицы Клиент, позволяя видеть только часть значений.</p>

<p>Выполним команду:</p>

<p>INSERT INTO view1 VALUES (12,'Петров', 'Самара')</p>

<p>Это допустимая <emphasis>команда</emphasis> в <emphasis>представлении</emphasis>, и строка будет добавлена с помощью <emphasis>представления</emphasis> view1 в таблицу Клиент. Однако, когда <emphasis>информация</emphasis> будет добавлена, строка исчезнет из <emphasis>представления</emphasis>, поскольку название города отлично от Москвы. Иногда такой подход может стать проблемой, т.к. данные уже находятся в таблице, но <emphasis>пользователь</emphasis> их не видит и не в состоянии выполнить их удаление или модификацию. Для исключения подобных моментов служит WITH CHECK OPTION в определении <emphasis>представления</emphasis>. Фраза размещается в определении <emphasis>представления</emphasis>, и все команды модификации будут подвергаться проверке.</p>

<p>ALTER VIEW view1</p>

<p>SELECT КодКлиента, Фамилия, ГородКлиента</p>

<p>FROM Клиент</p>

<p>WHERE ГородКлиента='Москва'</p>

<p>WITH CHECK OPTION</p>

<p>Пример 10.2. Создание представления с проверкой команд модификации.</p>

<p>Для такого <emphasis>представления</emphasis> вышеупомянутая вставка значений будет отклонена системой.</p>

<p>Таким образом, <emphasis>представление</emphasis> может изменяться командами модификации <emphasis>DML</emphasis>, но фактически модификация воздействует не на само <emphasis>представление</emphasis>, а на базовую таблицу.</p>

<p><emphasis>Представление</emphasis> удаляется командой:</p>

<p>DROP VIEW имя_представления [,...n]</p>

<p><strong>Обновление данных в представлениях</strong></p>

<p>Не все <emphasis>представления</emphasis> в <emphasis>SQL</emphasis> могут быть модифицированы. <emphasis>Модифицируемое представление</emphasis> определяется следующими критериями:</p>

<p>основывается только на одной базовой таблице;</p>

<p>содержит первичный ключ этой таблицы;</p>

<p>не содержит DISTINCT в своем определении;</p>

<p>не использует GROUP BY или HAVING в своем определении;</p>

<p>по возможности не применяет в своем определении подзапросы;</p>

<p>не использует константы или выражения значений среди выбранных полей вывода;</p>

<p>в <emphasis>просмотр</emphasis> должен быть включен каждый столбец таблицы, имеющий атрибут NOT NULL ;</p>

<p>оператор SELECT <emphasis>просмотра</emphasis> не использует агрегирующие (итоговые) функции, соединения таблиц, хранимые процедуры и функции, определенные пользователем;</p>

<p>основывается на одиночном запросе, поэтому объединение UNION не разрешено.</p>

<p>Если <emphasis>просмотр</emphasis> удовлетворяет этим условиям, к нему могут применяться <emphasis>операторы</emphasis> INSERT, UPDATE, DELETE. Различия между <emphasis>модифицируемыми представлениями</emphasis> и <emphasis>представлениями</emphasis>, предназначенными только для чтения, не случайны. Цели, для которых их используют, различны. С <emphasis>модифицируемыми представлениями</emphasis> в основном обходятся точно так же, как и с базовыми таблицами. Фактически, пользователи не могут даже осознать, является ли <emphasis>объект</emphasis>, который они запрашивают, базовой таблицей или <emphasis>представлением</emphasis>, т.е. прежде всего это средство защиты для сокрытия конфиденциальных или не относящихся к потребностям данного пользователя частей таблицы. <emphasis>Представления</emphasis> в режиме &lt;только для чтения&gt; позволяют получать и форматировать данные более рационально. Они создают <emphasis>целый</emphasis> арсенал сложных запросов, которые можно выполнить и повторить снова, сохраняя полученную информацию. Результаты этих запросов могут затем использоваться в других запросах, что позволит избежать сложных предикатов и снизить <emphasis>вероятность</emphasis> ошибочных действий.</p>

<p>CREATE VIEW view2 AS</p>

<p>SELECT Клиент.Фамилия, Клиент.Фирма,</p>

<p>       Сделка.Количество</p>

<p>FROM Клиент INNER JOIN Сделка</p>

<p>ON Клиент.КодКлиента=Сделка.КодКлиента</p>

<p>Пример 10.3. Немодифицируемое представление с данными из разных таблиц.</p>

<p>CREATE VIEW view3(Тип, Общ_остаток) AS</p>

<p>SELECT Тип, Sum(Остаток)</p>

<p>FROM Товар</p>

<p>GROUP BY Тип</p>

<p>Пример 10.4. Немодифицируемое представление с группировкой и итоговыми функциями.</p>

<p>Обычно в <emphasis>представлениях</emphasis> используются имена, полученные непосредственно из имен полей основной таблицы. Однако иногда необходимо дать столбцам новые имена, например, в случае итоговых функций или вычисляемых столбцов.</p>

<p>CREATE VIEW view4(Код, Название,</p>

<p>    Тип, Цена, Налог) AS</p>

<p>SELECT КодТовара, Название,</p>

<p>Тип, Цена, Цена*0.05 FROM Товар</p>

<p>Пример 10.5. Модифицируемое представление с вычислениями.</p>

<p><strong>Преимущества и недостатки представлений</strong></p>

<p>Механизм <emphasis>представления</emphasis> - мощное средство <emphasis>СУБД</emphasis>, позволяющее скрыть реальную структуру <emphasis>БД</emphasis> от некоторых пользователей за счет определения <emphasis>представлений</emphasis>. Любая <emphasis>реализация представления</emphasis> должна гарантировать, что состояние представляемого отношения точно соответствует состоянию данных, на которых определено это <emphasis>представление</emphasis>. Обычно <emphasis>вычисление</emphasis> <emphasis>представления</emphasis> производится каждый раз при его использовании. Когда <emphasis>представление</emphasis> создается, <emphasis>информация</emphasis> о нем записывается в каталог <emphasis>БД</emphasis> под собственным именем. Любые изменения в данных адекватно отобразятся в <emphasis>представлении</emphasis> - в этом его отличие от очень похожего на него запроса к <emphasis>БД</emphasis>. В то же время <emphasis>запрос</emphasis>представляет собой как бы &lt;мгновенную фотографию&gt; данных и при изменении последних <emphasis>запрос</emphasis> к <emphasis>БД</emphasis> необходимо повторить. Наличие <emphasis>представлений</emphasis> в <emphasis>БД</emphasis> необходимо для обеспечения логической независимости данных. Если система обеспечивает физическую независимость данных, то изменения в физической структуре <emphasis>БД</emphasis> не влияют на работу пользовательских программ. Логическая независимость подразумевает тот факт, что при изменении логической структуры данных влияние на пользовательские программы также не оказывается, а значит, система должна уметь решать проблемы, связанные с ростом и реструктуризацией <emphasis>БД</emphasis>. Очевидно, что с увеличением количества данных, хранимых в <emphasis>БД</emphasis>, возникает необходимость ее расширения за счет добавления новых атрибутов или отношений - это называется ростом <emphasis>БД</emphasis>. Реструктуризация данных подразумевает сохранение той же самой информации, но изменяется ее расположение, например, за счет перегруппировки атрибутов в отношениях. Предположим, некоторое <emphasis>отношение</emphasis> в силу каких-либо причин необходимо разделить на два. Соединение полученных отношений в <emphasis>представлении</emphasis> воссоздает исходное <emphasis>отношение</emphasis>, а у пользователя складывается впечатление, что никакой реструктуризации не производилось. Помимо решения проблемы реструктуризации <emphasis>представление</emphasis> можно применять для просмотра одних и тех же данных разными пользователями и в различных вариантах. С помощью <emphasis>представлений</emphasis> <emphasis>пользователь</emphasis> имеет возможность ограничить объем данных для удобства работы. Наконец, механизм <emphasis>представлений</emphasis> позволяет скрыть служебные данные, не интересные пользователям.</p>

<p>В случае выполнения <emphasis>СУБД</emphasis> на отдельно стоящем персональном компьютере использование <emphasis>представлений</emphasis> обычно имеет целью лишь упрощение структуры запросов к базе данных. Однако в случае многопользовательской сетевой <emphasis>СУБД</emphasis> <emphasis>представления</emphasis> играют ключевую роль в определении структуры <emphasis>базы данных</emphasis> и организации защиты информации. Рассмотрим основные <emphasis>преимущества применения представлений</emphasis> в подобной среде.</p>

<p><strong>Независимость от данных</strong></p>

<p>С помощью <emphasis>представлений</emphasis> можно создать согласованную, неизменную картину структуры базы данных, которая будет оставаться стабильной даже в случае изменения формата исходных таблиц (например, добавления или удаления столбцов, изменения связей, разделения таблиц, их реструктуризации или переименования). Если в таблицу добавляются или из нее удаляются не используемые в <emphasis>представлении</emphasis> столбцы, то изменять определение этого <emphasis>представления</emphasis> не потребуется. Если структура исходной таблицы переупорядочивается или таблица разделяется, можно создать <emphasis>представление</emphasis>, позволяющее работать с виртуальной таблицей прежнего формата. В случае разделения исходной таблицы, прежний формат может быть виртуально воссоздан с помощью <emphasis>представления</emphasis>, построенного на основе соединения вновь созданных таблиц - конечно, если это окажется возможным. Последнее условие можно обеспечить с помощью помещения во все вновь созданные таблицы первичного ключа прежней таблицы.</p>

<p><strong>Актуальность</strong></p>

<p>Изменения данных в любой из таблиц базы данных, указанных в определяющем запросе, немедленно отображается на содержимом <emphasis>представления</emphasis>.</p>

<p><strong>Повышение защищенности данных</strong></p>

<p>Права доступа к данным могут быть предоставлены исключительно через ограниченный набор <emphasis>представлений</emphasis>, содержащих только то подмножество данных, которое необходимо пользователю. Подобный подход позволяет существенно ужесточить контроль за доступом отдельных категорий пользователей к информации в базе данных.</p>

<p><strong>Снижение стоимости</strong></p>

<p><emphasis>Представления</emphasis> позволяют упростить структуру запросов за счет объединения данных из нескольких таблиц в единственную виртуальную таблицу. В результате многотабличные запросы сводятся к простым запросам к одному <emphasis>представлению</emphasis>.</p>

<p><strong>Дополнительные удобства</strong></p>

<p>Создание <emphasis>представлений</emphasis> может обеспечивать пользователей дополнительными удобствами - например, возможностью работы только с действительно нужной частью данных. В результате можно добиться максимального упрощения той модели данных, которая понадобится каждому конечному пользователю.</p>

<p><strong>Возможность настройки</strong></p>

<p><emphasis>Представления</emphasis> являются удобным средством настройки индивидуального образа базы данных. В результате одни и те же таблицы могут быть предъявлены пользователям в совершенно разном виде.</p>

<p><strong>Обеспечение целостности данных</strong></p>

<p>Если в операторе CREATE VIEW будет указана фраза WITH CHECK OPTION, то СУБД станет осуществлять контроль за тем, чтобы в исходные таблицы базы данных не была введена ни одна из строк, не удовлетворяющих предложению WHERE в определяющем запросе. Этот механизм гарантирует целостность данных в <emphasis>представлении</emphasis>.</p>

<p>Практика ограничения доступа некоторых пользователей к данным посредством создания специализированных <emphasis>представлений</emphasis>, безусловно, имеет значительные преимущества перед предоставлением им прямого доступа к таблицам базы данных.</p>

<p>Однако использование <emphasis>представлений</emphasis> в среде SQL не лишено <emphasis>недостатков</emphasis>.</p>

<p><strong>Ограниченные возможности обновления</strong></p>

<p>В некоторых случаях <emphasis>представления</emphasis> не позволяют вносить изменения в содержащиеся в них данные.</p>

<p><strong>Структурные ограничения</strong></p>

<p>Структура <emphasis>представления</emphasis> устанавливается в момент его создания. Если определяющий запрос представлен в форме SELECT * FROM_, то символ * ссылается на все столбцы, существующие в исходной таблице на момент создания <emphasis>представления</emphasis>. Если впоследствии в исходную таблицу базы данных добавятся новые столбцы, то они не появятся в данном <emphasis>представлении</emphasis> до тех пор, пока это <emphasis>представление</emphasis> не будет удалено и вновь создано.</p>

<p><strong>Снижение производительности</strong></p>

<p>Использование <emphasis>представлений</emphasis> связано с определенным снижением производительности. В одних случаях влияние этого фактора совершенно незначительно, тогда как в других оно может послужить источником существенных проблем. Например, <emphasis>представление</emphasis>, определенное с помощью сложного многотабличного запроса, может потребовать значительных затрат времени на обработку, поскольку при его разрешении потребуется выполнять соединение таблиц всякий раз, когда понадобится доступ к данному <emphasis>представлению</emphasis>. Выполнение разрешения <emphasis>представлений</emphasis> связано с использованием дополнительных вычислительных ресурсов.</p><empty-line /><p>Лекция 11</p><empty-line /><empty-line /><p><strong>Основы SQL</strong></p><empty-line /><p>[+]</p>

<p>Записаться</p>

<p>|</p>

<p>Вам нравится?  Нравится 189 студентам</p>

<p> | Поделиться |</p>

<p> Поддержать курс</p>

<p> | Скачать электронную книгу</p>

<p>Лекция 11:</p>

<p>Функции пользователя</p>

<p><strong>A</strong></p>

<p> |</p>

<p>версия для печати</p>

<p>&lt; Лекция 10 || <strong>Лекция 11</strong>: <strong>1</strong>23 || Лекция 12 &gt;</p>

<p><strong>Аннотация: </strong>Дается определение функций пользователя, приводятся примеры их создания и использования. Рассматриваются различные типы функций. Анализируются встроенные функции языка SQL.</p>

<p><strong>Ключевые слова: </strong>SQL, хранимая процедура, архитектура, функция пользователя, server, встроенная функция, поиск, базы данных, скалярная функция пользователя, табличный тип данных, мультитабличная функция, входной параметр, параметр, тип данных, значение, пользователь, слово, множества, константы, скалярный тип, равенство, табличная функция пользователя, сервер, синтаксис, завершение работы, команда, список, математическая функция, строковая функция, функция даты/времени, COTS, radian, soundex</p>

<p><strong>Понятие функции пользователя</strong></p>

<p>При реализации на языке <emphasis>SQL</emphasis> сложных алгоритмов, которые могут потребоваться более одного раза, сразу встает вопрос о сохранении разработанного кода для дальнейшего применения. Эту задачу можно было бы реализовать с помощью <emphasis>хранимых процедур</emphasis>, однако их <emphasis>архитектура</emphasis> не позволяет использовать процедуры непосредственно в выражениях, т.к. они требуют промежуточного присвоения возвращенного значения переменной, которая затем и указывается в выражении. Естественно, подобный метод применения программного кода не слишком удобен. Многие разработчики уже давно хотели иметь возможность вызова разработанных алгоритмов непосредственно в выражениях.</p>

<p>Возможность создания <emphasis>пользовательских функций</emphasis> была предоставлена в среде MS <emphasis>SQL</emphasis> <emphasis>Server</emphasis> 2000. В других реализациях <emphasis>SQL</emphasis> в распоряжении пользователя имеются только <emphasis>встроенные функции</emphasis>, которые обеспечивают выполнение наиболее распространенных алгоритмов: <emphasis>поиск</emphasis>максимального или минимального значения и др.</p>

<p><emphasis>Функции пользователя</emphasis> представляют собой самостоятельные объекты <emphasis>базы данных</emphasis>, такие, например, как <emphasis>хранимые процедуры</emphasis> или триггеры. <emphasis>Функция пользователя</emphasis> располагается в определенной базе данных и доступна только в ее контексте.</p>

<p>В <emphasis>SQL</emphasis> <emphasis>Server</emphasis> имеются следующие классы <emphasis>функций пользователя</emphasis>:</p>

<p><strong><emphasis>Scalar</emphasis></strong> – <emphasis>функции</emphasis> возвращают обычное скалярное значение, каждая может включать множество команд, объединяемых в один блок с помощью конструкции BEGIN...END;</p>

<p><strong>Inline</strong> – <emphasis>функции</emphasis> содержат всего одну команду SELECT и возвращают пользователю набор данных в виде значения <emphasis>типа данных TABLE</emphasis> ;</p>

<p><strong><emphasis>Multi-statement</emphasis></strong> – <emphasis>функции</emphasis> также возвращают пользователю значение <emphasis>типа данных TABLE</emphasis>, содержащее набор данных, однако в теле <emphasis>функции</emphasis> находится множество команд SQL ( INSERT, UPDATE и т.д.). Именно с их помощью и формируется набор данных, который должен быть возвращен после выполнения <emphasis>функции</emphasis> .</p>

<p><strong><emphasis>Пользовательские функции</emphasis></strong> сходны с <emphasis>хранимыми процедурами</emphasis>, но, в отличие от них, могут применяться в запросах так же, как и системные <emphasis>встроенные функции</emphasis>. <emphasis>Пользовательские функции</emphasis>, возвращающие таблицы, могут стать альтернативой просмотрам. Просмотры ограничены одним выражением SELECT, а <emphasis>пользовательские функции</emphasis> способны включать дополнительные выражения, что позволяет создавать более сложные и мощные конструкции.</p>

<p><strong>Функции Scalar</strong></p>

<p>Создание и изменение <emphasis>функции</emphasis> данного типа выполняется с помощью команды:</p>

<p>&lt;определение_скаляр_функции&gt;::=</p>

<p>{CREATE | ALTER } FUNCTION [владелец.]</p>

<p>    имя_функции</p>

<p>( [ { @имя_параметра скаляр_тип_данных</p>

<p>    [=default]}[,...n]])</p>

<p>RETURNS скаляр_тип_данных</p>

<p>[WITH {ENCRYPTION | SCHEMABINDING}</p>

<p>    [,...n] ]</p>

<p>[AS]</p>

<p>BEGIN</p>

<p>&lt;тело_функции&gt;</p>

<p>RETURN скаляр_выражение</p>

<p>END</p>

<p>Рассмотрим назначение параметров команды.</p>

<p><emphasis>Функция</emphasis> может содержать один или несколько <emphasis>входных параметров</emphasis> либо не содержать ни одного. Каждый <emphasis>параметр</emphasis> должен иметь уникальное в пределах создаваемой <emphasis>функции</emphasis> имя и начинаться с символа " @ ". После имени указывается <emphasis>тип данных</emphasis> параметра. Дополнительно можно указать <emphasis>значение</emphasis>, которое будет автоматически присваиваться параметру ( DEFAULT ), если <emphasis>пользователь</emphasis> явно не указал <emphasis>значение</emphasis>соответствующего параметра при вызове <emphasis>функции</emphasis>.</p>

<p>С помощью конструкции RETURNS скаляр_тип_данных указывается, какой <emphasis>тип данных</emphasis> будет иметь возвращаемое <emphasis>функцией</emphasis> <emphasis>значение</emphasis>.</p>

<p>Дополнительные параметры, с которыми должна быть создана <emphasis>функция</emphasis>, могут быть указаны посредством ключевого слова WITH. Благодаря ключевому слову ENCRYPTION код команды, используемый для создания <emphasis>функции</emphasis>, будет зашифрован, и никто не сможет просмотреть его. Эта возможность позволяет скрыть логику работы <emphasis>функции</emphasis>. Кроме того, в теле <emphasis>функции</emphasis> может выполняться обращение к различным объектам <emphasis>базы данных</emphasis>, а потому изменение или удаление соответствующих объектов может привести к нарушению работы <emphasis>функции</emphasis>. Чтобы избежать этого, требуется запретить внесение изменений, указав при создании этой <emphasis>функции</emphasis> ключевое <emphasis>слово</emphasis> SCHEMABINDING.</p>

<p>Между ключевыми словами BEGIN...END указывается набор команд, они и будут являться телом <emphasis>функции</emphasis>.</p>

<p>Когда в ходе выполнения кода <emphasis>функции</emphasis> встречается ключевое <emphasis>слово</emphasis> RETURN, выполнение <emphasis>функции</emphasis> завершается и как результат ее вычисления возвращается <emphasis>значение</emphasis>, указанное непосредственно после слова RETURN. Отметим, что в теле <emphasis>функции</emphasis> разрешается использование <emphasis>множества</emphasis> команд RETURN, которые могут возвращать различные значения. В качестве возвращаемого значения допускаются как обычные <emphasis>константы</emphasis>, так и сложные выражения. Единственное условие – <emphasis>тип данных</emphasis> возвращаемого значения должен совпадать с типом данных, указанным после ключевого слова RETURNS.</p>

<p><strong>Пример 11.1</strong>. Создать и применить функцию <emphasis>скалярного типа</emphasis> для вычисления суммарного количества товара, поступившего за определенную дату. Владелец функции – <emphasis>пользователь</emphasis> с именем user1.</p>

<p>CREATE FUNCTION</p>

<p>    user1.sales(@data DATETIME)</p>

<p>RETURNS INT</p>

<p>AS</p>

<p>BEGIN</p>

<p>DECLARE @c INT</p>

<p>SET @c=(SELECT SUM(количество)</p>

<p>        FROM Сделка</p>

<p>        WHERE дата=@data)</p>

<p>RETURN (@c)</p>

<p>END</p>

<p>11.1. Создание функции скалярного типа для вычисления суммарного количества товара, поступившего за определенную дату.</p>

<p>В качестве <emphasis>входного параметра</emphasis> используется дата. <emphasis>Функция</emphasis> возвращает <emphasis>значение</emphasis> целого типа, полученное из оператора SELECT путем суммирования количества товара из таблицы Сделка. Условием отбора записей для суммирования является <emphasis>равенство</emphasis> даты сделки значению <emphasis>входного параметра</emphasis> <emphasis>функции</emphasis>.</p>

<p>Проиллюстрируем обращение к <emphasis>функции пользователя</emphasis>: определим количество товара, поступившего за 02.11.01:</p>

<p>DECLARE @kol INT</p>

<p>SET @kol=user1.sales ('02.11.01')</p>

<p>SELECT @kol</p>

<p><strong>Функции Inline</strong></p>

<p>Создание и изменение <emphasis>функции</emphasis> этого типа выполняется с помощью команды:</p>

<p>&lt;определение_табл_функции&gt;::=</p>

<p>{CREATE | ALTER } FUNCTION [владелец.]</p>

<p>    имя_функции</p>

<p>( [ { @имя_параметра скаляр_тип_данных</p>

<p>    [=default]}[,...n]])</p>

<p>RETURNS TABLE</p>

<p>[ WITH {ENCRYPTION | SCHEMABINDING}</p>

<p>    [,...n] ]</p>

<p>[AS]</p>

<p>RETURN [(] SELECT_оператор [)]</p>

<p>Основная часть параметров, используемых при создании <emphasis>табличных функций</emphasis>, аналогична параметрам <emphasis>скалярной функции</emphasis>. Тем не менее создание <emphasis>табличных функций</emphasis> имеет свою специфику.</p>

<p>После ключевого слова RETURNS всегда должно указываться ключевое <emphasis>слово</emphasis> TABLE. Таким образом, <emphasis>функция</emphasis> данного типа должна строго возвращать <emphasis>значение</emphasis> <emphasis>типа данных TABLE</emphasis>. Структура возвращаемого значения <emphasis>типа TABLE</emphasis> не указывается явно при описании собственно типа данных. Вместо этого <emphasis>сервер</emphasis> будет автоматически использовать для возвращаемого значения TABLE структуру, возвращаемую запросом SELECT, который является единственной командой <emphasis>функции</emphasis>.</p>

<p>Особенность <emphasis>функции</emphasis> данного типа заключается в том, что структура значения TABLE создается автоматически в ходе выполнения запроса, а не указывается явно при определении типа после ключевого слова RETURNS.</p>

<p>Возвращаемое <emphasis>функцией</emphasis> <emphasis>значение</emphasis> <emphasis>типа TABLE</emphasis> может быть использовано непосредственно в запросе, т.е. в разделе FROM.</p>

<p><strong>Пример 11.2</strong>. Создать и применить функцию табличного типа для определения двух наименований товара с наибольшим остатком.</p>

<p>CREATE FUNCTION user1.itog()</p>

<p>RETURNS TABLE</p>

<p>AS</p>

<p>RETURN (SELECT TOP 2 Товар.Название</p>

<p>   FROM Товар INNER JOIN Склад</p>

<p>   ON Товар.КодТовара=Склад.КодТовара</p>

<p>   ORDER BY Склад.Остаток DESC)</p>

<p>11.2. Создание функции табличного типа для определения двух наименований товара с наибольшим остатком.</p>

<p>Использовать <emphasis>функцию</emphasis> для получения двух наименований товара с наибольшим остатком можно следующим образом:</p>

<p>SELECT Название</p>

<p>FROM user1.itog()</p>

<p><strong>Функции Multi-statement</strong></p>

<p>Создание и изменение <emphasis>функций</emphasis> типа <emphasis>Multi-statement</emphasis> выполняется с помощью следующей команды:</p>

<p>&lt;определение_мульти_функции&gt;::=</p>

<p>{CREATE | ALTER }FUNCTION [владелец.]</p>

<p>    имя_функции</p>

<p>( [ { @имя_параметра скаляр_тип_данных</p>

<p>    [=default]}[,...n]])</p>

<p>RETURNS @имя_параметра TABLE</p>

<p>    &lt;определение_таблицы&gt;</p>

<p>[WITH {ENCRYPTION | SCHEMABINDING}</p>

<p>    [,...n] ]</p>

<p>[AS]</p>

<p>BEGIN</p>

<p>&lt;тело_функции&gt;</p>

<p>RETURN</p>

<p>END</p>

<p>Использование большей части параметров рассматривалось при описании предыдущих <emphasis>функций</emphasis>.</p>

<p>Отметим, что <emphasis>функции</emphasis> данного типа, как и <emphasis>табличные</emphasis>, возвращают <emphasis>значение</emphasis> <emphasis>типа TABLE</emphasis>. Однако, в отличие от <emphasis>табличных функций</emphasis>, при создании <emphasis>функций Multi-statement</emphasis> необходимо явно задать структуру возвращаемого значения. Она указывается непосредственно после ключевого слова TABLE и, таким образом, является частью определения возвращаемого типа данных. <emphasis>Синтаксис</emphasis> конструкции &lt;определение_таблицы&gt; полностью соответствует одноименным структурам, используемым при создании обычных таблиц с помощью команды CREATE TABLE.</p>

<p>Набор возвращаемых данных должен формироваться с помощью команд INSERT, выполняемых в теле <emphasis>функции</emphasis>. Кроме того, в теле <emphasis>функции</emphasis>допускается использование различных конструкций языка <emphasis>SQL</emphasis>, которые могут контролировать значения, размещаемые в выходном наборе строк. При работе с командой INSERT требуется явно указать имя того объекта, куда необходимо вставить строки. Поэтому в <emphasis>функциях</emphasis> типа <emphasis>Multi-statement</emphasis>, в отличие от <emphasis>табличных</emphasis>, необходимо присвоить какое-то имя объекту с <emphasis>типом данных TABLE</emphasis> – оно и указывается как возвращаемое <emphasis>значение</emphasis>.</p>

<p><emphasis>Завершение работы</emphasis> <emphasis>функции</emphasis> происходит в двух случаях: если возникают ошибки выполнения и если появляется ключевое <emphasis>слово</emphasis> RETURN. В отличие от <emphasis>функций скалярного типа</emphasis>, при использовании команды RETURN не нужно указывать возвращаемое <emphasis>значение</emphasis>. <emphasis>Сервер</emphasis>автоматически возвратит набор данных <emphasis>типа TABLE</emphasis>, имя и структура которого была указана после ключевого слова RETURNS. В теле <emphasis>функции</emphasis>может быть указано более одной команды RETURN.</p>

<p>Необходимо отметить, что работа <emphasis>функции</emphasis> завершается только при наличии команды RETURN. Это утверждение верно и в том случае, когда речь идет о достижении конца тела <emphasis>функции</emphasis> – самой последней командой должна быть <emphasis>команда</emphasis> RETURN.</p>

<p><strong>Пример 11.3</strong>. Создать и применить функцию (типа multi-statement), которая для некоторого сотрудника выводит <emphasis>список</emphasis> всех его подчиненных (подчиненных как непосредственно ему, так и опосредствованно через других сотрудников).</p>

<p><emphasis>Список</emphasis> сотрудников с указанием каждого руководителя представлен в таблице emp_mgr со следующей структурой:</p>

<p>CREATE TABLE emp_mgr</p>

<p>(emp CHAR(2) PRIMARY KEY,-- сотрудник</p>

<p>mgr CHAR(2))             -- руководитель</p>

<p>Пример данных в таблице emp_mgr показан ниже. Для упрощения иллюстрации имена сотрудников и их начальников представлены буквами латинского алфавита. У директора организации начальника нет ( NULL ).</p>

<p>emp     mgr</p>

<p>---------</p>

<p>a     NULL</p>

<p>b     a</p>

<p>c     a</p>

<p>d     a</p>

<p>e     f</p>

<p>f     b</p>

<p>g     b</p>

<p>i     c</p>

<p>k     d</p><empty-line /><p>CREATE FUNCTION fn_findReports(@id_emp</p>

<p>    CHAR(2))</p>

<p>RETURNS @report TABLE(empid CHAR(2)</p>

<p>    PRIMARY KEY,</p>

<p>    mgrid CHAR(2))</p>

<p>AS</p>

<p>BEGIN</p>

<p>    DECLARE @r INT</p>

<p>    DECLARE @t TABLE(empid CHAR(2)</p>

<p>        PRIMARY KEY,</p>

<p>        mgrid CHAR(2),</p>

<p>           pr   INT DEFAULT 0)</p>

<p>INSERT @t SELECT emp,mgr,0</p>

<p>        FROM emp_mgr</p>

<p>        WHERE emp=@id_emp</p>

<p>SET @r=@@ROWCOUNT</p>

<p>WHILE @r&gt;0</p>

<p>BEGIN</p>

<p>    UPDATE @t   SET pr=1   WHERE pr=0</p>

<p>    INSERT @t SELECT e.emp, e.mgr,0</p>

<p>        FROM  emp_mgr e, @t t</p>

<p>        WHERE e.mgr=t.empid</p>

<p>            AND t.pr=1</p>

<p>    SET @r=@@ROWCOUNT</p>

<p>    UPDATE @t SET pr=2 WHERE pr=1</p>

<p>END</p>

<p>INSERT @report SELECT empid, mgrid</p>

<p>    FROM @t</p>

<p>RETURN</p>

<p>END</p>

<p>11.3. Создание функции, которая для некоторого сотрудника выводит список всех его подчиненных.</p>

<p>Применим созданную <emphasis>функцию</emphasis> для определения списка подчиненных сотрудника ‘b’:</p>

<p>SELECT * FROM fn_findReports('b')</p>

<p>Оператор возвращает следующие значения:</p>

<p>emp     mgr</p>

<p>-----------</p>

<p>b     a</p>

<p>e     f</p>

<p>f     b</p>

<p>g     b</p>

<p><emphasis>Список</emphasis> подчиненных сотрудника ‘a’ создается с помощью оператора</p>

<p>SELECT * FROM fn_findReports('a')</p><empty-line /><p>emp     mgr</p>

<p>---------</p>

<p>a     NULL</p>

<p>b     a</p>

<p>c     a</p>

<p>d     a</p>

<p>e     f</p>

<p>f     b</p>

<p>g     b</p>

<p>i     c</p>

<p>k     d</p>

<p>Другой оператор формирует <emphasis>список</emphasis> подчиненных сотрудника ‘e’:</p>

<p>SELECT * FROM fn_findReports('e')</p>

<p>emp     mgr</p>

<p>--------</p>

<p>e     f</p>

<p><emphasis>Список</emphasis> подчиненных сотрудника ‘c’ создает следующий оператор:</p>

<p>SELECT * FROM fn_findReports('c')</p>

<p>emp     mgr</p>

<p>--------</p>

<p>c     a</p>

<p>i     c</p>

<p>Удаление любой <emphasis>функции</emphasis> осуществляется командой:</p>

<p>DROP FUNCTION {[ владелец.] имя_функции }</p>

<p>    [,...n]</p>

<p><strong>Встроенные функции</strong></p>

<p><emphasis>Встроенные функции</emphasis>, имеющиеся в распоряжении пользователей при работе с <emphasis>SQL</emphasis>, можно условно разделить на следующие группы:</p>

<p><emphasis>математические функции</emphasis> ;</p>

<p><emphasis>строковые функции</emphasis> ;</p>

<p><emphasis>функции для работы с датой и временем</emphasis> ;</p>

<p>функции конфигурирования;</p>

<p>функции системы безопасности;</p>

<p>функции управления метаданными;</p>

<p>статистические функции.</p>

<p><strong>Математические функции</strong></p>

<p>Краткий обзор <emphasis>математических функций</emphasis> представлен в таблице.</p><empty-line /><p>Таблица 11.1.</p><empty-line /><p>ABS</p>

<p>вычисляет абсолютное значение числа</p><empty-line /><p>ACOS</p>

<p>вычисляет арккосинус</p><empty-line /><p>ASIN</p>

<p>вычисляет арксинус</p><empty-line /><p>ATAN</p>

<p>вычисляет арктангенс</p><empty-line /><p>ATN2</p>

<p>вычисляет арктангенс с учетом квадратов</p><empty-line /><p>CEILING</p>

<p>выполняет округление вверх</p><empty-line /><p>COS</p>

<p>вычисляет косинус угла</p><empty-line /><p><emphasis>COT</emphasis></p>

<p>возвращает котангенс угла</p><empty-line /><p>DEGREES</p>

<p>преобразует значение угла из радиан в градусы</p><empty-line /><p>EXP</p>

<p>возвращает экспоненту</p><empty-line /><p>FLOOR</p>

<p>выполняет округление вниз</p><empty-line /><p>LOG</p>

<p>вычисляет натуральный логарифм</p><empty-line /><p>LOG10</p>

<p>вычисляет десятичный логарифм</p><empty-line /><p>PI</p>

<p>возвращает значение "пи"</p><empty-line /><p>POWER</p>

<p>возводит число в степень</p><empty-line /><p><emphasis>RADIANS</emphasis></p>

<p>преобразует значение угла из градуса в радианы</p><empty-line /><p>RAND</p>

<p>возвращает случайное число</p><empty-line /><p>ROUND</p>

<p>выполняет округление с заданной точностью</p><empty-line /><p>SIGN</p>

<p>определяет знак числа</p><empty-line /><p>SIN</p>

<p>вычисляет синус угла</p><empty-line /><p>SQUARE</p>

<p>выполняет возведение числа в квадрат</p><empty-line /><p>SQRT</p>

<p>извлекает квадратный корень</p><empty-line /><p>TAN</p>

<p>возвращает тангенс угла</p><empty-line /><p>SELECT Товар.Название, Сделка.Количество,</p>

<p>Round(Товар.Цена*Сделка.Количество</p>

<p>    *0.05,1)</p>

<p>AS Налог</p>

<p>FROM Товар INNER JOIN Сделка</p>

<p>    ON Товар.КодТовара=</p>

<p>    Сделка.КодТовара</p>

<p>11.4. Использование функции округления до одного знака после запятой для расчета налога.</p>

<p><strong>Строковые функции</strong></p>

<p>Краткий обзор <emphasis>строковых функций</emphasis> представлен в таблице.</p><empty-line /><p>Таблица 11.2.</p><empty-line /><p>ASCII</p>

<p>возвращает код ASCII левого символа строки</p><empty-line /><p>CHAR</p>

<p>по коду ASCII возвращает символ</p><empty-line /><p>CHARINDEX</p>

<p>определяет порядковый номер символа, с которого начинается вхождение подстроки в строку</p><empty-line /><p>DIFFERENCE</p>

<p>возвращает показатель совпадения строк</p><empty-line /><p>LEFT</p>

<p>возвращает указанное число символов с начала строки</p><empty-line /><p>LEN</p>

<p>возвращает длину строки</p><empty-line /><p>LOWER</p>

<p>переводит все символы строки в нижний регистр</p><empty-line /><p>LTRIM</p>

<p>удаляет пробелы в начале строки</p><empty-line /><p>NCHAR</p>

<p>возвращает по коду символ Unicode</p><empty-line /><p>PATINDEX</p>

<p>выполняет поиск подстроки в строке по указанному шаблону</p><empty-line /><p>REPLACE</p>

<p>заменяет вхождения подстроки на указанное значение</p><empty-line /><p>QUOTENAME</p>

<p>конвертирует строку в формат Unicode</p><empty-line /><p>REPLICATE</p>

<p>выполняет тиражирование строки определенное число раз</p><empty-line /><p>REVERSE</p>

<p>возвращает строку, символы которой записаны в обратном порядке</p><empty-line /><p>RIGHT</p>

<p>возвращает указанное число символов с конца строки</p><empty-line /><p>RTRIM</p>

<p>удаляет пробелы в конце строки</p><empty-line /><p><emphasis>SOUNDEX</emphasis></p>

<p>возвращает код звучания строки</p><empty-line /><p>SPACE</p>

<p>возвращает указанное число пробелов</p><empty-line /><p>STR</p>

<p>выполняет конвертирование значения числового типа в символьный формат</p><empty-line /><p>STUFF</p>

<p>удаляет указанное число символов, заменяя новой подстрокой</p><empty-line /><p>SUBSTRING</p>

<p>возвращает для строки подстроку указанной длины с заданного символа</p><empty-line /><p>UNICODE</p>

<p>возвращает Unicode-код левого символа строки</p><empty-line /><p>UPPER</p>

<p>переводит все символы строки в верхний регистр</p><empty-line /><p>SELECT Фирма, [Фамилия]+""</p>

<p>    +Left([Имя],1)+"."</p>

<p>    +Left([Отчество],1)</p>

<p>    +"." AS ФИО</p>

<p>FROM Клиент</p>

<p>11.5. Использование функции LEFT для получения инициалов клиентов.</p>

<p><strong>Функции для работы с датой и временем</strong></p>

<p>Краткий обзор основных <emphasis>функций для работы с датой и временем</emphasis> представлен в таблице.</p><empty-line /><p>Таблица 11.3.</p><empty-line /><p>DATEADD</p>

<p>добавляет к дате указанное значение дней, месяцев, часов и т.д.</p><empty-line /><p>DATEDIFF</p>

<p>возвращает разницу между указанными частями двух дат</p><empty-line /><p>DATENAME</p>

<p>выделяет из даты указанную часть и возвращает ее в символьном формате</p><empty-line /><p>DATEPART</p>

<p>выделяет из даты указанную часть и возвращает ее в числовом формате</p><empty-line /><p>DAY</p>

<p>возвращает число из указанной даты</p><empty-line /><p>GETDATE</p>

<p>возвращает текущее системное время</p><empty-line /><p>ISDATE</p>

<p>проверяет правильность выражения на соответствие одному из возможных форматов ввода даты</p><empty-line /><p>MONTH</p>

<p>возвращает значение месяца из указанной даты</p><empty-line /><p>YEAR</p>

<p>возвращает значение года из указанной даты</p><empty-line /><p>SELECT Year(Дата) AS Год, Month(Дата)</p>

<p>   AS Месяц,</p>

<p>   Sum(Количество) AS Общ_Количество</p>

<p>FROM Сделка</p>

<p>GROUP BY Year(Дата), Month(Дата)</p>

<p>11.6. Использование функций YEAR и MONTH для определения общего количества товара, проданного за каждый месяц каждого года.</p>

<p>DECLARE @d DATETIME</p>

<p>DECLARE @y INT</p>

<p>SET @d=’29.10.03’</p>

<p>SET @y=DATEPART(yy,@d)</p>

<p>SELECT @y</p>

<p>11.7. Пример выделения из даты значения года.</p><empty-line />
</section>

</body><binary id="_19.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEAZABkAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/2wBDAQoLCw4NDhwQEBw7KC
IoOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozv/w
AARCAASAD8DASIAAhEBAxEB/8QAGgAAAwEBAQEAAAAAAAAAAAAAAAQFAwYCB//EACoQAAIC
AQMDAwQCAwAAAAAAAAECAwQRAAUSBiExEyJRFGFxgUGRUqHB/8QAFAEBAAAAAAAAAAAAAAA
AAAAAAP/EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/APrG9zw1dku2LAzFDC
0jDJGcDPkfjXPbXt1Wl0RWtbtPOtg1hLJN9Q4cMRyAHfz3AA1v19OsmyRbSsirLudqKtjlg
8S2WP8AQOseq4K+3TbC9Gusdh9yihSRR4Q55A/IIGgr9LS7lN01Rk3dWF1o8ychhvJxkfOM
Z0xs12W/t/rzBQ/rSp7RgYWRlH+gNORypMCY25AMVJHyOx1I6dnihgn26SRUtQWJS8bHBwz
sysB/III76Bu5dlg3Xb6qBeFkyByR3HFcjGnicKSBnA8ajWpY7fU23x13WVqiyvPxORGGXi
M/BJ/j7HTe77pFtNaKaUgCSeOEE+BybGf0Mn9aCH07Y2nqSgLNyWGzuDs3qxO/vrnJHAL5X
HyPPnVrYqU9Da1itSvLOzu8ju2SSWJHf8YH61E6v2HabNCS3DUiTdnI+kngHGUy59pyPP3+
2ddTGGWJA55MFHI/J0GU230rMnqT04JX/wAniDH+yNeb1eCamUlhjdUIKqyggEeCNGjQbQI
scCKihVAGABgDSW7UalqJXsVYZmU+0yRhiPxnRo0DFCtXq1UStBHChGeMaBRn9a1kjjkKeo
ivxORyGcdiP+6NGgS2+lUgtSvFVhjYdgyRgED41R0aNB//2Q==
</binary><binary id="_10.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEAZABkAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/2wBDAQoLCw4NDhwQEBw7KC
IoOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozv/w
AARCAAVAEgDASIAAhEBAxEB/8QAGwAAAgIDAQAAAAAAAAAAAAAAAAUDBgECBAf/xAApEAAC
AQQBAgUFAQEAAAAAAAABAgMABAUREgYhEzFBUWEUImJxkbHB/8QAFAEBAAAAAAAAAAAAAAA
AAAAAAP/EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/APWM3PDa4S9ubgbihh
aRhsjehv0/VV7FY60suirW5y08wuDbCWSX6hxJyYcgB33vuABUnX93C+Hiw/1EaS5K5ityC
4BCFtsf1oH+1p1ZDb2DYKSwt0infJQxJNGoHFDvkCfYgaoG/Sr5OTpqyfMBhemPcnIabzOt
/OtbqTG56zyfBV5wSuvJIp14s6+6+jD9V3xTRzqWjbkoYrv5HY1V8fOmU6ftLC2sVvGSMB5
ZdrFCw/LzLD8f6KC2UVX8sZ8J0ZdCW7ku7hIiiSN2ZnY6UDXfzI9zUmPs4poooV+qSSyaMN
LI7gyMACdgnuD/ANoHlVTE3+Kzl5ex5SaF76K6kiFpOwBiVTpeKn3HffzT3M5FcTipr0ry8
PQVQCdkkAdh59zSnqXH9P5TFS3FzbW1zM8ZEEkYHis+vtCkd971QMcJjpcfHdCaV5DLcMyc
25FYx2Rd/AFFdGJhuLfEWcN3J4lxHAiyuTvkwA2f7RQTPbQStykgjdvdlBNZkghmj8OWJJE
7faygjt8UUUGyIqKERQqgaAA0BWQAo0oAA9BRRQLszinyyW8YuREkE6TlTHy5lTsA9x23/l
MQND0360UUGGVW1yUHR2Nj1qJLK0jmM0dtCkp83WMBv7RRQT0UUUH/2Q==
</binary><binary id="_12.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEAZABkAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/2wBDAQoLCw4NDhwQEBw7KC
IoOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozv/w
AARCAAXAGgDASIAAhEBAxEB/8QAGwAAAgMBAQEAAAAAAAAAAAAAAAUCAwQGAQf/xAAwEAAC
AQQBAwIFAwMFAAAAAAABAgMABAURIQYSMRNRFEFhcYEikaEVI1IyQmKCov/EABQBAQAAAAA
AAAAAAAAAAAAAAAD/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwD65k5lt8
Zc3DytEsMTSF01sADfz+1IsMuSn6Rt8lkMxcQ3Mlv67uVj7UBGxsdvgDVS69lc9NnHwnU2S
njtE15/W36v/INZeqoYcZHhY4Wlk9W+hthBLIXjkQ+Qyk64A2KBz0vk7rMdN2WQvYRDPOm2
UAgHkgEA+Njn80zlmigXulkSNd627ACoNdW0RRGniQu/popYDub/ABH1+lc9Z3HxGfzmRvy
PQxmoIFbwgCB3b7nY59hQdIZYwhkLr2Dy2+BSi+ys2Hws17PLFeSSTdtqsS9oYu2o18nfnk
/ekeImhxfQQvpVJlVWvzCBwXkLGNf5Xj6CvchiZbboqxhjLzzYm5hublVBJYhu+QD313E/i
g6aOwuTbAzX83xJHMiaCqfovjX33VWDyr5GK5huFVbyymMFwq+CRyGH0IINZIem8dNbJNFk
sk8TqGV1yEnaR7jR1S/AyRYm0zmckZvg5Jl9BnPMiRoEDb/5EHn80DLG3J6ge8mN5LFFBcv
AkML9hXsOiWI52TzrxrVasKmQRbv4+dpSLhlhLKF/tgAA/c8ndKuoOlsNJFd5lGlx94IzIb
q1maMkgcEgcN+3NN8ZdSx4fHnKyxxXk0SK4Yhe6QryAPfzxQL8nezR9YY22S+eGD0JZrlCV
CFRpV8jyWPv8qf+onp+p3r2a33b4177rmbb4c9U57L3qqFsIo4EZx/oQJ3sfyW/irelrWVe
kbNskGj0XuDE3+1SzMqkewBHH0oHNkZ3aeWS6hnheTcHpLrsXXgnZ2d75opX0Yrv08l5JsN
fTSXWvYO5IH7aooGF5hcbkJ0nu7SOaWM7Rm3tT7j2NWXeOtL6KKO5gEiwuskeyQUYeCCOQa
KKAbGWL/D99rG5tn9SEuuyjf5An58nmvZMdZyzPM9ujO+u8kcPrxseD+aKKCC4mwSyayW1Q
W7AAx/LjWv20Ne2q0QwxwRiOJAqj5UUUGf+lWPayiACNjtowxCH/rvX8VdPaW9zAIJoUeIE
HsI/Twdjj7gUUUGdMNYJIriDfYe5EZ2KKfcKToftV9zZWt40LXNvHK0EgkiLrvsYeCPY0UU
EJsbZTzGaW3R3bXcSOG142PB19aW5hMxfx3+MggiihuI1jhufU5UMNOSPPHyA80UUDa1to7
O0htYhqOGNUUfQDQooooP/2Q==
</binary><binary id="_2.jpg" content-type="image/jpeg">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
</binary><binary id="_1.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEAZABkAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/2wBDAQoLCw4NDhwQEBw7KC
IoOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozv/w
AARCAAbAHEDASIAAhEBAxEB/8QAGwAAAgIDAQAAAAAAAAAAAAAAAAUEBgECAwf/xAAxEAAC
AQQBAgMHAgcBAAAAAAABAgMABAUREiExE1FxBhQiMkFhgVJiBxUWI0OhseH/xAAUAQEAAAA
AAAAAAAAAAAAAAAAA/8QAFBEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEQMRAD8A9moqvX
PiZ32gucW000NjYxI0whkKNNI+yFLDqFAG+ncmoPstjbS2vcrdvPctFZ3rxwSz3UjKFCryH
VtEBiw2aC30VEXKY9vlvrc/CX6Sj5R3Pp962t8jZXZAtruGYsvIcHB2POgk0VHhv7O4Z1hu
YpCg2wVgdDz9K0XKY998b63bivM6lHRfP0oJdFRhkbFioF5ASyeIAJB1X9Xp96FyFk5jCXc
DeKpaPUg+MDuR5igk0VGTI2UkTyrdwlI9c25jS77b9aEv7W4DrbXMUzqpPFHBPT/2g5WE73
sk11yPgB2iiUdiFOi35IP4H3pbnclkbXN4mwsJ4lN/IyurxciiKpLMDsfYfmpfsxr+mMcQd
8rdGPqRs/7pSEkyn8Rrh45TGmKsVj5AA/HKeR7/ALVFBLvstfYbL4y2uZIruHIzGAcY+Dxt
onfcgjp18qY2lw8eQnx8zFyqiWJj3ZCSNH0I16EUmwRW89qMst43vlzjHSOG5ca4K67KhR0
BHYkd6Y3fw+1eNK92tpw3puM/9oG9FFFBBlxcb3kt1FPNbyToElMRHxgb0eoOiNnqKy1nFZ
4iS1tINIsTKiL3JIPn3JP1qbRQVjHWN3Ff4qSW0kRIMSbeVjrSvtOnf9ppdZ467y+AwUVpE
1qbe3ctO2gAGiZQBrqdlgfx51dZYknieKReSOCrDzFc7Ozt7C2S2tYlihToqL2FBXrOH+VW
9lcz2d0bi0tvdggKkFjxARQPm2RvZ7VxWCe3yRVrOcCbFe6xnj0aUFmI79Oh+tWxkV9clDa
Oxsdj50FVYqWUEqdgkdjQVPE43IW2RtLq6tpWZcSYJNa0jArpAN+QPX6muWLx2WxmP8FrFr
x58dwAm4/2ZFXXhEg/I32+++9XOigqeKx17FmInuLSV7Z7GKJzIFUI8ZZtBR9ASoH/AGmmB
tHjjme4tnilFzOyF9fI8hb6Hy1TiigV4iI2sE2LJKGBm8Jh3MbElSPTevxRi8DDiry6uorq
5lkvH5zeKykM2tA9ANdBTPiOXLQ2Om6zQKrf2ftrXI3d5DLKvvsqzTR7HFnUaB7b126Vvbx
+9ZuS+/xQRe7xH9RJ25H26KPwaZVgAKNAAAfQUGaKKKD/2Q==
</binary><binary id="_6.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEAZABkAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/2wBDAQoLCw4NDhwQEBw7KC
IoOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozv/w
AARCAATAFMDASIAAhEBAxEB/8QAGwAAAQUBAQAAAAAAAAAAAAAAAAIDBAUGAQf/xAArEAAC
AQQBAgUDBQEAAAAAAAABAgMABAUREiExBhNBUWEUIpEyQlJicfD/xAAUAQEAAAAAAAAAAAA
AAAAAAAAA/8QAFBEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEQMRAD8A9Xzk8Frg725uVD
RQwNIwProbrO4rF4+w8E2s+VLfUG2Ejy+awk5sOQCkHe+ugBT/AI+uYnw0OIE6JLkrqK3IL
AEIW2x/zQP5pvxZDb2EmBext0iuHyUMSSxqBxQ75An2IGqC38Ktk28M2LZjl9aY9yc/1dzr
fzrW6cxmfs8mEUCS3mkXkkU68WdfdfRh/lT45kmRmjbkASu/kdDWXx88eV8PWdha2S3rJEo
eWTaxQsP7dyw9l6/IoNZUe9v7XHw+bdTLGpOlHcsfYAdSfgUnG2s1lYRW9xdvdyIOsrjRP/
fPWqlLObEX8t9dQvklcki6A5TQqf28P4j+vX3B70FpjMimTt3mSGWHhI0ZSVdMCPj0qZVDh
slB9PdTRLLPHLeSlWhiZx3HfQ6VZw5BJpRGLe6Un1eBlH5IoKfxHlba0zGMsslOLbH3IkaS
R24pI664ox9B1J+dU+uHtHylhfY3y47SPm0i27ARyNrSkgdCRtutO297j86L61uYoJkt7ho
jHKoIIXXXR79d9fioPhfG29hlMs+MQRYuR4xDGh+zzADzZPjqB06bBoNLRRRQMy2drM/OW2
ikb+TICa7LbwTxCKaGOSMEEK6gga7dKKKBaIsaBEUKqjQAGgK6qqihVUKB2AGqKKDtFFFBG
nsLe415isNEn7JGTqe/6SN0mHG20EoljEvJe3KZ2H4J1RRQLlx9lOFE1pBIF3oNGDrfenlV
UUKihVA0ABoCiigVRRRQf//Z
</binary><binary id="_15.jpg" content-type="image/jpeg">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
</binary><binary id="_8.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEAZABkAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/2wBDAQoLCw4NDhwQEBw7KC
IoOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozv/w
AARCAATAE8DASIAAhEBAxEB/8QAGwAAAgMBAQEAAAAAAAAAAAAAAAQBAwUCBgf/xAAsEAAC
AQQBAgUDBAMAAAAAAAABAgMABAUREhMhBiIxQVEUMnFCYYGRFVLB/8QAFAEBAAAAAAAAAAA
AAAAAAAAAAP/EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/APrGangtsJe3Fy
oaKGFpGB99Df8AyvOYbF46x8E2lxlieu1uJZJTKwk5N5gAd733AGqv8f3UbYSPECdElydzF
b6LAEIWBY/jQNVeLobfHphJLC3SK4bJQRRzRqBxU/cCfggaoNbwm2TbwzZNmOf1hQ8+f3a2
ePL99a3Td8+WWVRYW9pJHrzGeZkIP4Cmmopo5gxjbkFYqT+49asoMaTKZPHp1spj4RbD75b
WYydMfLKVB18kb1WwrBlDKQQRsEe9J5W/t7Cxkechi6lUiHdpWPYKB7k1OItpbPD2dtMdyx
QIj9/cAA0DE88NtC008qRRoNs7nQH80lj8zBkrqaGGKZViRXEkicRIrEgFd99eU+1KZDG3A
ygyLR/5KFQONq50YSP1IPtJ/Pf4PtSU/iC2t7zJZCPkelbW6NG6EMrGRxor6770FeGv8Rmr
q8TKSW8mRS6ki+luCNxKrEKFU/I0dj13W1hMY+NiulkkdzLcO6c25FU9EXfwFArP8T43A5L
ETXF1a29xM8ZFvIgHVZ9eUIR33vVbGKhuLfE2cN3J1LiOBFlcne2AGz/dBbLZ2sz85baKRv
8AZkBNTLbwTxdKaGOSMa8jKCO3p2oooO0RI0CIoVV7AKNAUnfYXHZKVZby1SZ1HEMSew/ii
igizwmMsJera2MMcgGg4XbAfk96foooCuGijZuTRqTsHZHx6UUUFUdhZwzGeO0gSU/rWMA/
3TFFFB//2Q==
</binary><binary id="_7.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEAZABkAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/2wBDAQoLCw4NDhwQEBw7KC
IoOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozv/w
AARCAASAEYDASIAAhEBAxEB/8QAGgAAAgMBAQAAAAAAAAAAAAAAAAMCBAUGB//EAC4QAAIC
AgEDAgQEBwAAAAAAAAECAwQAEQUSMVEGIRMicZEUFWGBIzIzQUJSof/EABQBAQAAAAAAAAA
AAAAAAAAAAAD/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwD1jmZoa3C3LF
gbihhaRhsjehvuPpnPcPxtWp6Jq2+XnnWc1xLJMbDhwzfMADvuNgAY/wBfTq/BR8UsirLyd
mKsB1aPSW2x+wOI9WQV+N/I3o11jstyUMMcijsp/mB8ggYGv6Tl5Ob0zSk5cMLjJt+sabWz
07HnWt47jeepcn0rGXhlYdSxTL0sy+R5H0y/HKkoYxt1BWKkjyO+ctQsV+S4Crx9ekL8yIO
pielIG8l+4YeF9/pgdZiLdytRgM9qZIox/kx7nwPJ/TF8ZWs06EcFu2bcq73KV1+37dtn3z
K/CTcbyUl+9C/JIWJjsKOp66n+wj7aHlffyMC7FzK2uLuXK1ebqrdYEUqdLMyrse3f32Myu
C/KOf4aK2LMVy/LEHklD/xY3I9wB3TR9tfpkqXO1K8rssyNHe5No0fft/TB3/zX75X9Ten+
M+JWs8dVir8y9mMwSwDoc/MC5bXdene94HQcLUmo8NVr2ZGlnWMGV2Oyzn3Y/cnDL2GBXm4
+lZk+JPTglf8A2eIMfuRkb1eCamY5YY3RdFVZQQCOxAwwwHQIscCKihVCjQA0BkkjSJAkaK
ijsFGhhhgSwwwwEPVrs3zV4jsNvaD33rf3ytxdStB8R4a8UbE62iAHXj2wwwNDDDDA/9k=
</binary><binary id="_0.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEAZABkAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/2wBDAQoLCw4NDhwQEBw7KC
IoOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozv/w
AARCAAaAD0DASIAAhEBAxEB/8QAGwAAAgMBAQEAAAAAAAAAAAAABAUAAwYCAQf/xAAtEAAC
AgIBAgQGAAcAAAAAAAABAgMEBREAEiEGEzFBIjJRcYGRBxQVI1Jhsf/EABQBAQAAAAAAAAA
AAAAAAAAAAAD/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwD7Nycz9lps3n
7GKWxNXp0YkacwOUeV32QvUO4AA2deuxwPwpjFXJZOY2706VLrwwNNakdSvSuxonR0SRvga
zguQt/yVRpVXqkZgka/5Ox0o/Z4DFk7djM5CpG9eOCmY08xkJJdxvp+b2BX98puvakmwyXF
RXa+3V5YIU9KSdPY/XQPAcwxvHAqNKXkA7uR6n7cQYTI5jMPkSLNVIatt68TiuT5nSBsn4/
r2/HHeRuJj8bZuyHS14mkP4G+Y6jHkcH/AAzGQW75EywNckUxg9RYlyN+xO9b4DnG5i5loM
lAFRL2LsmJjGf7cxA2PXuAQdEex46p2o71OG1F8kyBxv1G/bg2Dq1KuJgNSAwrOomYMdsWY
bJYnuT39eUeGe2JZB8qWrCr9hK2uARLilN2a3BYlryWEVJvL18XTvR7jsdHW+X1atfG01gr
RFYowSFXuSfUn/ZJ4RycDN+HsUJY5ruQpvFckvSWdSDRHchPvpQONMzXkmqRzQqXmqyrOij
1bp9R+VJH54w5OAry2Mh8SYk1muTxVbCfH5PSC6n22Qdc6vYSDI4CXDWpZZIZY/LL9g2vb0
Gu2h7cYKqqNKABv0A51wF6x/0mk8jytO6oqINa6tDSqAPqf+8sxNJsfi4KzkGRV3IR7uTtj
+yeFlQSCQDo7G/bnvA//9k=
</binary><binary id="_21.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEAZABkAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/2wBDAQoLCw4NDhwQEBw7KC
IoOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozv/w
AARCAAVAEcDASIAAhEBAxEB/8QAGwAAAgIDAQAAAAAAAAAAAAAAAAUBBAIDBgf/xAApEAAC
AQQBBAEDBQEAAAAAAAABAgMABAUREgYTITFhFFFxFTJBQpGB/8QAFAEBAAAAAAAAAAAAAAA
AAAAAAP/EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/APZq47qa8nbM4K5jkK
2cWUWAgepGKsCfwD4H/afZPJwRzRYyK7ijvbs8EXmOSjWy2vgevnVc11vbLisFYu2Rdltb6
3eOOQIPAcAkaAPo0HcVQvMZLdz91Mpe2w1rhCyBfz5U1dR0lQPG6ujDYZTsGqlzlILSbtSR
XLNre47aRx/oBFBQuYcjhoGvYshNfQQjlNBcKpYoPZVlA0QPOjsGnSOskauh2rAEH7ik17e
z5a3kx9ha3Kd9SklxPC0aRKfBI5aLHXoAe/dOIolhhSJBpUUKo+BQJ+srlLPpPIXDAlkiPb
0xB5nwvkfJFL5rHG4zpdFuriV7tbYLzjncyyS8f66Oy26jrK4tru9w2EeeLVxerJOpcDUcY
5nf5IFY9Xy2k+M+hxCxS5iZ1Fp9NrnE2wS5I/aoHsmgedOjIjp6x/Vju+7K97fvl8/P3+aK
vwh1hQSsGkCgMR/J/miggwQtJ3DEhcf2Kjf+0SQQza7sSPr1yUHVFFBkqqihUUKo9ADQFUb
yzyM8/O2yrWsetdsQI/n77NFFBpXG5gMCc+5G/I+lj801oooNb2tvIxZ4I2Y+yUBJqY4Yot
9qJE374qBRRQbKKKKD/9k=
</binary><binary id="_4.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEAZABkAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/2wBDAQoLCw4NDhwQEBw7KC
IoOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozv/w
AARCAAaAKEDASIAAhEBAxEB/8QAGwAAAQUBAQAAAAAAAAAAAAAABQACAwQGAQf/xAA7EAAB
AwMCAgcEBgsBAAAAAAABAgMEAAUREiEGMRMUIkFRcYFCYZGhFSMycrGzJTQ1NlJWYnN0lKL
B/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAh
EDEQA/APSbzcrjEvtqgxnWEtXBbiFFbRUpGlGrI7QzmmXObd4E+2RkyoqxOkFlRMcjSAhSs
jt/01HxB+9vDH99/wDKNScRftvhz/OV+UugP12hhuak8QrgLcZSwmOlw52VrUogDOd9ge7w
qu5fnGjDfXHHVpcrqoBCkuIVkgEgjcZT8++gvPSFu3NEJpRSEI6Z5Q54zhKfUg+g99MulxX
EcixY4SqVNcLbWv7KQAVKUfHAHLv2qC2HVf7yVc0uMoH3ejBHzJpt5tMPiICOZL8eTBcC23
46tK2lkdx8jyoOSnLvBlQmkPtykSpAbcK2wktJAKiRjnskjfxFW48hbVydgPKKso6ZlR5lO
cEehx6EUKsi7vBv79muU4XJpMZMhmSpsIWnKinSrGx8c+dXbgdPEtoI5qS+k+WkH8QKAvSq
KSrRGcV0oawknpCM6ffis99KI/mtn/XRQaauKUEJKlEBIGST3UHtU1MiWUJvjc7sk9ElpKf
XIqbiNam+GrktGdQiuYx3dk0E1tedlxuuLJCZHabR/Cj2fUjc+dU+HLhMuSJ65S2nG2ZjjD
C20adSU4BJ3PfkelW5Upq12J2WcBuLGK/RKc/+Vk24Ttp4RszTbrv0nMks6V6iClS19Ivbw
06s0GrnSHIMhiQVEx3FpZdSeSSo4SoepAPn7qv0I4nIVwvPWkg6WStJHiNx8xRZJykE+FBH
Kktw4rsl04baQVq8gKZBD5jJckn61ztqT3Iz7I8qocTn9CKT7K32UK+6XUg/Ku8T3R6z2F+
VGQFyCUtMgjbWtQSnPqc0BaqEeQ41c3YDyirUjpmVHmU5wpPocehFA57D0S98P26NMf6d1x
bstzpDl1CE5Or3FRFFLj2eI7Ooc1dOg+WgH8QKAvSpUqAXcLGi4XOHPVMkNOQipTKUadIKh
g5yk52rtysqblMhyVTH2VQ19I0lvTjVgjJyDnYmidKgzc21ypL9xZS2oOTpDP1+NkMoCSd/
HIVt4mnGXImXxovWWdpYdKWFrSgNI7i4e1nOM422z760VKgGaOpX9T52anNpQT4OIzj4pP8
AzXE2UsTJMyLNeZelL1u5AWk4AAGDywB3USUlKk4UkEc8EU6gqQre3DU66VrekPEF15zGpW
OQ22AHcBVdDfXL91obtQ2lNIPitRBV8AkD1NE6alISnCQAPAUDqVKlQKopMdEuK7GcGUPIK
FeRGDUtKgCpgpvPDqrTOWtC0pDMjQcE6SPkoDPkatzrSzOeiPFxbTkRSi0UY21J0nn7jV0J
SFlQSNRG5xuadQCrpHQ/GYtDKQEuqTrA9lpJBPxwB6065wusXG2voekIcYdJCG1kIUkjtax
37cveaIhI1FWBkjBNOoKd1hG4WuRFB0qcR2FeChuk/ECh1wmwp1uixp7LwEtwIUUD9XcR2s
qPs4KdqO00JSkqISAVHJwOdBnLTDclcWS7upTrsdqMmNHddGNZJ1LKRgbfZGcb4NEkt9cvw
kjdqE0ptJ8XFEavgEgeponTUpCU4SAB4CgdSpUqD//Z
</binary><binary id="_14.jpg" content-type="image/jpeg">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
V1lpEdhtlsYQ2kJSPYDArrSNQVgZAxmuqD/2Q==
</binary><binary id="_9.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEAZABkAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/2wBDAQoLCw4NDhwQEBw7KC
IoOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozv/w
AARCAATAE8DASIAAhEBAxEB/8QAGwAAAwEAAwEAAAAAAAAAAAAAAAMFBAECBgf/xAAsEAAC
AgIBAgQFBAMAAAAAAAABAgMEBREAEiEGEzFRFCJBYXEVQlKRMoHB/8QAFAEBAAAAAAAAAAA
AAAAAAAAAAP/EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/APrGangrYS7Ysq
GihhaRgfrob/5zzmGxeOo+CaljLE+e1cSySmVhJ1N8wAO977gDXH+P7UbYSPECdElydmKvo
sAQhYFj+NA8V4uhr49MJJQrpFYbJQRRzRqB0qf8gT7EDXAb4ez1qniKVfxBHYS15AklndNh
FLME8wj0Oh3JGvfnqEdJEDowZWGwynYI5Aly1Wv4ksD555HqoiQxJ1NIQ77AHsPqT25oxGM
s17kltgtKGUdqETdSA/yJ9A32XQ/PAqzzxVoJJ5nCRRqWdj6AD15LW/mriCaljII4W7p8XO
Udh9D0hTr8E74/PwS2MLYSGMyuOl/LH7wrBiv+wCOaad2tkKy2KsqyRsPUH0+x9j9uAug+T
cv+oQVYh26PIlZ9++9qObOHMOZyS4nFy3WG+gqANE7JYAdh+eBAw1/EZq1cTKSV5MilqSL4
WwRuJVYhQqn3Gjseu+WsJjHxsVpZJHcy2HdOtuoqnoi79goHJ/ifG4HJYiaxaq17EzxkV5E
A81n18oQjvveuWMVDYr4mnDbk8yxHAiyuTvbADZ/vgNlp1Zn65a0UjfyZATzmWvBPF5U0Mc
kY18jKCO3p24cOB2SKOMARxqmhodI1oe3O/DhwDk61gMTclaaxj4XkbuzhdFvyR68OHAbRx
NDGdfwVZYevXV0k99fnmpkV9dahtHY2N6Pvw4cBMdCnDMZ46kCSn96xgH++aOHDgf/Z
</binary><binary id="_13.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEAZABkAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/2wBDAQoLCw4NDhwQEBw7KC
IoOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozv/w
AARCAASABMDASIAAhEBAxEB/8QAGQABAQEAAwAAAAAAAAAAAAAAAAQBAwYH/8QAJRAAAgEE
AQMEAwAAAAAAAAAAAQIDAAQFERIGUXETISJhFTFB/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/
EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/APR7u9a/6nGGWUxW9vAJ7khuJk
LEhE329iTrsK3ORLjMXLkcYUhuLRTJ6anSzKPdkI/uwDo/sGoMliLNer2uMnbrNY5OCOPbj
4rNGTxB8hjr7FbncBhsdjZfx2LgXIzo0VqI1+RdgV34AJJ+qDstldR31jBeQncc8ayL4I2K
Vx4uyGNxVpYhuQtoUi334gClBTJGkqFJEV1YaKsNg1LY28EXJo4Y0bZG1UA67UpQWUpSg//
Z
</binary><binary id="_18.jpg" content-type="image/jpeg">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
</binary><binary id="_5.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEAZABkAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/2wBDAQoLCw4NDhwQEBw7KC
IoOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozv/w
AARCAAVAFMDASIAAhEBAxEB/8QAGwAAAQUBAQAAAAAAAAAAAAAAAAIDBAUGAQf/xAArEAAC
AQQBAwMEAQUAAAAAAAABAgMABAUREgYhYRMxQRRRYnGRIjNCwfD/xAAUAQEAAAAAAAAAAAA
AAAAAAAAA/8QAFBEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEQMRAD8A9Xzc8NrhL25uBu
KGFpGGyN6G/j9Vn8Xj7Sy6KtbnLTzC5NsJJJfqHEnJhsAd977gAU51/dwvh4sP9RGkuSuYr
cguAQhbbH9aB/mkdWRW9hJgZLG3SKd8lDEk0agcUO+QJ+xA1QW/S0mTk6asnzAYXpj3JyGm
9zrfnWt05jM9Z5MIq84JXXksU68WZfuvww/VT4po50Zo25KCV35HY1l8fMmV6es7C1sVu2S
JQ00u1ihYfl7lh+P8ig1lR7y+tcfD6t1Msak6G/dj9gPcnwKTjrWazsY7e4u3upEHeVxon/
vPeqpLOfE38t9cwNkg5JFyBymhU/4hfbiPx0fBoLPG5FMnbvMkMsPCRoyky8WBHj4qZWUmy
ccXSeavrd+fKeUQlSQS7EKvnfIip+Os4poooV+qSWyMQeWR3BkYAE+57g/7oGepMrBZZLGW
d9cfS2N00nqzFuKsVA4oW+Adk+dap4Yi2kyGPu8YyR2iMzzLA44SniQuwOx0TunYb7H5qS/
srqOCVLecxGOZQQwAGzo+/fY34qB0zjLaxzOUlxSCLFyemEjT+2ZRvmyeO6jt22DQaaiiig
ae2glblJBG7fdlBNdlghmj9OWJJE7f0soI7eKKKBSoqKERQqgaAA0BXQAo0oAA+BRRQdooo
oKzMYlspHBEs6wpFcJOy+ny9QqdgHuO26sgND4380UUDMtlaTgCa2hkAJIDxg6J96dVVRQq
qFUDQAGgKKKBVFFFB//Z
</binary><binary id="_16.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEAZABkAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/2wBDAQoLCw4NDhwQEBw7KC
IoOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozv/w
AARCAATAE8DASIAAhEBAxEB/8QAGwAAAgMBAQEAAAAAAAAAAAAAAAQBAwUCBgf/xAAsEAAC
AQQBAgUDBAMAAAAAAAABAgMABAUREhMhBiIxQVEUMnFCYYGRFVLB/8QAFAEBAAAAAAAAAAA
AAAAAAAAAAP/EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/APrGangtsJe3Fy
oaKGFpGB99Df8AyvOYbF46x8E2lxlieu1uJZJTKwk5N5gAd733AGqv8f3UbYSPECdElydzF
b6LAEIWBY/jQNVeLobfHphJLC3SK4bJQRRzRqBxU/cCfggaoNbwm2TbwzZNmOf1hQ8+f3a2
ePL99a3Td8+WWVRYW9pJHrzGeZkIP4Cmmopo5gxjbkFYqT+49asoMaTKZPHp1spj4RbD75b
WYydMfLKVB18kb1WwrBlDKQQRsEe9J5W/t7Cxkechi6lUiHdpWPYKB7k1OItpbPD2dtMdyx
QIj9/cAA0DE88NtC008qRRoNs7nQH80lj8zBkrqaGGKZViRXEkicRIrEgFd99eU+1KZDG3A
ygyLR/5KFQONq50YSP1IPtJ/Pf4PtSU/iC2t7zJZCPkelbW6NG6EMrGRxor6770FeGv8Rmr
q8TKSW8mRS6ki+luCNxKrEKFU/I0dj13W1hMY+NiulkkdzLcO6c25FU9EXfwFArP8T43A5L
ETXF1a29xM8ZFvIgHVZ9eUIR33vVbGKhuLfE2cN3J1LiOBFlcne2AGz/dBbLZ2sz85baKRv
8AZkBNTLbwTxdKaGOSMa8jKCO3p2oooO0RI0CIoVV7AKNAUnfYXHZKVZby1SZ1HEMSew/ii
igizwmMsJera2MMcgGg4XbAfk96foooCuGijZuTRqTsHZHx6UUUFUdhZwzGeO0gSU/rWMA/
3TFFFB//2Q==
</binary><binary id="_3.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEAZABkAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/2wBDAQoLCw4NDhwQEBw7KC
IoOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozv/w
AARCAAbAHsDASIAAhEBAxEB/8QAGwAAAgMBAQEAAAAAAAAAAAAAAAUBAwQGAgf/xAA0EAAC
AQQBAgIHBQkAAAAAAAABAgMABAURIRIxBlETIjJBYXGBFDNSkbMjNTZic3SCobH/xAAUAQE
AAAAAAAAAAAAAAAAAAAAA/8QAFBEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEQMRAD8A+j
5rIZG1z+Jsra4iSG/eRG6ouop0p1bB37685O6y1hkMXbJewut9cGJy1vyoCM3Hrfy148Qfx
b4Y/rT/AKRqzxF+/PDn98/6L0D+pqma6t7cgTTxxkjfrsBxWO+yUtplcdaLCjRXsjIZOs7X
SFu2vh50DKio7cmsVzlIIrOaeBhctEvV6OL1mOzocDnVBuopXa5KY5ybFXKIXW3W4SSMEAq
WKkEHsdj600oCiiqRd2xm9CJ4zJsjo6hvY78UF1Ybqd5L+CwiYqXUyysO6oCBr6k6+QNXLk
LN2VVuoiWbpADjk+XzrBaEt4ryPV3S1gC/ImQ/9oLs/evjcFeX8cqxNbRNJtk6gdDtrY70t
+1ZyDwyuWmurUTpa/aJIWgIT2eorvq2PLdV+PC1xirTERtp8pexW/8AhvqY/ktV+IQ0eVw+
Ou7hrqyyEzQyWpAUHSlgxKgbA0Ng8HdAwt8w1xj8bmQrx296sYlic/d9fsn8yB8j8Kd0o8T
qsfha+CAKI4doBxojRGvqBTYdhQLb/BxZDJWl/JdXEctmSYRGyhVJGjwQd7FTkcLFkry0up
Lq4jezfriEbKAG0Rs7B3wSKZUUHMZDG3swysbwPMby4iUMNaFuOnYHx9vj41qykd1LlcLMl
nK628rvMU0QgMbL588mntFAmzZu761vMdbwSISkZ9IGH7RC3rqOdg9II586qhW6tsnkb9cd
I4MMccEa9ILKoJAHPBLMe/YCngRQxYAdR7nzr1Qc/jLi8Q3t5LhbqO4MfW7TPGGlI9lF0xA
A57+fzpsl3LI69NnJ6NoBKHLL7X4Nb7/6rSyq6lWG1I0QffR24FBia5vJYYlSyeKSaFmLMy
kQvrhW0eeT7vKk9hjbpJsQkto5S1tnWV3I5mfpDk8+XVz79101FBy8WMvUsrTdrp5sg11cK
CNjRYxqfhwg+lNbhDaZqG+P3U8X2eU/hIO0Py2WH1FM6gqGBDAEHuDQKr3AQ3+UtsjLeXSy
2hLQqrL0ISNHjp5486syWFt8le2N6zvHc2Ds0Lro66hogg96ZUUCnIWqzW8GJjJYSOrSljs
iNW6mJ+ZGvqfKm1RobJ0Nn31NB//Z
</binary><binary id="_17.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEAZABkAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/2wBDAQoLCw4NDhwQEBw7KC
IoOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozv/w
AARCAATAE8DASIAAhEBAxEB/8QAGwAAAwEBAAMAAAAAAAAAAAAAAAMFBAIBBgf/xAAuEAAC
AQQBAgUDAgcAAAAAAAABAgMABAUREiExBhNBUWEUInFCkRUWIzJSgcH/xAAUAQEAAAAAAAA
AAAAAAAAAAAAA/8QAFBEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEQMRAD8A+sZqeC2wl7
cXKhooYWkYH10N/wDK9cw2Lx1j4JtLjLE+e1uJZJTKwk5N9wAO976gDVP8f3UbYSPECdEly
dzFb6LAEIWBY/jQNK8XQ2+PTCSWFukVw2SgijmjUDip/uBPsQNUFbwo+S/lezfNFlu+BLmT
owXZ48vnjrdOgz9pd5GOztlklWRWIuFX+kSutgN69/TYpGVsZMpJHPBItzBASsllISscpB7
7Hcj52KUmQhus/joFie2mijm5W8i8So0vb0I+R0oLc88VtBJPM4SKNSzsewA71LW/zV4gms
sZBHC3VPq5yjsPQ8Qp1+Cd0/PwS3GFuEhjMrji/lj9YVgxX/YBFabO9tshbLcWsqyRsO4Pb
4PsfigXYPk3L/xCC1iHTh5ErPv33tRWyisOZyS4nFy3rDfAqANE7JYAdB+aCBhr/EZq6vEy
klvJkUupIvpbgjcSqxChVPuNHY77q1hMY+NiulkkdzLcO6c25FU7Iu/YKBU/xPjcDksRNcX
Vrb3EzxkW8iAeaz6+0IR13vVWMVDcW+Js4buTzLiOBFlcne2AGz+9A2WztZn5y20Ujf5MgJ
rzLbwTxeVNDHJGNfYygjp26UUUHaIkaBEUKq9AFGgKCqlgxUFh2OuooooOqnXWAxN5K01xj
4XkbqzhdFvyR3oooG2OJsMZz+itlh565cSeuvzWpkV9c1DaOxsb0feiigTHYWcMxnjtIElP
61jAP71ooooP/9k=
</binary><binary id="_20.jpg" content-type="image/jpeg">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
</binary><binary id="_11.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEAZABkAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8
lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/2wBDAQoLCw4NDhwQEBw7KC
IoOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozv/w
AARCAAVAFMDASIAAhEBAxEB/8QAGwAAAQUBAQAAAAAAAAAAAAAAAAIDBAUGAQf/xAArEAAC
AQQBAwMEAQUAAAAAAAABAgMABAUREgYhYRMxQRRRYnGRIjNCwfD/xAAUAQEAAAAAAAAAAAA
AAAAAAAAA/8QAFBEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEQMRAD8A9Xzc8NrhL25uBu
KGFpGGyN6G/j9Vn8Xj7Sy6KtbnLTzC5NsJJJfqHEnJhsAd977gAU51/dwvh4sP9RGkuSuYr
cguAQhbbH9aB/mkdWRW9hJgZLG3SKd8lDEk0agcUO+QJ+xA1QW/S0mTk6asnzAYXpj3JyGm
9zrfnWt05jM9Z5MIq84JXXksU68WZfuvww/VT4po50Zo25KCV35HY1l8fMmV6es7C1sVu2S
JQ00u1ihYfl7lh+P8ig1lR7y+tcfD6t1Msak6G/dj9gPcnwKTjrWazsY7e4u3upEHeVxon/
vPeqpLOfE38t9cwNkg5JFyBymhU/4hfbiPx0fBoLPG5FMnbvMkMsPCRoyky8WBHj4qZWUmy
ccXSeavrd+fKeUQlSQS7EKvnfIip+Os4poooV+qSWyMQeWR3BkYAE+57g/7oGepMrBZZLGW
d9cfS2N00nqzFuKsVA4oW+Adk+dap4Yi2kyGPu8YyR2iMzzLA44SniQuwOx0TunYb7H5qS/
srqOCVLecxGOZQQwAGzo+/fY34qB0zjLaxzOUlxSCLFyemEjT+2ZRvmyeO6jt22DQaaiiig
ae2glblJBG7fdlBNdlghmj9OWJJE7f0soI7eKKKBSoqKERQqgaAA0BXQAo0oAA+BRRQdooo
oKzMYlspHBEs6wpFcJOy+ny9QqdgHuO26sgND4380UUDMtlaTgCa2hkAJIDxg6J96dVVRQq
qFUDQAGgKKKBVFFFB//Z
</binary>
</FictionBook>